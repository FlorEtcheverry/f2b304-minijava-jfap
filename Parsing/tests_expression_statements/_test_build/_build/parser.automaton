State 0:
compilationUnit' -> . compilationUnit [ # ]
-- On error shift to state 1
-- On LCURL shift to state 2
-- On compilationUnit shift to state 449
-- On block shift to state 450

State 1:
compilationUnit -> error . [ # ]
-- On # reduce production compilationUnit -> error 

State 2:
block -> LCURL . localVariableDeclAndStmts RCURL [ # ]
block -> LCURL . RCURL [ # ]
-- On error shift to state 3
-- On WHILE shift to state 4
-- On VOID shift to state 6
-- On TRY shift to state 208
-- On THROW shift to state 210
-- On THIS shift to state 7
-- On SYNCHRONIZED shift to state 213
-- On SWITCH shift to state 217
-- On SUPER shift to state 8
-- On STRLIT shift to state 9
-- On SHORT shift to state 10
-- On SEMI shift to state 238
-- On RETURN shift to state 239
-- On RCURL shift to state 446
-- On PLUS shift to state 11
-- On NULLLIT shift to state 12
-- On NOT shift to state 13
-- On NEW shift to state 14
-- On MINUS shift to state 26
-- On LPAR shift to state 27
-- On LONG shift to state 15
-- On LCURL shift to state 243
-- On INTLIT shift to state 28
-- On INT shift to state 16
-- On INCREMENT shift to state 29
-- On IF shift to state 245
-- On IDENTIFIER shift to state 249
-- On FOR shift to state 251
-- On FLOATLIT shift to state 31
-- On FLOAT shift to state 18
-- On FINAL shift to state 254
-- On DOUBLELIT shift to state 32
-- On DOUBLE shift to state 19
-- On DO shift to state 274
-- On DECREMENT shift to state 33
-- On CONTINUE shift to state 387
-- On CHARLIT shift to state 34
-- On CHAR shift to state 20
-- On BYTE shift to state 21
-- On BREAK shift to state 391
-- On BOOLEANLIT shift to state 35
-- On BOOLEAN shift to state 22
-- On BNOT shift to state 36
-- On ASSERT shift to state 395
-- On unaryExpression shift to state 44
-- On typeSpecifier shift to state 422
-- On typeName shift to state 130
-- On statement shift to state 423
-- On specialName shift to state 38
-- On shiftExpression shift to state 58
-- On selectStmt shift to state 402
-- On relationalExpression shift to state 79
-- On realPostfixExpression shift to state 39
-- On qualifiedName shift to state 424
-- On primitiveType shift to state 425
-- On primaryExpression shift to state 64
-- On postfixExpression shift to state 65
-- On plainNewAllocationExpression shift to state 68
-- On notJustName shift to state 69
-- On newAllocationExpression shift to state 72
-- On multiplicativeExpression shift to state 73
-- On methodCall shift to state 75
-- On methodAccess shift to state 76
-- On logicalUnaryOperator shift to state 83
-- On logicalUnaryExpression shift to state 85
-- On localVariableDeclStmt shift to state 426
-- On localVariableDeclOrStmt shift to state 427
-- On localVariableDeclAndStmts shift to state 447
-- On labelStmt shift to state 403
-- On jumpStmt shift to state 404
-- On iterStmt shift to state 405
-- On inclusiveOrExpression shift to state 90
-- On guardingStmt shift to state 406
-- On fieldAccess shift to state 86
-- On expressionStmt shift to state 407
-- On expression shift to state 357
-- On exclusiveOrExpression shift to state 111
-- On equalityExpression shift to state 94
-- On emptyStmt shift to state 409
-- On conditionalOrExpression shift to state 112
-- On conditionalExpression shift to state 151
-- On conditionalAndExpression shift to state 117
-- On complexPrimaryNoParenthesis shift to state 87
-- On complexPrimary shift to state 88
-- On classAllocationExpression shift to state 100
-- On castExpression shift to state 103
-- On block shift to state 410
-- On assignmentExpression shift to state 152
-- On assertStmt shift to state 411
-- On arrayAllocationExpression shift to state 104
-- On arrayAccess shift to state 120
-- On arithmeticUnaryOperator shift to state 121
-- On andExpression shift to state 123
-- On additiveExpression shift to state 140

State 3:
expression -> error . [ SEMI RPAR RCURL RBRAC COMM COL ]
-- On SEMI reduce production expression -> error 
-- On RPAR reduce production expression -> error 
-- On RCURL reduce production expression -> error 
-- On RBRAC reduce production expression -> error 
-- On COMM reduce production expression -> error 
-- On COL reduce production expression -> error 

State 4:
iterStmt -> WHILE . LPAR expression RPAR statement [ error WHILE VOID TRY THROW THIS SYNCHRONIZED SWITCH SUPER STRLIT SHORT SEMI RETURN RCURL PLUS NULLLIT NOT NEW MINUS LPAR LONG LCURL INTLIT INT INCREMENT IF IDENTIFIER FOR FLOATLIT FLOAT FINAL ELSE DOUBLELIT DOUBLE DO DECREMENT CONTINUE CHARLIT CHAR BYTE BREAK BOOLEANLIT BOOLEAN BNOT ASSERT ]
-- On LPAR shift to state 5

State 5:
iterStmt -> WHILE LPAR . expression RPAR statement [ error WHILE VOID TRY THROW THIS SYNCHRONIZED SWITCH SUPER STRLIT SHORT SEMI RETURN RCURL PLUS NULLLIT NOT NEW MINUS LPAR LONG LCURL INTLIT INT INCREMENT IF IDENTIFIER FOR FLOATLIT FLOAT FINAL ELSE DOUBLELIT DOUBLE DO DECREMENT CONTINUE CHARLIT CHAR BYTE BREAK BOOLEANLIT BOOLEAN BNOT ASSERT ]
-- On error shift to state 3
-- On VOID shift to state 6
-- On THIS shift to state 7
-- On SUPER shift to state 8
-- On STRLIT shift to state 9
-- On SHORT shift to state 10
-- On PLUS shift to state 11
-- On NULLLIT shift to state 12
-- On NOT shift to state 13
-- On NEW shift to state 14
-- On MINUS shift to state 26
-- On LPAR shift to state 27
-- On LONG shift to state 15
-- On INTLIT shift to state 28
-- On INT shift to state 16
-- On INCREMENT shift to state 29
-- On IDENTIFIER shift to state 17
-- On FLOATLIT shift to state 31
-- On FLOAT shift to state 18
-- On DOUBLELIT shift to state 32
-- On DOUBLE shift to state 19
-- On DECREMENT shift to state 33
-- On CHARLIT shift to state 34
-- On CHAR shift to state 20
-- On BYTE shift to state 21
-- On BOOLEANLIT shift to state 35
-- On BOOLEAN shift to state 22
-- On BNOT shift to state 36
-- On unaryExpression shift to state 44
-- On specialName shift to state 38
-- On shiftExpression shift to state 58
-- On relationalExpression shift to state 79
-- On realPostfixExpression shift to state 39
-- On qualifiedName shift to state 42
-- On primitiveType shift to state 61
-- On primaryExpression shift to state 64
-- On postfixExpression shift to state 65
-- On plainNewAllocationExpression shift to state 68
-- On notJustName shift to state 69
-- On newAllocationExpression shift to state 72
-- On multiplicativeExpression shift to state 73
-- On methodCall shift to state 75
-- On methodAccess shift to state 76
-- On logicalUnaryOperator shift to state 83
-- On logicalUnaryExpression shift to state 85
-- On inclusiveOrExpression shift to state 90
-- On fieldAccess shift to state 86
-- On expression shift to state 206
-- On exclusiveOrExpression shift to state 111
-- On equalityExpression shift to state 94
-- On conditionalOrExpression shift to state 112
-- On conditionalExpression shift to state 151
-- On conditionalAndExpression shift to state 117
-- On complexPrimaryNoParenthesis shift to state 87
-- On complexPrimary shift to state 88
-- On classAllocationExpression shift to state 100
-- On castExpression shift to state 103
-- On assignmentExpression shift to state 152
-- On arrayAllocationExpression shift to state 104
-- On arrayAccess shift to state 120
-- On arithmeticUnaryOperator shift to state 121
-- On andExpression shift to state 123
-- On additiveExpression shift to state 140

State 6:
primitiveType -> VOID . [ XOR SEMI RPAR RCURL RBRAC QM OR NEQUAL LTHAN LPAR LETHAN LBRAC INSTANCEOF IDENTIFIER GTHAN GETHAN EQUAL DOT DIM COMM COL BOR BAND AND ]
-- On XOR reduce production primitiveType -> VOID 
-- On SEMI reduce production primitiveType -> VOID 
-- On RPAR reduce production primitiveType -> VOID 
-- On RCURL reduce production primitiveType -> VOID 
-- On RBRAC reduce production primitiveType -> VOID 
-- On QM reduce production primitiveType -> VOID 
-- On OR reduce production primitiveType -> VOID 
-- On NEQUAL reduce production primitiveType -> VOID 
-- On LTHAN reduce production primitiveType -> VOID 
-- On LPAR reduce production primitiveType -> VOID 
-- On LETHAN reduce production primitiveType -> VOID 
-- On LBRAC reduce production primitiveType -> VOID 
-- On INSTANCEOF reduce production primitiveType -> VOID 
-- On IDENTIFIER reduce production primitiveType -> VOID 
-- On GTHAN reduce production primitiveType -> VOID 
-- On GETHAN reduce production primitiveType -> VOID 
-- On EQUAL reduce production primitiveType -> VOID 
-- On DOT reduce production primitiveType -> VOID 
-- On DIM reduce production primitiveType -> VOID 
-- On COMM reduce production primitiveType -> VOID 
-- On COL reduce production primitiveType -> VOID 
-- On BOR reduce production primitiveType -> VOID 
-- On BAND reduce production primitiveType -> VOID 
-- On AND reduce production primitiveType -> VOID 

State 7:
specialName -> THIS . [ XOREQUAL XOR SEMI RSHIFTEQUAL RSHIFT RPAR RCURL RBRAC QM PLUS PEQUAL OREQUAL OR NEQUAL MULEQUAL MUL MODEQUAL MOD MINUSEQUAL MINUS LTHAN LSHIFTEQUAL LSHIFT LPAR LOGSHIFTEQUAL LOGSHIFT LETHAN INSTANCEOF INCREMENT GTHAN GETHAN EQUAL DOT DIVEQUAL DIV DECREMENT COMM COL BOR BAND ASSIGN ANDEQUAL AND ]
-- On XOREQUAL reduce production specialName -> THIS 
-- On XOR reduce production specialName -> THIS 
-- On SEMI reduce production specialName -> THIS 
-- On RSHIFTEQUAL reduce production specialName -> THIS 
-- On RSHIFT reduce production specialName -> THIS 
-- On RPAR reduce production specialName -> THIS 
-- On RCURL reduce production specialName -> THIS 
-- On RBRAC reduce production specialName -> THIS 
-- On QM reduce production specialName -> THIS 
-- On PLUS reduce production specialName -> THIS 
-- On PEQUAL reduce production specialName -> THIS 
-- On OREQUAL reduce production specialName -> THIS 
-- On OR reduce production specialName -> THIS 
-- On NEQUAL reduce production specialName -> THIS 
-- On MULEQUAL reduce production specialName -> THIS 
-- On MUL reduce production specialName -> THIS 
-- On MODEQUAL reduce production specialName -> THIS 
-- On MOD reduce production specialName -> THIS 
-- On MINUSEQUAL reduce production specialName -> THIS 
-- On MINUS reduce production specialName -> THIS 
-- On LTHAN reduce production specialName -> THIS 
-- On LSHIFTEQUAL reduce production specialName -> THIS 
-- On LSHIFT reduce production specialName -> THIS 
-- On LPAR reduce production specialName -> THIS 
-- On LOGSHIFTEQUAL reduce production specialName -> THIS 
-- On LOGSHIFT reduce production specialName -> THIS 
-- On LETHAN reduce production specialName -> THIS 
-- On INSTANCEOF reduce production specialName -> THIS 
-- On INCREMENT reduce production specialName -> THIS 
-- On GTHAN reduce production specialName -> THIS 
-- On GETHAN reduce production specialName -> THIS 
-- On EQUAL reduce production specialName -> THIS 
-- On DOT reduce production specialName -> THIS 
-- On DIVEQUAL reduce production specialName -> THIS 
-- On DIV reduce production specialName -> THIS 
-- On DECREMENT reduce production specialName -> THIS 
-- On COMM reduce production specialName -> THIS 
-- On COL reduce production specialName -> THIS 
-- On BOR reduce production specialName -> THIS 
-- On BAND reduce production specialName -> THIS 
-- On ASSIGN reduce production specialName -> THIS 
-- On ANDEQUAL reduce production specialName -> THIS 
-- On AND reduce production specialName -> THIS 

State 8:
specialName -> SUPER . [ XOREQUAL XOR SEMI RSHIFTEQUAL RSHIFT RPAR RCURL RBRAC QM PLUS PEQUAL OREQUAL OR NEQUAL MULEQUAL MUL MODEQUAL MOD MINUSEQUAL MINUS LTHAN LSHIFTEQUAL LSHIFT LPAR LOGSHIFTEQUAL LOGSHIFT LETHAN INSTANCEOF INCREMENT GTHAN GETHAN EQUAL DOT DIVEQUAL DIV DECREMENT COMM COL BOR BAND ASSIGN ANDEQUAL AND ]
-- On XOREQUAL reduce production specialName -> SUPER 
-- On XOR reduce production specialName -> SUPER 
-- On SEMI reduce production specialName -> SUPER 
-- On RSHIFTEQUAL reduce production specialName -> SUPER 
-- On RSHIFT reduce production specialName -> SUPER 
-- On RPAR reduce production specialName -> SUPER 
-- On RCURL reduce production specialName -> SUPER 
-- On RBRAC reduce production specialName -> SUPER 
-- On QM reduce production specialName -> SUPER 
-- On PLUS reduce production specialName -> SUPER 
-- On PEQUAL reduce production specialName -> SUPER 
-- On OREQUAL reduce production specialName -> SUPER 
-- On OR reduce production specialName -> SUPER 
-- On NEQUAL reduce production specialName -> SUPER 
-- On MULEQUAL reduce production specialName -> SUPER 
-- On MUL reduce production specialName -> SUPER 
-- On MODEQUAL reduce production specialName -> SUPER 
-- On MOD reduce production specialName -> SUPER 
-- On MINUSEQUAL reduce production specialName -> SUPER 
-- On MINUS reduce production specialName -> SUPER 
-- On LTHAN reduce production specialName -> SUPER 
-- On LSHIFTEQUAL reduce production specialName -> SUPER 
-- On LSHIFT reduce production specialName -> SUPER 
-- On LPAR reduce production specialName -> SUPER 
-- On LOGSHIFTEQUAL reduce production specialName -> SUPER 
-- On LOGSHIFT reduce production specialName -> SUPER 
-- On LETHAN reduce production specialName -> SUPER 
-- On INSTANCEOF reduce production specialName -> SUPER 
-- On INCREMENT reduce production specialName -> SUPER 
-- On GTHAN reduce production specialName -> SUPER 
-- On GETHAN reduce production specialName -> SUPER 
-- On EQUAL reduce production specialName -> SUPER 
-- On DOT reduce production specialName -> SUPER 
-- On DIVEQUAL reduce production specialName -> SUPER 
-- On DIV reduce production specialName -> SUPER 
-- On DECREMENT reduce production specialName -> SUPER 
-- On COMM reduce production specialName -> SUPER 
-- On COL reduce production specialName -> SUPER 
-- On BOR reduce production specialName -> SUPER 
-- On BAND reduce production specialName -> SUPER 
-- On ASSIGN reduce production specialName -> SUPER 
-- On ANDEQUAL reduce production specialName -> SUPER 
-- On AND reduce production specialName -> SUPER 

State 9:
complexPrimaryNoParenthesis -> STRLIT . [ XOREQUAL XOR SEMI RSHIFTEQUAL RSHIFT RPAR RCURL RBRAC QM PLUS PEQUAL OREQUAL OR NEQUAL MULEQUAL MUL MODEQUAL MOD MINUSEQUAL MINUS LTHAN LSHIFTEQUAL LSHIFT LPAR LOGSHIFTEQUAL LOGSHIFT LETHAN LBRAC INSTANCEOF INCREMENT GTHAN GETHAN EQUAL DOT DIVEQUAL DIV DECREMENT COMM COL BOR BAND ASSIGN ANDEQUAL AND ]
-- On XOREQUAL reduce production complexPrimaryNoParenthesis -> STRLIT 
-- On XOR reduce production complexPrimaryNoParenthesis -> STRLIT 
-- On SEMI reduce production complexPrimaryNoParenthesis -> STRLIT 
-- On RSHIFTEQUAL reduce production complexPrimaryNoParenthesis -> STRLIT 
-- On RSHIFT reduce production complexPrimaryNoParenthesis -> STRLIT 
-- On RPAR reduce production complexPrimaryNoParenthesis -> STRLIT 
-- On RCURL reduce production complexPrimaryNoParenthesis -> STRLIT 
-- On RBRAC reduce production complexPrimaryNoParenthesis -> STRLIT 
-- On QM reduce production complexPrimaryNoParenthesis -> STRLIT 
-- On PLUS reduce production complexPrimaryNoParenthesis -> STRLIT 
-- On PEQUAL reduce production complexPrimaryNoParenthesis -> STRLIT 
-- On OREQUAL reduce production complexPrimaryNoParenthesis -> STRLIT 
-- On OR reduce production complexPrimaryNoParenthesis -> STRLIT 
-- On NEQUAL reduce production complexPrimaryNoParenthesis -> STRLIT 
-- On MULEQUAL reduce production complexPrimaryNoParenthesis -> STRLIT 
-- On MUL reduce production complexPrimaryNoParenthesis -> STRLIT 
-- On MODEQUAL reduce production complexPrimaryNoParenthesis -> STRLIT 
-- On MOD reduce production complexPrimaryNoParenthesis -> STRLIT 
-- On MINUSEQUAL reduce production complexPrimaryNoParenthesis -> STRLIT 
-- On MINUS reduce production complexPrimaryNoParenthesis -> STRLIT 
-- On LTHAN reduce production complexPrimaryNoParenthesis -> STRLIT 
-- On LSHIFTEQUAL reduce production complexPrimaryNoParenthesis -> STRLIT 
-- On LSHIFT reduce production complexPrimaryNoParenthesis -> STRLIT 
-- On LPAR reduce production complexPrimaryNoParenthesis -> STRLIT 
-- On LOGSHIFTEQUAL reduce production complexPrimaryNoParenthesis -> STRLIT 
-- On LOGSHIFT reduce production complexPrimaryNoParenthesis -> STRLIT 
-- On LETHAN reduce production complexPrimaryNoParenthesis -> STRLIT 
-- On LBRAC reduce production complexPrimaryNoParenthesis -> STRLIT 
-- On INSTANCEOF reduce production complexPrimaryNoParenthesis -> STRLIT 
-- On INCREMENT reduce production complexPrimaryNoParenthesis -> STRLIT 
-- On GTHAN reduce production complexPrimaryNoParenthesis -> STRLIT 
-- On GETHAN reduce production complexPrimaryNoParenthesis -> STRLIT 
-- On EQUAL reduce production complexPrimaryNoParenthesis -> STRLIT 
-- On DOT reduce production complexPrimaryNoParenthesis -> STRLIT 
-- On DIVEQUAL reduce production complexPrimaryNoParenthesis -> STRLIT 
-- On DIV reduce production complexPrimaryNoParenthesis -> STRLIT 
-- On DECREMENT reduce production complexPrimaryNoParenthesis -> STRLIT 
-- On COMM reduce production complexPrimaryNoParenthesis -> STRLIT 
-- On COL reduce production complexPrimaryNoParenthesis -> STRLIT 
-- On BOR reduce production complexPrimaryNoParenthesis -> STRLIT 
-- On BAND reduce production complexPrimaryNoParenthesis -> STRLIT 
-- On ASSIGN reduce production complexPrimaryNoParenthesis -> STRLIT 
-- On ANDEQUAL reduce production complexPrimaryNoParenthesis -> STRLIT 
-- On AND reduce production complexPrimaryNoParenthesis -> STRLIT 

State 10:
primitiveType -> SHORT . [ XOR SEMI RPAR RCURL RBRAC QM OR NEQUAL LTHAN LPAR LETHAN LBRAC INSTANCEOF IDENTIFIER GTHAN GETHAN EQUAL DOT DIM COMM COL BOR BAND AND ]
-- On XOR reduce production primitiveType -> SHORT 
-- On SEMI reduce production primitiveType -> SHORT 
-- On RPAR reduce production primitiveType -> SHORT 
-- On RCURL reduce production primitiveType -> SHORT 
-- On RBRAC reduce production primitiveType -> SHORT 
-- On QM reduce production primitiveType -> SHORT 
-- On OR reduce production primitiveType -> SHORT 
-- On NEQUAL reduce production primitiveType -> SHORT 
-- On LTHAN reduce production primitiveType -> SHORT 
-- On LPAR reduce production primitiveType -> SHORT 
-- On LETHAN reduce production primitiveType -> SHORT 
-- On LBRAC reduce production primitiveType -> SHORT 
-- On INSTANCEOF reduce production primitiveType -> SHORT 
-- On IDENTIFIER reduce production primitiveType -> SHORT 
-- On GTHAN reduce production primitiveType -> SHORT 
-- On GETHAN reduce production primitiveType -> SHORT 
-- On EQUAL reduce production primitiveType -> SHORT 
-- On DOT reduce production primitiveType -> SHORT 
-- On DIM reduce production primitiveType -> SHORT 
-- On COMM reduce production primitiveType -> SHORT 
-- On COL reduce production primitiveType -> SHORT 
-- On BOR reduce production primitiveType -> SHORT 
-- On BAND reduce production primitiveType -> SHORT 
-- On AND reduce production primitiveType -> SHORT 

State 11:
arithmeticUnaryOperator -> PLUS . [ VOID THIS SUPER STRLIT SHORT PLUS NULLLIT NOT NEW MINUS LPAR LONG INTLIT INT INCREMENT IDENTIFIER FLOATLIT FLOAT DOUBLELIT DOUBLE DECREMENT CHARLIT CHAR BYTE BOOLEANLIT BOOLEAN BNOT ]
-- On VOID reduce production arithmeticUnaryOperator -> PLUS 
-- On THIS reduce production arithmeticUnaryOperator -> PLUS 
-- On SUPER reduce production arithmeticUnaryOperator -> PLUS 
-- On STRLIT reduce production arithmeticUnaryOperator -> PLUS 
-- On SHORT reduce production arithmeticUnaryOperator -> PLUS 
-- On PLUS reduce production arithmeticUnaryOperator -> PLUS 
-- On NULLLIT reduce production arithmeticUnaryOperator -> PLUS 
-- On NOT reduce production arithmeticUnaryOperator -> PLUS 
-- On NEW reduce production arithmeticUnaryOperator -> PLUS 
-- On MINUS reduce production arithmeticUnaryOperator -> PLUS 
-- On LPAR reduce production arithmeticUnaryOperator -> PLUS 
-- On LONG reduce production arithmeticUnaryOperator -> PLUS 
-- On INTLIT reduce production arithmeticUnaryOperator -> PLUS 
-- On INT reduce production arithmeticUnaryOperator -> PLUS 
-- On INCREMENT reduce production arithmeticUnaryOperator -> PLUS 
-- On IDENTIFIER reduce production arithmeticUnaryOperator -> PLUS 
-- On FLOATLIT reduce production arithmeticUnaryOperator -> PLUS 
-- On FLOAT reduce production arithmeticUnaryOperator -> PLUS 
-- On DOUBLELIT reduce production arithmeticUnaryOperator -> PLUS 
-- On DOUBLE reduce production arithmeticUnaryOperator -> PLUS 
-- On DECREMENT reduce production arithmeticUnaryOperator -> PLUS 
-- On CHARLIT reduce production arithmeticUnaryOperator -> PLUS 
-- On CHAR reduce production arithmeticUnaryOperator -> PLUS 
-- On BYTE reduce production arithmeticUnaryOperator -> PLUS 
-- On BOOLEANLIT reduce production arithmeticUnaryOperator -> PLUS 
-- On BOOLEAN reduce production arithmeticUnaryOperator -> PLUS 
-- On BNOT reduce production arithmeticUnaryOperator -> PLUS 

State 12:
specialName -> NULLLIT . [ XOREQUAL XOR SEMI RSHIFTEQUAL RSHIFT RPAR RCURL RBRAC QM PLUS PEQUAL OREQUAL OR NEQUAL MULEQUAL MUL MODEQUAL MOD MINUSEQUAL MINUS LTHAN LSHIFTEQUAL LSHIFT LPAR LOGSHIFTEQUAL LOGSHIFT LETHAN INSTANCEOF INCREMENT GTHAN GETHAN EQUAL DOT DIVEQUAL DIV DECREMENT COMM COL BOR BAND ASSIGN ANDEQUAL AND ]
-- On XOREQUAL reduce production specialName -> NULLLIT 
-- On XOR reduce production specialName -> NULLLIT 
-- On SEMI reduce production specialName -> NULLLIT 
-- On RSHIFTEQUAL reduce production specialName -> NULLLIT 
-- On RSHIFT reduce production specialName -> NULLLIT 
-- On RPAR reduce production specialName -> NULLLIT 
-- On RCURL reduce production specialName -> NULLLIT 
-- On RBRAC reduce production specialName -> NULLLIT 
-- On QM reduce production specialName -> NULLLIT 
-- On PLUS reduce production specialName -> NULLLIT 
-- On PEQUAL reduce production specialName -> NULLLIT 
-- On OREQUAL reduce production specialName -> NULLLIT 
-- On OR reduce production specialName -> NULLLIT 
-- On NEQUAL reduce production specialName -> NULLLIT 
-- On MULEQUAL reduce production specialName -> NULLLIT 
-- On MUL reduce production specialName -> NULLLIT 
-- On MODEQUAL reduce production specialName -> NULLLIT 
-- On MOD reduce production specialName -> NULLLIT 
-- On MINUSEQUAL reduce production specialName -> NULLLIT 
-- On MINUS reduce production specialName -> NULLLIT 
-- On LTHAN reduce production specialName -> NULLLIT 
-- On LSHIFTEQUAL reduce production specialName -> NULLLIT 
-- On LSHIFT reduce production specialName -> NULLLIT 
-- On LPAR reduce production specialName -> NULLLIT 
-- On LOGSHIFTEQUAL reduce production specialName -> NULLLIT 
-- On LOGSHIFT reduce production specialName -> NULLLIT 
-- On LETHAN reduce production specialName -> NULLLIT 
-- On INSTANCEOF reduce production specialName -> NULLLIT 
-- On INCREMENT reduce production specialName -> NULLLIT 
-- On GTHAN reduce production specialName -> NULLLIT 
-- On GETHAN reduce production specialName -> NULLLIT 
-- On EQUAL reduce production specialName -> NULLLIT 
-- On DOT reduce production specialName -> NULLLIT 
-- On DIVEQUAL reduce production specialName -> NULLLIT 
-- On DIV reduce production specialName -> NULLLIT 
-- On DECREMENT reduce production specialName -> NULLLIT 
-- On COMM reduce production specialName -> NULLLIT 
-- On COL reduce production specialName -> NULLLIT 
-- On BOR reduce production specialName -> NULLLIT 
-- On BAND reduce production specialName -> NULLLIT 
-- On ASSIGN reduce production specialName -> NULLLIT 
-- On ANDEQUAL reduce production specialName -> NULLLIT 
-- On AND reduce production specialName -> NULLLIT 

State 13:
logicalUnaryOperator -> NOT . [ VOID THIS SUPER STRLIT SHORT PLUS NULLLIT NOT NEW MINUS LPAR LONG INTLIT INT INCREMENT IDENTIFIER FLOATLIT FLOAT DOUBLELIT DOUBLE DECREMENT CHARLIT CHAR BYTE BOOLEANLIT BOOLEAN BNOT ]
-- On VOID reduce production logicalUnaryOperator -> NOT 
-- On THIS reduce production logicalUnaryOperator -> NOT 
-- On SUPER reduce production logicalUnaryOperator -> NOT 
-- On STRLIT reduce production logicalUnaryOperator -> NOT 
-- On SHORT reduce production logicalUnaryOperator -> NOT 
-- On PLUS reduce production logicalUnaryOperator -> NOT 
-- On NULLLIT reduce production logicalUnaryOperator -> NOT 
-- On NOT reduce production logicalUnaryOperator -> NOT 
-- On NEW reduce production logicalUnaryOperator -> NOT 
-- On MINUS reduce production logicalUnaryOperator -> NOT 
-- On LPAR reduce production logicalUnaryOperator -> NOT 
-- On LONG reduce production logicalUnaryOperator -> NOT 
-- On INTLIT reduce production logicalUnaryOperator -> NOT 
-- On INT reduce production logicalUnaryOperator -> NOT 
-- On INCREMENT reduce production logicalUnaryOperator -> NOT 
-- On IDENTIFIER reduce production logicalUnaryOperator -> NOT 
-- On FLOATLIT reduce production logicalUnaryOperator -> NOT 
-- On FLOAT reduce production logicalUnaryOperator -> NOT 
-- On DOUBLELIT reduce production logicalUnaryOperator -> NOT 
-- On DOUBLE reduce production logicalUnaryOperator -> NOT 
-- On DECREMENT reduce production logicalUnaryOperator -> NOT 
-- On CHARLIT reduce production logicalUnaryOperator -> NOT 
-- On CHAR reduce production logicalUnaryOperator -> NOT 
-- On BYTE reduce production logicalUnaryOperator -> NOT 
-- On BOOLEANLIT reduce production logicalUnaryOperator -> NOT 
-- On BOOLEAN reduce production logicalUnaryOperator -> NOT 
-- On BNOT reduce production logicalUnaryOperator -> NOT 

State 14:
arrayAllocationExpression -> NEW . typeName dimExprs dims [ XOREQUAL XOR SEMI RSHIFTEQUAL RSHIFT RPAR RCURL RBRAC QM PLUS PEQUAL OREQUAL OR NEQUAL MULEQUAL MUL MODEQUAL MOD MINUSEQUAL MINUS LTHAN LSHIFTEQUAL LSHIFT LOGSHIFTEQUAL LOGSHIFT LETHAN LCURL INSTANCEOF INCREMENT GTHAN GETHAN EQUAL DOT DIVEQUAL DIV DECREMENT COMM COL BOR BAND ASSIGN ANDEQUAL AND ]
arrayAllocationExpression -> NEW . typeName dimExprs [ XOREQUAL XOR SEMI RSHIFTEQUAL RSHIFT RPAR RCURL RBRAC QM PLUS PEQUAL OREQUAL OR NEQUAL MULEQUAL MUL MODEQUAL MOD MINUSEQUAL MINUS LTHAN LSHIFTEQUAL LSHIFT LOGSHIFTEQUAL LOGSHIFT LETHAN LCURL INSTANCEOF INCREMENT GTHAN GETHAN EQUAL DOT DIVEQUAL DIV DECREMENT COMM COL BOR BAND ASSIGN ANDEQUAL AND ]
arrayAllocationExpression -> NEW . typeName dims [ XOREQUAL XOR SEMI RSHIFTEQUAL RSHIFT RPAR RCURL RBRAC QM PLUS PEQUAL OREQUAL OR NEQUAL MULEQUAL MUL MODEQUAL MOD MINUSEQUAL MINUS LTHAN LSHIFTEQUAL LSHIFT LOGSHIFTEQUAL LOGSHIFT LETHAN LCURL INSTANCEOF INCREMENT GTHAN GETHAN EQUAL DOT DIVEQUAL DIV DECREMENT COMM COL BOR BAND ASSIGN ANDEQUAL AND ]
classAllocationExpression -> NEW . typeName LPAR argumentList RPAR [ XOREQUAL XOR SEMI RSHIFTEQUAL RSHIFT RPAR RCURL RBRAC QM PLUS PEQUAL OREQUAL OR NEQUAL MULEQUAL MUL MODEQUAL MOD MINUSEQUAL MINUS LTHAN LSHIFTEQUAL LSHIFT LOGSHIFTEQUAL LOGSHIFT LETHAN LCURL INSTANCEOF INCREMENT GTHAN GETHAN EQUAL DOT DIVEQUAL DIV DECREMENT COMM COL BOR BAND ASSIGN ANDEQUAL AND ]
classAllocationExpression -> NEW . typeName LPAR RPAR [ XOREQUAL XOR SEMI RSHIFTEQUAL RSHIFT RPAR RCURL RBRAC QM PLUS PEQUAL OREQUAL OR NEQUAL MULEQUAL MUL MODEQUAL MOD MINUSEQUAL MINUS LTHAN LSHIFTEQUAL LSHIFT LOGSHIFTEQUAL LOGSHIFT LETHAN LCURL INSTANCEOF INCREMENT GTHAN GETHAN EQUAL DOT DIVEQUAL DIV DECREMENT COMM COL BOR BAND ASSIGN ANDEQUAL AND ]
-- On VOID shift to state 6
-- On SHORT shift to state 10
-- On LONG shift to state 15
-- On INT shift to state 16
-- On IDENTIFIER shift to state 17
-- On FLOAT shift to state 18
-- On DOUBLE shift to state 19
-- On CHAR shift to state 20
-- On BYTE shift to state 21
-- On BOOLEAN shift to state 22
-- On typeName shift to state 23
-- On qualifiedName shift to state 134
-- On primitiveType shift to state 137

State 15:
primitiveType -> LONG . [ XOR SEMI RPAR RCURL RBRAC QM OR NEQUAL LTHAN LPAR LETHAN LBRAC INSTANCEOF IDENTIFIER GTHAN GETHAN EQUAL DOT DIM COMM COL BOR BAND AND ]
-- On XOR reduce production primitiveType -> LONG 
-- On SEMI reduce production primitiveType -> LONG 
-- On RPAR reduce production primitiveType -> LONG 
-- On RCURL reduce production primitiveType -> LONG 
-- On RBRAC reduce production primitiveType -> LONG 
-- On QM reduce production primitiveType -> LONG 
-- On OR reduce production primitiveType -> LONG 
-- On NEQUAL reduce production primitiveType -> LONG 
-- On LTHAN reduce production primitiveType -> LONG 
-- On LPAR reduce production primitiveType -> LONG 
-- On LETHAN reduce production primitiveType -> LONG 
-- On LBRAC reduce production primitiveType -> LONG 
-- On INSTANCEOF reduce production primitiveType -> LONG 
-- On IDENTIFIER reduce production primitiveType -> LONG 
-- On GTHAN reduce production primitiveType -> LONG 
-- On GETHAN reduce production primitiveType -> LONG 
-- On EQUAL reduce production primitiveType -> LONG 
-- On DOT reduce production primitiveType -> LONG 
-- On DIM reduce production primitiveType -> LONG 
-- On COMM reduce production primitiveType -> LONG 
-- On COL reduce production primitiveType -> LONG 
-- On BOR reduce production primitiveType -> LONG 
-- On BAND reduce production primitiveType -> LONG 
-- On AND reduce production primitiveType -> LONG 

State 16:
primitiveType -> INT . [ XOR SEMI RPAR RCURL RBRAC QM OR NEQUAL LTHAN LPAR LETHAN LBRAC INSTANCEOF IDENTIFIER GTHAN GETHAN EQUAL DOT DIM COMM COL BOR BAND AND ]
-- On XOR reduce production primitiveType -> INT 
-- On SEMI reduce production primitiveType -> INT 
-- On RPAR reduce production primitiveType -> INT 
-- On RCURL reduce production primitiveType -> INT 
-- On RBRAC reduce production primitiveType -> INT 
-- On QM reduce production primitiveType -> INT 
-- On OR reduce production primitiveType -> INT 
-- On NEQUAL reduce production primitiveType -> INT 
-- On LTHAN reduce production primitiveType -> INT 
-- On LPAR reduce production primitiveType -> INT 
-- On LETHAN reduce production primitiveType -> INT 
-- On LBRAC reduce production primitiveType -> INT 
-- On INSTANCEOF reduce production primitiveType -> INT 
-- On IDENTIFIER reduce production primitiveType -> INT 
-- On GTHAN reduce production primitiveType -> INT 
-- On GETHAN reduce production primitiveType -> INT 
-- On EQUAL reduce production primitiveType -> INT 
-- On DOT reduce production primitiveType -> INT 
-- On DIM reduce production primitiveType -> INT 
-- On COMM reduce production primitiveType -> INT 
-- On COL reduce production primitiveType -> INT 
-- On BOR reduce production primitiveType -> INT 
-- On BAND reduce production primitiveType -> INT 
-- On AND reduce production primitiveType -> INT 

State 17:
qualifiedName -> IDENTIFIER . [ XOREQUAL XOR SEMI RSHIFTEQUAL RSHIFT RPAR RCURL RBRAC QM PLUS PEQUAL OREQUAL OR NEQUAL MULEQUAL MUL MODEQUAL MOD MINUSEQUAL MINUS LTHAN LSHIFTEQUAL LSHIFT LPAR LOGSHIFTEQUAL LOGSHIFT LETHAN LBRAC INSTANCEOF INCREMENT IDENTIFIER GTHAN GETHAN EQUAL DOT DIVEQUAL DIV DIM DECREMENT COMM COL BOR BAND ASSIGN ANDEQUAL AND ]
-- On XOREQUAL reduce production qualifiedName -> IDENTIFIER 
-- On XOR reduce production qualifiedName -> IDENTIFIER 
-- On SEMI reduce production qualifiedName -> IDENTIFIER 
-- On RSHIFTEQUAL reduce production qualifiedName -> IDENTIFIER 
-- On RSHIFT reduce production qualifiedName -> IDENTIFIER 
-- On RPAR reduce production qualifiedName -> IDENTIFIER 
-- On RCURL reduce production qualifiedName -> IDENTIFIER 
-- On RBRAC reduce production qualifiedName -> IDENTIFIER 
-- On QM reduce production qualifiedName -> IDENTIFIER 
-- On PLUS reduce production qualifiedName -> IDENTIFIER 
-- On PEQUAL reduce production qualifiedName -> IDENTIFIER 
-- On OREQUAL reduce production qualifiedName -> IDENTIFIER 
-- On OR reduce production qualifiedName -> IDENTIFIER 
-- On NEQUAL reduce production qualifiedName -> IDENTIFIER 
-- On MULEQUAL reduce production qualifiedName -> IDENTIFIER 
-- On MUL reduce production qualifiedName -> IDENTIFIER 
-- On MODEQUAL reduce production qualifiedName -> IDENTIFIER 
-- On MOD reduce production qualifiedName -> IDENTIFIER 
-- On MINUSEQUAL reduce production qualifiedName -> IDENTIFIER 
-- On MINUS reduce production qualifiedName -> IDENTIFIER 
-- On LTHAN reduce production qualifiedName -> IDENTIFIER 
-- On LSHIFTEQUAL reduce production qualifiedName -> IDENTIFIER 
-- On LSHIFT reduce production qualifiedName -> IDENTIFIER 
-- On LPAR reduce production qualifiedName -> IDENTIFIER 
-- On LOGSHIFTEQUAL reduce production qualifiedName -> IDENTIFIER 
-- On LOGSHIFT reduce production qualifiedName -> IDENTIFIER 
-- On LETHAN reduce production qualifiedName -> IDENTIFIER 
-- On LBRAC reduce production qualifiedName -> IDENTIFIER 
-- On INSTANCEOF reduce production qualifiedName -> IDENTIFIER 
-- On INCREMENT reduce production qualifiedName -> IDENTIFIER 
-- On IDENTIFIER reduce production qualifiedName -> IDENTIFIER 
-- On GTHAN reduce production qualifiedName -> IDENTIFIER 
-- On GETHAN reduce production qualifiedName -> IDENTIFIER 
-- On EQUAL reduce production qualifiedName -> IDENTIFIER 
-- On DOT reduce production qualifiedName -> IDENTIFIER 
-- On DIVEQUAL reduce production qualifiedName -> IDENTIFIER 
-- On DIV reduce production qualifiedName -> IDENTIFIER 
-- On DIM reduce production qualifiedName -> IDENTIFIER 
-- On DECREMENT reduce production qualifiedName -> IDENTIFIER 
-- On COMM reduce production qualifiedName -> IDENTIFIER 
-- On COL reduce production qualifiedName -> IDENTIFIER 
-- On BOR reduce production qualifiedName -> IDENTIFIER 
-- On BAND reduce production qualifiedName -> IDENTIFIER 
-- On ASSIGN reduce production qualifiedName -> IDENTIFIER 
-- On ANDEQUAL reduce production qualifiedName -> IDENTIFIER 
-- On AND reduce production qualifiedName -> IDENTIFIER 

State 18:
primitiveType -> FLOAT . [ XOR SEMI RPAR RCURL RBRAC QM OR NEQUAL LTHAN LPAR LETHAN LBRAC INSTANCEOF IDENTIFIER GTHAN GETHAN EQUAL DOT DIM COMM COL BOR BAND AND ]
-- On XOR reduce production primitiveType -> FLOAT 
-- On SEMI reduce production primitiveType -> FLOAT 
-- On RPAR reduce production primitiveType -> FLOAT 
-- On RCURL reduce production primitiveType -> FLOAT 
-- On RBRAC reduce production primitiveType -> FLOAT 
-- On QM reduce production primitiveType -> FLOAT 
-- On OR reduce production primitiveType -> FLOAT 
-- On NEQUAL reduce production primitiveType -> FLOAT 
-- On LTHAN reduce production primitiveType -> FLOAT 
-- On LPAR reduce production primitiveType -> FLOAT 
-- On LETHAN reduce production primitiveType -> FLOAT 
-- On LBRAC reduce production primitiveType -> FLOAT 
-- On INSTANCEOF reduce production primitiveType -> FLOAT 
-- On IDENTIFIER reduce production primitiveType -> FLOAT 
-- On GTHAN reduce production primitiveType -> FLOAT 
-- On GETHAN reduce production primitiveType -> FLOAT 
-- On EQUAL reduce production primitiveType -> FLOAT 
-- On DOT reduce production primitiveType -> FLOAT 
-- On DIM reduce production primitiveType -> FLOAT 
-- On COMM reduce production primitiveType -> FLOAT 
-- On COL reduce production primitiveType -> FLOAT 
-- On BOR reduce production primitiveType -> FLOAT 
-- On BAND reduce production primitiveType -> FLOAT 
-- On AND reduce production primitiveType -> FLOAT 

State 19:
primitiveType -> DOUBLE . [ XOR SEMI RPAR RCURL RBRAC QM OR NEQUAL LTHAN LPAR LETHAN LBRAC INSTANCEOF IDENTIFIER GTHAN GETHAN EQUAL DOT DIM COMM COL BOR BAND AND ]
-- On XOR reduce production primitiveType -> DOUBLE 
-- On SEMI reduce production primitiveType -> DOUBLE 
-- On RPAR reduce production primitiveType -> DOUBLE 
-- On RCURL reduce production primitiveType -> DOUBLE 
-- On RBRAC reduce production primitiveType -> DOUBLE 
-- On QM reduce production primitiveType -> DOUBLE 
-- On OR reduce production primitiveType -> DOUBLE 
-- On NEQUAL reduce production primitiveType -> DOUBLE 
-- On LTHAN reduce production primitiveType -> DOUBLE 
-- On LPAR reduce production primitiveType -> DOUBLE 
-- On LETHAN reduce production primitiveType -> DOUBLE 
-- On LBRAC reduce production primitiveType -> DOUBLE 
-- On INSTANCEOF reduce production primitiveType -> DOUBLE 
-- On IDENTIFIER reduce production primitiveType -> DOUBLE 
-- On GTHAN reduce production primitiveType -> DOUBLE 
-- On GETHAN reduce production primitiveType -> DOUBLE 
-- On EQUAL reduce production primitiveType -> DOUBLE 
-- On DOT reduce production primitiveType -> DOUBLE 
-- On DIM reduce production primitiveType -> DOUBLE 
-- On COMM reduce production primitiveType -> DOUBLE 
-- On COL reduce production primitiveType -> DOUBLE 
-- On BOR reduce production primitiveType -> DOUBLE 
-- On BAND reduce production primitiveType -> DOUBLE 
-- On AND reduce production primitiveType -> DOUBLE 

State 20:
primitiveType -> CHAR . [ XOR SEMI RPAR RCURL RBRAC QM OR NEQUAL LTHAN LPAR LETHAN LBRAC INSTANCEOF IDENTIFIER GTHAN GETHAN EQUAL DOT DIM COMM COL BOR BAND AND ]
-- On XOR reduce production primitiveType -> CHAR 
-- On SEMI reduce production primitiveType -> CHAR 
-- On RPAR reduce production primitiveType -> CHAR 
-- On RCURL reduce production primitiveType -> CHAR 
-- On RBRAC reduce production primitiveType -> CHAR 
-- On QM reduce production primitiveType -> CHAR 
-- On OR reduce production primitiveType -> CHAR 
-- On NEQUAL reduce production primitiveType -> CHAR 
-- On LTHAN reduce production primitiveType -> CHAR 
-- On LPAR reduce production primitiveType -> CHAR 
-- On LETHAN reduce production primitiveType -> CHAR 
-- On LBRAC reduce production primitiveType -> CHAR 
-- On INSTANCEOF reduce production primitiveType -> CHAR 
-- On IDENTIFIER reduce production primitiveType -> CHAR 
-- On GTHAN reduce production primitiveType -> CHAR 
-- On GETHAN reduce production primitiveType -> CHAR 
-- On EQUAL reduce production primitiveType -> CHAR 
-- On DOT reduce production primitiveType -> CHAR 
-- On DIM reduce production primitiveType -> CHAR 
-- On COMM reduce production primitiveType -> CHAR 
-- On COL reduce production primitiveType -> CHAR 
-- On BOR reduce production primitiveType -> CHAR 
-- On BAND reduce production primitiveType -> CHAR 
-- On AND reduce production primitiveType -> CHAR 

State 21:
primitiveType -> BYTE . [ XOR SEMI RPAR RCURL RBRAC QM OR NEQUAL LTHAN LPAR LETHAN LBRAC INSTANCEOF IDENTIFIER GTHAN GETHAN EQUAL DOT DIM COMM COL BOR BAND AND ]
-- On XOR reduce production primitiveType -> BYTE 
-- On SEMI reduce production primitiveType -> BYTE 
-- On RPAR reduce production primitiveType -> BYTE 
-- On RCURL reduce production primitiveType -> BYTE 
-- On RBRAC reduce production primitiveType -> BYTE 
-- On QM reduce production primitiveType -> BYTE 
-- On OR reduce production primitiveType -> BYTE 
-- On NEQUAL reduce production primitiveType -> BYTE 
-- On LTHAN reduce production primitiveType -> BYTE 
-- On LPAR reduce production primitiveType -> BYTE 
-- On LETHAN reduce production primitiveType -> BYTE 
-- On LBRAC reduce production primitiveType -> BYTE 
-- On INSTANCEOF reduce production primitiveType -> BYTE 
-- On IDENTIFIER reduce production primitiveType -> BYTE 
-- On GTHAN reduce production primitiveType -> BYTE 
-- On GETHAN reduce production primitiveType -> BYTE 
-- On EQUAL reduce production primitiveType -> BYTE 
-- On DOT reduce production primitiveType -> BYTE 
-- On DIM reduce production primitiveType -> BYTE 
-- On COMM reduce production primitiveType -> BYTE 
-- On COL reduce production primitiveType -> BYTE 
-- On BOR reduce production primitiveType -> BYTE 
-- On BAND reduce production primitiveType -> BYTE 
-- On AND reduce production primitiveType -> BYTE 

State 22:
primitiveType -> BOOLEAN . [ XOR SEMI RPAR RCURL RBRAC QM OR NEQUAL LTHAN LPAR LETHAN LBRAC INSTANCEOF IDENTIFIER GTHAN GETHAN EQUAL DOT DIM COMM COL BOR BAND AND ]
-- On XOR reduce production primitiveType -> BOOLEAN 
-- On SEMI reduce production primitiveType -> BOOLEAN 
-- On RPAR reduce production primitiveType -> BOOLEAN 
-- On RCURL reduce production primitiveType -> BOOLEAN 
-- On RBRAC reduce production primitiveType -> BOOLEAN 
-- On QM reduce production primitiveType -> BOOLEAN 
-- On OR reduce production primitiveType -> BOOLEAN 
-- On NEQUAL reduce production primitiveType -> BOOLEAN 
-- On LTHAN reduce production primitiveType -> BOOLEAN 
-- On LPAR reduce production primitiveType -> BOOLEAN 
-- On LETHAN reduce production primitiveType -> BOOLEAN 
-- On LBRAC reduce production primitiveType -> BOOLEAN 
-- On INSTANCEOF reduce production primitiveType -> BOOLEAN 
-- On IDENTIFIER reduce production primitiveType -> BOOLEAN 
-- On GTHAN reduce production primitiveType -> BOOLEAN 
-- On GETHAN reduce production primitiveType -> BOOLEAN 
-- On EQUAL reduce production primitiveType -> BOOLEAN 
-- On DOT reduce production primitiveType -> BOOLEAN 
-- On DIM reduce production primitiveType -> BOOLEAN 
-- On COMM reduce production primitiveType -> BOOLEAN 
-- On COL reduce production primitiveType -> BOOLEAN 
-- On BOR reduce production primitiveType -> BOOLEAN 
-- On BAND reduce production primitiveType -> BOOLEAN 
-- On AND reduce production primitiveType -> BOOLEAN 

State 23:
arrayAllocationExpression -> NEW typeName . dimExprs dims [ XOREQUAL XOR SEMI RSHIFTEQUAL RSHIFT RPAR RCURL RBRAC QM PLUS PEQUAL OREQUAL OR NEQUAL MULEQUAL MUL MODEQUAL MOD MINUSEQUAL MINUS LTHAN LSHIFTEQUAL LSHIFT LOGSHIFTEQUAL LOGSHIFT LETHAN LCURL INSTANCEOF INCREMENT GTHAN GETHAN EQUAL DOT DIVEQUAL DIV DECREMENT COMM COL BOR BAND ASSIGN ANDEQUAL AND ]
arrayAllocationExpression -> NEW typeName . dimExprs [ XOREQUAL XOR SEMI RSHIFTEQUAL RSHIFT RPAR RCURL RBRAC QM PLUS PEQUAL OREQUAL OR NEQUAL MULEQUAL MUL MODEQUAL MOD MINUSEQUAL MINUS LTHAN LSHIFTEQUAL LSHIFT LOGSHIFTEQUAL LOGSHIFT LETHAN LCURL INSTANCEOF INCREMENT GTHAN GETHAN EQUAL DOT DIVEQUAL DIV DECREMENT COMM COL BOR BAND ASSIGN ANDEQUAL AND ]
arrayAllocationExpression -> NEW typeName . dims [ XOREQUAL XOR SEMI RSHIFTEQUAL RSHIFT RPAR RCURL RBRAC QM PLUS PEQUAL OREQUAL OR NEQUAL MULEQUAL MUL MODEQUAL MOD MINUSEQUAL MINUS LTHAN LSHIFTEQUAL LSHIFT LOGSHIFTEQUAL LOGSHIFT LETHAN LCURL INSTANCEOF INCREMENT GTHAN GETHAN EQUAL DOT DIVEQUAL DIV DECREMENT COMM COL BOR BAND ASSIGN ANDEQUAL AND ]
classAllocationExpression -> NEW typeName . LPAR argumentList RPAR [ XOREQUAL XOR SEMI RSHIFTEQUAL RSHIFT RPAR RCURL RBRAC QM PLUS PEQUAL OREQUAL OR NEQUAL MULEQUAL MUL MODEQUAL MOD MINUSEQUAL MINUS LTHAN LSHIFTEQUAL LSHIFT LOGSHIFTEQUAL LOGSHIFT LETHAN LCURL INSTANCEOF INCREMENT GTHAN GETHAN EQUAL DOT DIVEQUAL DIV DECREMENT COMM COL BOR BAND ASSIGN ANDEQUAL AND ]
classAllocationExpression -> NEW typeName . LPAR RPAR [ XOREQUAL XOR SEMI RSHIFTEQUAL RSHIFT RPAR RCURL RBRAC QM PLUS PEQUAL OREQUAL OR NEQUAL MULEQUAL MUL MODEQUAL MOD MINUSEQUAL MINUS LTHAN LSHIFTEQUAL LSHIFT LOGSHIFTEQUAL LOGSHIFT LETHAN LCURL INSTANCEOF INCREMENT GTHAN GETHAN EQUAL DOT DIVEQUAL DIV DECREMENT COMM COL BOR BAND ASSIGN ANDEQUAL AND ]
-- On LPAR shift to state 24
-- On LBRAC shift to state 198
-- On DIM shift to state 131
-- On dims shift to state 201
-- On dimExprs shift to state 202
-- On dimExpr shift to state 205

State 24:
classAllocationExpression -> NEW typeName LPAR . argumentList RPAR [ XOREQUAL XOR SEMI RSHIFTEQUAL RSHIFT RPAR RCURL RBRAC QM PLUS PEQUAL OREQUAL OR NEQUAL MULEQUAL MUL MODEQUAL MOD MINUSEQUAL MINUS LTHAN LSHIFTEQUAL LSHIFT LOGSHIFTEQUAL LOGSHIFT LETHAN LCURL INSTANCEOF INCREMENT GTHAN GETHAN EQUAL DOT DIVEQUAL DIV DECREMENT COMM COL BOR BAND ASSIGN ANDEQUAL AND ]
classAllocationExpression -> NEW typeName LPAR . RPAR [ XOREQUAL XOR SEMI RSHIFTEQUAL RSHIFT RPAR RCURL RBRAC QM PLUS PEQUAL OREQUAL OR NEQUAL MULEQUAL MUL MODEQUAL MOD MINUSEQUAL MINUS LTHAN LSHIFTEQUAL LSHIFT LOGSHIFTEQUAL LOGSHIFT LETHAN LCURL INSTANCEOF INCREMENT GTHAN GETHAN EQUAL DOT DIVEQUAL DIV DECREMENT COMM COL BOR BAND ASSIGN ANDEQUAL AND ]
-- On error shift to state 3
-- On VOID shift to state 6
-- On THIS shift to state 7
-- On SUPER shift to state 8
-- On STRLIT shift to state 9
-- On SHORT shift to state 10
-- On RPAR shift to state 25
-- On PLUS shift to state 11
-- On NULLLIT shift to state 12
-- On NOT shift to state 13
-- On NEW shift to state 14
-- On MINUS shift to state 26
-- On LPAR shift to state 27
-- On LONG shift to state 15
-- On INTLIT shift to state 28
-- On INT shift to state 16
-- On INCREMENT shift to state 29
-- On IDENTIFIER shift to state 17
-- On FLOATLIT shift to state 31
-- On FLOAT shift to state 18
-- On DOUBLELIT shift to state 32
-- On DOUBLE shift to state 19
-- On DECREMENT shift to state 33
-- On CHARLIT shift to state 34
-- On CHAR shift to state 20
-- On BYTE shift to state 21
-- On BOOLEANLIT shift to state 35
-- On BOOLEAN shift to state 22
-- On BNOT shift to state 36
-- On unaryExpression shift to state 44
-- On specialName shift to state 38
-- On shiftExpression shift to state 58
-- On relationalExpression shift to state 79
-- On realPostfixExpression shift to state 39
-- On qualifiedName shift to state 42
-- On primitiveType shift to state 61
-- On primaryExpression shift to state 64
-- On postfixExpression shift to state 65
-- On plainNewAllocationExpression shift to state 68
-- On notJustName shift to state 69
-- On newAllocationExpression shift to state 72
-- On multiplicativeExpression shift to state 73
-- On methodCall shift to state 75
-- On methodAccess shift to state 76
-- On logicalUnaryOperator shift to state 83
-- On logicalUnaryExpression shift to state 85
-- On inclusiveOrExpression shift to state 90
-- On fieldAccess shift to state 86
-- On expression shift to state 166
-- On exclusiveOrExpression shift to state 111
-- On equalityExpression shift to state 94
-- On conditionalOrExpression shift to state 112
-- On conditionalExpression shift to state 151
-- On conditionalAndExpression shift to state 117
-- On complexPrimaryNoParenthesis shift to state 87
-- On complexPrimary shift to state 88
-- On classAllocationExpression shift to state 100
-- On castExpression shift to state 103
-- On assignmentExpression shift to state 152
-- On arrayAllocationExpression shift to state 104
-- On arrayAccess shift to state 120
-- On arithmeticUnaryOperator shift to state 121
-- On argumentList shift to state 196
-- On andExpression shift to state 123
-- On additiveExpression shift to state 140

State 25:
classAllocationExpression -> NEW typeName LPAR RPAR . [ XOREQUAL XOR SEMI RSHIFTEQUAL RSHIFT RPAR RCURL RBRAC QM PLUS PEQUAL OREQUAL OR NEQUAL MULEQUAL MUL MODEQUAL MOD MINUSEQUAL MINUS LTHAN LSHIFTEQUAL LSHIFT LOGSHIFTEQUAL LOGSHIFT LETHAN LCURL INSTANCEOF INCREMENT GTHAN GETHAN EQUAL DOT DIVEQUAL DIV DECREMENT COMM COL BOR BAND ASSIGN ANDEQUAL AND ]
-- On XOREQUAL reduce production classAllocationExpression -> NEW typeName LPAR RPAR 
-- On XOR reduce production classAllocationExpression -> NEW typeName LPAR RPAR 
-- On SEMI reduce production classAllocationExpression -> NEW typeName LPAR RPAR 
-- On RSHIFTEQUAL reduce production classAllocationExpression -> NEW typeName LPAR RPAR 
-- On RSHIFT reduce production classAllocationExpression -> NEW typeName LPAR RPAR 
-- On RPAR reduce production classAllocationExpression -> NEW typeName LPAR RPAR 
-- On RCURL reduce production classAllocationExpression -> NEW typeName LPAR RPAR 
-- On RBRAC reduce production classAllocationExpression -> NEW typeName LPAR RPAR 
-- On QM reduce production classAllocationExpression -> NEW typeName LPAR RPAR 
-- On PLUS reduce production classAllocationExpression -> NEW typeName LPAR RPAR 
-- On PEQUAL reduce production classAllocationExpression -> NEW typeName LPAR RPAR 
-- On OREQUAL reduce production classAllocationExpression -> NEW typeName LPAR RPAR 
-- On OR reduce production classAllocationExpression -> NEW typeName LPAR RPAR 
-- On NEQUAL reduce production classAllocationExpression -> NEW typeName LPAR RPAR 
-- On MULEQUAL reduce production classAllocationExpression -> NEW typeName LPAR RPAR 
-- On MUL reduce production classAllocationExpression -> NEW typeName LPAR RPAR 
-- On MODEQUAL reduce production classAllocationExpression -> NEW typeName LPAR RPAR 
-- On MOD reduce production classAllocationExpression -> NEW typeName LPAR RPAR 
-- On MINUSEQUAL reduce production classAllocationExpression -> NEW typeName LPAR RPAR 
-- On MINUS reduce production classAllocationExpression -> NEW typeName LPAR RPAR 
-- On LTHAN reduce production classAllocationExpression -> NEW typeName LPAR RPAR 
-- On LSHIFTEQUAL reduce production classAllocationExpression -> NEW typeName LPAR RPAR 
-- On LSHIFT reduce production classAllocationExpression -> NEW typeName LPAR RPAR 
-- On LOGSHIFTEQUAL reduce production classAllocationExpression -> NEW typeName LPAR RPAR 
-- On LOGSHIFT reduce production classAllocationExpression -> NEW typeName LPAR RPAR 
-- On LETHAN reduce production classAllocationExpression -> NEW typeName LPAR RPAR 
-- On LCURL reduce production classAllocationExpression -> NEW typeName LPAR RPAR 
-- On INSTANCEOF reduce production classAllocationExpression -> NEW typeName LPAR RPAR 
-- On INCREMENT reduce production classAllocationExpression -> NEW typeName LPAR RPAR 
-- On GTHAN reduce production classAllocationExpression -> NEW typeName LPAR RPAR 
-- On GETHAN reduce production classAllocationExpression -> NEW typeName LPAR RPAR 
-- On EQUAL reduce production classAllocationExpression -> NEW typeName LPAR RPAR 
-- On DOT reduce production classAllocationExpression -> NEW typeName LPAR RPAR 
-- On DIVEQUAL reduce production classAllocationExpression -> NEW typeName LPAR RPAR 
-- On DIV reduce production classAllocationExpression -> NEW typeName LPAR RPAR 
-- On DECREMENT reduce production classAllocationExpression -> NEW typeName LPAR RPAR 
-- On COMM reduce production classAllocationExpression -> NEW typeName LPAR RPAR 
-- On COL reduce production classAllocationExpression -> NEW typeName LPAR RPAR 
-- On BOR reduce production classAllocationExpression -> NEW typeName LPAR RPAR 
-- On BAND reduce production classAllocationExpression -> NEW typeName LPAR RPAR 
-- On ASSIGN reduce production classAllocationExpression -> NEW typeName LPAR RPAR 
-- On ANDEQUAL reduce production classAllocationExpression -> NEW typeName LPAR RPAR 
-- On AND reduce production classAllocationExpression -> NEW typeName LPAR RPAR 

State 26:
arithmeticUnaryOperator -> MINUS . [ VOID THIS SUPER STRLIT SHORT PLUS NULLLIT NOT NEW MINUS LPAR LONG INTLIT INT INCREMENT IDENTIFIER FLOATLIT FLOAT DOUBLELIT DOUBLE DECREMENT CHARLIT CHAR BYTE BOOLEANLIT BOOLEAN BNOT ]
-- On VOID reduce production arithmeticUnaryOperator -> MINUS 
-- On THIS reduce production arithmeticUnaryOperator -> MINUS 
-- On SUPER reduce production arithmeticUnaryOperator -> MINUS 
-- On STRLIT reduce production arithmeticUnaryOperator -> MINUS 
-- On SHORT reduce production arithmeticUnaryOperator -> MINUS 
-- On PLUS reduce production arithmeticUnaryOperator -> MINUS 
-- On NULLLIT reduce production arithmeticUnaryOperator -> MINUS 
-- On NOT reduce production arithmeticUnaryOperator -> MINUS 
-- On NEW reduce production arithmeticUnaryOperator -> MINUS 
-- On MINUS reduce production arithmeticUnaryOperator -> MINUS 
-- On LPAR reduce production arithmeticUnaryOperator -> MINUS 
-- On LONG reduce production arithmeticUnaryOperator -> MINUS 
-- On INTLIT reduce production arithmeticUnaryOperator -> MINUS 
-- On INT reduce production arithmeticUnaryOperator -> MINUS 
-- On INCREMENT reduce production arithmeticUnaryOperator -> MINUS 
-- On IDENTIFIER reduce production arithmeticUnaryOperator -> MINUS 
-- On FLOATLIT reduce production arithmeticUnaryOperator -> MINUS 
-- On FLOAT reduce production arithmeticUnaryOperator -> MINUS 
-- On DOUBLELIT reduce production arithmeticUnaryOperator -> MINUS 
-- On DOUBLE reduce production arithmeticUnaryOperator -> MINUS 
-- On DECREMENT reduce production arithmeticUnaryOperator -> MINUS 
-- On CHARLIT reduce production arithmeticUnaryOperator -> MINUS 
-- On CHAR reduce production arithmeticUnaryOperator -> MINUS 
-- On BYTE reduce production arithmeticUnaryOperator -> MINUS 
-- On BOOLEANLIT reduce production arithmeticUnaryOperator -> MINUS 
-- On BOOLEAN reduce production arithmeticUnaryOperator -> MINUS 
-- On BNOT reduce production arithmeticUnaryOperator -> MINUS 

State 27:
castExpression -> LPAR . primitiveTypeExpression RPAR castExpression [ XOREQUAL XOR SEMI RSHIFTEQUAL RSHIFT RPAR RCURL RBRAC QM PLUS PEQUAL OREQUAL OR NEQUAL MULEQUAL MUL MODEQUAL MOD MINUSEQUAL MINUS LTHAN LSHIFTEQUAL LSHIFT LOGSHIFTEQUAL LOGSHIFT LETHAN INSTANCEOF GTHAN GETHAN EQUAL DIVEQUAL DIV COMM COL BOR BAND ASSIGN ANDEQUAL AND ]
castExpression -> LPAR . classTypeExpression RPAR castExpression [ XOREQUAL XOR SEMI RSHIFTEQUAL RSHIFT RPAR RCURL RBRAC QM PLUS PEQUAL OREQUAL OR NEQUAL MULEQUAL MUL MODEQUAL MOD MINUSEQUAL MINUS LTHAN LSHIFTEQUAL LSHIFT LOGSHIFTEQUAL LOGSHIFT LETHAN INSTANCEOF GTHAN GETHAN EQUAL DIVEQUAL DIV COMM COL BOR BAND ASSIGN ANDEQUAL AND ]
castExpression -> LPAR . expression RPAR logicalUnaryExpression [ XOREQUAL XOR SEMI RSHIFTEQUAL RSHIFT RPAR RCURL RBRAC QM PLUS PEQUAL OREQUAL OR NEQUAL MULEQUAL MUL MODEQUAL MOD MINUSEQUAL MINUS LTHAN LSHIFTEQUAL LSHIFT LOGSHIFTEQUAL LOGSHIFT LETHAN INSTANCEOF GTHAN GETHAN EQUAL DIVEQUAL DIV COMM COL BOR BAND ASSIGN ANDEQUAL AND ]
complexPrimary -> LPAR . expression RPAR [ XOREQUAL XOR SEMI RSHIFTEQUAL RSHIFT RPAR RCURL RBRAC QM PLUS PEQUAL OREQUAL OR NEQUAL MULEQUAL MUL MODEQUAL MOD MINUSEQUAL MINUS LTHAN LSHIFTEQUAL LSHIFT LOGSHIFTEQUAL LOGSHIFT LETHAN LBRAC INSTANCEOF INCREMENT GTHAN GETHAN EQUAL DOT DIVEQUAL DIV DECREMENT COMM COL BOR BAND ASSIGN ANDEQUAL AND ]
-- On error shift to state 3
-- On VOID shift to state 6
-- On THIS shift to state 7
-- On SUPER shift to state 8
-- On STRLIT shift to state 9
-- On SHORT shift to state 10
-- On PLUS shift to state 11
-- On NULLLIT shift to state 12
-- On NOT shift to state 13
-- On NEW shift to state 14
-- On MINUS shift to state 26
-- On LPAR shift to state 27
-- On LONG shift to state 15
-- On INTLIT shift to state 28
-- On INT shift to state 16
-- On INCREMENT shift to state 29
-- On IDENTIFIER shift to state 17
-- On FLOATLIT shift to state 31
-- On FLOAT shift to state 18
-- On DOUBLELIT shift to state 32
-- On DOUBLE shift to state 19
-- On DECREMENT shift to state 33
-- On CHARLIT shift to state 34
-- On CHAR shift to state 20
-- On BYTE shift to state 21
-- On BOOLEANLIT shift to state 35
-- On BOOLEAN shift to state 22
-- On BNOT shift to state 36
-- On unaryExpression shift to state 44
-- On specialName shift to state 38
-- On shiftExpression shift to state 58
-- On relationalExpression shift to state 79
-- On realPostfixExpression shift to state 39
-- On qualifiedName shift to state 183
-- On primitiveTypeExpression shift to state 185
-- On primitiveType shift to state 188
-- On primaryExpression shift to state 64
-- On postfixExpression shift to state 65
-- On plainNewAllocationExpression shift to state 68
-- On notJustName shift to state 69
-- On newAllocationExpression shift to state 72
-- On multiplicativeExpression shift to state 73
-- On methodCall shift to state 75
-- On methodAccess shift to state 76
-- On logicalUnaryOperator shift to state 83
-- On logicalUnaryExpression shift to state 85
-- On inclusiveOrExpression shift to state 90
-- On fieldAccess shift to state 86
-- On expression shift to state 190
-- On exclusiveOrExpression shift to state 111
-- On equalityExpression shift to state 94
-- On conditionalOrExpression shift to state 112
-- On conditionalExpression shift to state 151
-- On conditionalAndExpression shift to state 117
-- On complexPrimaryNoParenthesis shift to state 87
-- On complexPrimary shift to state 88
-- On classTypeExpression shift to state 193
-- On classAllocationExpression shift to state 100
-- On castExpression shift to state 103
-- On assignmentExpression shift to state 152
-- On arrayAllocationExpression shift to state 104
-- On arrayAccess shift to state 120
-- On arithmeticUnaryOperator shift to state 121
-- On andExpression shift to state 123
-- On additiveExpression shift to state 140

State 28:
complexPrimaryNoParenthesis -> INTLIT . [ XOREQUAL XOR SEMI RSHIFTEQUAL RSHIFT RPAR RCURL RBRAC QM PLUS PEQUAL OREQUAL OR NEQUAL MULEQUAL MUL MODEQUAL MOD MINUSEQUAL MINUS LTHAN LSHIFTEQUAL LSHIFT LPAR LOGSHIFTEQUAL LOGSHIFT LETHAN LBRAC INSTANCEOF INCREMENT GTHAN GETHAN EQUAL DOT DIVEQUAL DIV DECREMENT COMM COL BOR BAND ASSIGN ANDEQUAL AND ]
-- On XOREQUAL reduce production complexPrimaryNoParenthesis -> INTLIT 
-- On XOR reduce production complexPrimaryNoParenthesis -> INTLIT 
-- On SEMI reduce production complexPrimaryNoParenthesis -> INTLIT 
-- On RSHIFTEQUAL reduce production complexPrimaryNoParenthesis -> INTLIT 
-- On RSHIFT reduce production complexPrimaryNoParenthesis -> INTLIT 
-- On RPAR reduce production complexPrimaryNoParenthesis -> INTLIT 
-- On RCURL reduce production complexPrimaryNoParenthesis -> INTLIT 
-- On RBRAC reduce production complexPrimaryNoParenthesis -> INTLIT 
-- On QM reduce production complexPrimaryNoParenthesis -> INTLIT 
-- On PLUS reduce production complexPrimaryNoParenthesis -> INTLIT 
-- On PEQUAL reduce production complexPrimaryNoParenthesis -> INTLIT 
-- On OREQUAL reduce production complexPrimaryNoParenthesis -> INTLIT 
-- On OR reduce production complexPrimaryNoParenthesis -> INTLIT 
-- On NEQUAL reduce production complexPrimaryNoParenthesis -> INTLIT 
-- On MULEQUAL reduce production complexPrimaryNoParenthesis -> INTLIT 
-- On MUL reduce production complexPrimaryNoParenthesis -> INTLIT 
-- On MODEQUAL reduce production complexPrimaryNoParenthesis -> INTLIT 
-- On MOD reduce production complexPrimaryNoParenthesis -> INTLIT 
-- On MINUSEQUAL reduce production complexPrimaryNoParenthesis -> INTLIT 
-- On MINUS reduce production complexPrimaryNoParenthesis -> INTLIT 
-- On LTHAN reduce production complexPrimaryNoParenthesis -> INTLIT 
-- On LSHIFTEQUAL reduce production complexPrimaryNoParenthesis -> INTLIT 
-- On LSHIFT reduce production complexPrimaryNoParenthesis -> INTLIT 
-- On LPAR reduce production complexPrimaryNoParenthesis -> INTLIT 
-- On LOGSHIFTEQUAL reduce production complexPrimaryNoParenthesis -> INTLIT 
-- On LOGSHIFT reduce production complexPrimaryNoParenthesis -> INTLIT 
-- On LETHAN reduce production complexPrimaryNoParenthesis -> INTLIT 
-- On LBRAC reduce production complexPrimaryNoParenthesis -> INTLIT 
-- On INSTANCEOF reduce production complexPrimaryNoParenthesis -> INTLIT 
-- On INCREMENT reduce production complexPrimaryNoParenthesis -> INTLIT 
-- On GTHAN reduce production complexPrimaryNoParenthesis -> INTLIT 
-- On GETHAN reduce production complexPrimaryNoParenthesis -> INTLIT 
-- On EQUAL reduce production complexPrimaryNoParenthesis -> INTLIT 
-- On DOT reduce production complexPrimaryNoParenthesis -> INTLIT 
-- On DIVEQUAL reduce production complexPrimaryNoParenthesis -> INTLIT 
-- On DIV reduce production complexPrimaryNoParenthesis -> INTLIT 
-- On DECREMENT reduce production complexPrimaryNoParenthesis -> INTLIT 
-- On COMM reduce production complexPrimaryNoParenthesis -> INTLIT 
-- On COL reduce production complexPrimaryNoParenthesis -> INTLIT 
-- On BOR reduce production complexPrimaryNoParenthesis -> INTLIT 
-- On BAND reduce production complexPrimaryNoParenthesis -> INTLIT 
-- On ASSIGN reduce production complexPrimaryNoParenthesis -> INTLIT 
-- On ANDEQUAL reduce production complexPrimaryNoParenthesis -> INTLIT 
-- On AND reduce production complexPrimaryNoParenthesis -> INTLIT 

State 29:
unaryExpression -> INCREMENT . unaryExpression [ XOREQUAL XOR SEMI RSHIFTEQUAL RSHIFT RPAR RCURL RBRAC QM PLUS PEQUAL OREQUAL OR NEQUAL MULEQUAL MUL MODEQUAL MOD MINUSEQUAL MINUS LTHAN LSHIFTEQUAL LSHIFT LOGSHIFTEQUAL LOGSHIFT LETHAN INSTANCEOF GTHAN GETHAN EQUAL DIVEQUAL DIV COMM COL BOR BAND ASSIGN ANDEQUAL AND ]
-- On VOID shift to state 6
-- On THIS shift to state 7
-- On SUPER shift to state 8
-- On STRLIT shift to state 9
-- On SHORT shift to state 10
-- On PLUS shift to state 11
-- On NULLLIT shift to state 12
-- On NOT shift to state 13
-- On NEW shift to state 14
-- On MINUS shift to state 26
-- On LPAR shift to state 30
-- On LONG shift to state 15
-- On INTLIT shift to state 28
-- On INT shift to state 16
-- On INCREMENT shift to state 29
-- On IDENTIFIER shift to state 17
-- On FLOATLIT shift to state 31
-- On FLOAT shift to state 18
-- On DOUBLELIT shift to state 32
-- On DOUBLE shift to state 19
-- On DECREMENT shift to state 33
-- On CHARLIT shift to state 34
-- On CHAR shift to state 20
-- On BYTE shift to state 21
-- On BOOLEANLIT shift to state 35
-- On BOOLEAN shift to state 22
-- On BNOT shift to state 36
-- On unaryExpression shift to state 182
-- On specialName shift to state 38
-- On realPostfixExpression shift to state 39
-- On qualifiedName shift to state 42
-- On primitiveType shift to state 61
-- On primaryExpression shift to state 64
-- On postfixExpression shift to state 65
-- On plainNewAllocationExpression shift to state 68
-- On notJustName shift to state 69
-- On newAllocationExpression shift to state 72
-- On methodCall shift to state 75
-- On methodAccess shift to state 76
-- On logicalUnaryOperator shift to state 83
-- On logicalUnaryExpression shift to state 85
-- On fieldAccess shift to state 86
-- On complexPrimaryNoParenthesis shift to state 87
-- On complexPrimary shift to state 88
-- On classAllocationExpression shift to state 100
-- On arrayAllocationExpression shift to state 104
-- On arrayAccess shift to state 120
-- On arithmeticUnaryOperator shift to state 121

State 30:
complexPrimary -> LPAR . expression RPAR [ XOREQUAL XOR SEMI RSHIFTEQUAL RSHIFT RPAR RCURL RBRAC QM PLUS PEQUAL OREQUAL OR NEQUAL MULEQUAL MUL MODEQUAL MOD MINUSEQUAL MINUS LTHAN LSHIFTEQUAL LSHIFT LOGSHIFTEQUAL LOGSHIFT LETHAN LBRAC INSTANCEOF INCREMENT GTHAN GETHAN EQUAL DOT DIVEQUAL DIV DECREMENT COMM COL BOR BAND ASSIGN ANDEQUAL AND ]
-- On error shift to state 3
-- On VOID shift to state 6
-- On THIS shift to state 7
-- On SUPER shift to state 8
-- On STRLIT shift to state 9
-- On SHORT shift to state 10
-- On PLUS shift to state 11
-- On NULLLIT shift to state 12
-- On NOT shift to state 13
-- On NEW shift to state 14
-- On MINUS shift to state 26
-- On LPAR shift to state 27
-- On LONG shift to state 15
-- On INTLIT shift to state 28
-- On INT shift to state 16
-- On INCREMENT shift to state 29
-- On IDENTIFIER shift to state 17
-- On FLOATLIT shift to state 31
-- On FLOAT shift to state 18
-- On DOUBLELIT shift to state 32
-- On DOUBLE shift to state 19
-- On DECREMENT shift to state 33
-- On CHARLIT shift to state 34
-- On CHAR shift to state 20
-- On BYTE shift to state 21
-- On BOOLEANLIT shift to state 35
-- On BOOLEAN shift to state 22
-- On BNOT shift to state 36
-- On unaryExpression shift to state 44
-- On specialName shift to state 38
-- On shiftExpression shift to state 58
-- On relationalExpression shift to state 79
-- On realPostfixExpression shift to state 39
-- On qualifiedName shift to state 42
-- On primitiveType shift to state 61
-- On primaryExpression shift to state 64
-- On postfixExpression shift to state 65
-- On plainNewAllocationExpression shift to state 68
-- On notJustName shift to state 69
-- On newAllocationExpression shift to state 72
-- On multiplicativeExpression shift to state 73
-- On methodCall shift to state 75
-- On methodAccess shift to state 76
-- On logicalUnaryOperator shift to state 83
-- On logicalUnaryExpression shift to state 85
-- On inclusiveOrExpression shift to state 90
-- On fieldAccess shift to state 86
-- On expression shift to state 180
-- On exclusiveOrExpression shift to state 111
-- On equalityExpression shift to state 94
-- On conditionalOrExpression shift to state 112
-- On conditionalExpression shift to state 151
-- On conditionalAndExpression shift to state 117
-- On complexPrimaryNoParenthesis shift to state 87
-- On complexPrimary shift to state 88
-- On classAllocationExpression shift to state 100
-- On castExpression shift to state 103
-- On assignmentExpression shift to state 152
-- On arrayAllocationExpression shift to state 104
-- On arrayAccess shift to state 120
-- On arithmeticUnaryOperator shift to state 121
-- On andExpression shift to state 123
-- On additiveExpression shift to state 140

State 31:
complexPrimaryNoParenthesis -> FLOATLIT . [ XOREQUAL XOR SEMI RSHIFTEQUAL RSHIFT RPAR RCURL RBRAC QM PLUS PEQUAL OREQUAL OR NEQUAL MULEQUAL MUL MODEQUAL MOD MINUSEQUAL MINUS LTHAN LSHIFTEQUAL LSHIFT LPAR LOGSHIFTEQUAL LOGSHIFT LETHAN LBRAC INSTANCEOF INCREMENT GTHAN GETHAN EQUAL DOT DIVEQUAL DIV DECREMENT COMM COL BOR BAND ASSIGN ANDEQUAL AND ]
-- On XOREQUAL reduce production complexPrimaryNoParenthesis -> FLOATLIT 
-- On XOR reduce production complexPrimaryNoParenthesis -> FLOATLIT 
-- On SEMI reduce production complexPrimaryNoParenthesis -> FLOATLIT 
-- On RSHIFTEQUAL reduce production complexPrimaryNoParenthesis -> FLOATLIT 
-- On RSHIFT reduce production complexPrimaryNoParenthesis -> FLOATLIT 
-- On RPAR reduce production complexPrimaryNoParenthesis -> FLOATLIT 
-- On RCURL reduce production complexPrimaryNoParenthesis -> FLOATLIT 
-- On RBRAC reduce production complexPrimaryNoParenthesis -> FLOATLIT 
-- On QM reduce production complexPrimaryNoParenthesis -> FLOATLIT 
-- On PLUS reduce production complexPrimaryNoParenthesis -> FLOATLIT 
-- On PEQUAL reduce production complexPrimaryNoParenthesis -> FLOATLIT 
-- On OREQUAL reduce production complexPrimaryNoParenthesis -> FLOATLIT 
-- On OR reduce production complexPrimaryNoParenthesis -> FLOATLIT 
-- On NEQUAL reduce production complexPrimaryNoParenthesis -> FLOATLIT 
-- On MULEQUAL reduce production complexPrimaryNoParenthesis -> FLOATLIT 
-- On MUL reduce production complexPrimaryNoParenthesis -> FLOATLIT 
-- On MODEQUAL reduce production complexPrimaryNoParenthesis -> FLOATLIT 
-- On MOD reduce production complexPrimaryNoParenthesis -> FLOATLIT 
-- On MINUSEQUAL reduce production complexPrimaryNoParenthesis -> FLOATLIT 
-- On MINUS reduce production complexPrimaryNoParenthesis -> FLOATLIT 
-- On LTHAN reduce production complexPrimaryNoParenthesis -> FLOATLIT 
-- On LSHIFTEQUAL reduce production complexPrimaryNoParenthesis -> FLOATLIT 
-- On LSHIFT reduce production complexPrimaryNoParenthesis -> FLOATLIT 
-- On LPAR reduce production complexPrimaryNoParenthesis -> FLOATLIT 
-- On LOGSHIFTEQUAL reduce production complexPrimaryNoParenthesis -> FLOATLIT 
-- On LOGSHIFT reduce production complexPrimaryNoParenthesis -> FLOATLIT 
-- On LETHAN reduce production complexPrimaryNoParenthesis -> FLOATLIT 
-- On LBRAC reduce production complexPrimaryNoParenthesis -> FLOATLIT 
-- On INSTANCEOF reduce production complexPrimaryNoParenthesis -> FLOATLIT 
-- On INCREMENT reduce production complexPrimaryNoParenthesis -> FLOATLIT 
-- On GTHAN reduce production complexPrimaryNoParenthesis -> FLOATLIT 
-- On GETHAN reduce production complexPrimaryNoParenthesis -> FLOATLIT 
-- On EQUAL reduce production complexPrimaryNoParenthesis -> FLOATLIT 
-- On DOT reduce production complexPrimaryNoParenthesis -> FLOATLIT 
-- On DIVEQUAL reduce production complexPrimaryNoParenthesis -> FLOATLIT 
-- On DIV reduce production complexPrimaryNoParenthesis -> FLOATLIT 
-- On DECREMENT reduce production complexPrimaryNoParenthesis -> FLOATLIT 
-- On COMM reduce production complexPrimaryNoParenthesis -> FLOATLIT 
-- On COL reduce production complexPrimaryNoParenthesis -> FLOATLIT 
-- On BOR reduce production complexPrimaryNoParenthesis -> FLOATLIT 
-- On BAND reduce production complexPrimaryNoParenthesis -> FLOATLIT 
-- On ASSIGN reduce production complexPrimaryNoParenthesis -> FLOATLIT 
-- On ANDEQUAL reduce production complexPrimaryNoParenthesis -> FLOATLIT 
-- On AND reduce production complexPrimaryNoParenthesis -> FLOATLIT 

State 32:
complexPrimaryNoParenthesis -> DOUBLELIT . [ XOREQUAL XOR SEMI RSHIFTEQUAL RSHIFT RPAR RCURL RBRAC QM PLUS PEQUAL OREQUAL OR NEQUAL MULEQUAL MUL MODEQUAL MOD MINUSEQUAL MINUS LTHAN LSHIFTEQUAL LSHIFT LPAR LOGSHIFTEQUAL LOGSHIFT LETHAN LBRAC INSTANCEOF INCREMENT GTHAN GETHAN EQUAL DOT DIVEQUAL DIV DECREMENT COMM COL BOR BAND ASSIGN ANDEQUAL AND ]
-- On XOREQUAL reduce production complexPrimaryNoParenthesis -> DOUBLELIT 
-- On XOR reduce production complexPrimaryNoParenthesis -> DOUBLELIT 
-- On SEMI reduce production complexPrimaryNoParenthesis -> DOUBLELIT 
-- On RSHIFTEQUAL reduce production complexPrimaryNoParenthesis -> DOUBLELIT 
-- On RSHIFT reduce production complexPrimaryNoParenthesis -> DOUBLELIT 
-- On RPAR reduce production complexPrimaryNoParenthesis -> DOUBLELIT 
-- On RCURL reduce production complexPrimaryNoParenthesis -> DOUBLELIT 
-- On RBRAC reduce production complexPrimaryNoParenthesis -> DOUBLELIT 
-- On QM reduce production complexPrimaryNoParenthesis -> DOUBLELIT 
-- On PLUS reduce production complexPrimaryNoParenthesis -> DOUBLELIT 
-- On PEQUAL reduce production complexPrimaryNoParenthesis -> DOUBLELIT 
-- On OREQUAL reduce production complexPrimaryNoParenthesis -> DOUBLELIT 
-- On OR reduce production complexPrimaryNoParenthesis -> DOUBLELIT 
-- On NEQUAL reduce production complexPrimaryNoParenthesis -> DOUBLELIT 
-- On MULEQUAL reduce production complexPrimaryNoParenthesis -> DOUBLELIT 
-- On MUL reduce production complexPrimaryNoParenthesis -> DOUBLELIT 
-- On MODEQUAL reduce production complexPrimaryNoParenthesis -> DOUBLELIT 
-- On MOD reduce production complexPrimaryNoParenthesis -> DOUBLELIT 
-- On MINUSEQUAL reduce production complexPrimaryNoParenthesis -> DOUBLELIT 
-- On MINUS reduce production complexPrimaryNoParenthesis -> DOUBLELIT 
-- On LTHAN reduce production complexPrimaryNoParenthesis -> DOUBLELIT 
-- On LSHIFTEQUAL reduce production complexPrimaryNoParenthesis -> DOUBLELIT 
-- On LSHIFT reduce production complexPrimaryNoParenthesis -> DOUBLELIT 
-- On LPAR reduce production complexPrimaryNoParenthesis -> DOUBLELIT 
-- On LOGSHIFTEQUAL reduce production complexPrimaryNoParenthesis -> DOUBLELIT 
-- On LOGSHIFT reduce production complexPrimaryNoParenthesis -> DOUBLELIT 
-- On LETHAN reduce production complexPrimaryNoParenthesis -> DOUBLELIT 
-- On LBRAC reduce production complexPrimaryNoParenthesis -> DOUBLELIT 
-- On INSTANCEOF reduce production complexPrimaryNoParenthesis -> DOUBLELIT 
-- On INCREMENT reduce production complexPrimaryNoParenthesis -> DOUBLELIT 
-- On GTHAN reduce production complexPrimaryNoParenthesis -> DOUBLELIT 
-- On GETHAN reduce production complexPrimaryNoParenthesis -> DOUBLELIT 
-- On EQUAL reduce production complexPrimaryNoParenthesis -> DOUBLELIT 
-- On DOT reduce production complexPrimaryNoParenthesis -> DOUBLELIT 
-- On DIVEQUAL reduce production complexPrimaryNoParenthesis -> DOUBLELIT 
-- On DIV reduce production complexPrimaryNoParenthesis -> DOUBLELIT 
-- On DECREMENT reduce production complexPrimaryNoParenthesis -> DOUBLELIT 
-- On COMM reduce production complexPrimaryNoParenthesis -> DOUBLELIT 
-- On COL reduce production complexPrimaryNoParenthesis -> DOUBLELIT 
-- On BOR reduce production complexPrimaryNoParenthesis -> DOUBLELIT 
-- On BAND reduce production complexPrimaryNoParenthesis -> DOUBLELIT 
-- On ASSIGN reduce production complexPrimaryNoParenthesis -> DOUBLELIT 
-- On ANDEQUAL reduce production complexPrimaryNoParenthesis -> DOUBLELIT 
-- On AND reduce production complexPrimaryNoParenthesis -> DOUBLELIT 

State 33:
unaryExpression -> DECREMENT . unaryExpression [ XOREQUAL XOR SEMI RSHIFTEQUAL RSHIFT RPAR RCURL RBRAC QM PLUS PEQUAL OREQUAL OR NEQUAL MULEQUAL MUL MODEQUAL MOD MINUSEQUAL MINUS LTHAN LSHIFTEQUAL LSHIFT LOGSHIFTEQUAL LOGSHIFT LETHAN INSTANCEOF GTHAN GETHAN EQUAL DIVEQUAL DIV COMM COL BOR BAND ASSIGN ANDEQUAL AND ]
-- On VOID shift to state 6
-- On THIS shift to state 7
-- On SUPER shift to state 8
-- On STRLIT shift to state 9
-- On SHORT shift to state 10
-- On PLUS shift to state 11
-- On NULLLIT shift to state 12
-- On NOT shift to state 13
-- On NEW shift to state 14
-- On MINUS shift to state 26
-- On LPAR shift to state 30
-- On LONG shift to state 15
-- On INTLIT shift to state 28
-- On INT shift to state 16
-- On INCREMENT shift to state 29
-- On IDENTIFIER shift to state 17
-- On FLOATLIT shift to state 31
-- On FLOAT shift to state 18
-- On DOUBLELIT shift to state 32
-- On DOUBLE shift to state 19
-- On DECREMENT shift to state 33
-- On CHARLIT shift to state 34
-- On CHAR shift to state 20
-- On BYTE shift to state 21
-- On BOOLEANLIT shift to state 35
-- On BOOLEAN shift to state 22
-- On BNOT shift to state 36
-- On unaryExpression shift to state 37
-- On specialName shift to state 38
-- On realPostfixExpression shift to state 39
-- On qualifiedName shift to state 42
-- On primitiveType shift to state 61
-- On primaryExpression shift to state 64
-- On postfixExpression shift to state 65
-- On plainNewAllocationExpression shift to state 68
-- On notJustName shift to state 69
-- On newAllocationExpression shift to state 72
-- On methodCall shift to state 75
-- On methodAccess shift to state 76
-- On logicalUnaryOperator shift to state 83
-- On logicalUnaryExpression shift to state 85
-- On fieldAccess shift to state 86
-- On complexPrimaryNoParenthesis shift to state 87
-- On complexPrimary shift to state 88
-- On classAllocationExpression shift to state 100
-- On arrayAllocationExpression shift to state 104
-- On arrayAccess shift to state 120
-- On arithmeticUnaryOperator shift to state 121

State 34:
complexPrimaryNoParenthesis -> CHARLIT . [ XOREQUAL XOR SEMI RSHIFTEQUAL RSHIFT RPAR RCURL RBRAC QM PLUS PEQUAL OREQUAL OR NEQUAL MULEQUAL MUL MODEQUAL MOD MINUSEQUAL MINUS LTHAN LSHIFTEQUAL LSHIFT LPAR LOGSHIFTEQUAL LOGSHIFT LETHAN LBRAC INSTANCEOF INCREMENT GTHAN GETHAN EQUAL DOT DIVEQUAL DIV DECREMENT COMM COL BOR BAND ASSIGN ANDEQUAL AND ]
-- On XOREQUAL reduce production complexPrimaryNoParenthesis -> CHARLIT 
-- On XOR reduce production complexPrimaryNoParenthesis -> CHARLIT 
-- On SEMI reduce production complexPrimaryNoParenthesis -> CHARLIT 
-- On RSHIFTEQUAL reduce production complexPrimaryNoParenthesis -> CHARLIT 
-- On RSHIFT reduce production complexPrimaryNoParenthesis -> CHARLIT 
-- On RPAR reduce production complexPrimaryNoParenthesis -> CHARLIT 
-- On RCURL reduce production complexPrimaryNoParenthesis -> CHARLIT 
-- On RBRAC reduce production complexPrimaryNoParenthesis -> CHARLIT 
-- On QM reduce production complexPrimaryNoParenthesis -> CHARLIT 
-- On PLUS reduce production complexPrimaryNoParenthesis -> CHARLIT 
-- On PEQUAL reduce production complexPrimaryNoParenthesis -> CHARLIT 
-- On OREQUAL reduce production complexPrimaryNoParenthesis -> CHARLIT 
-- On OR reduce production complexPrimaryNoParenthesis -> CHARLIT 
-- On NEQUAL reduce production complexPrimaryNoParenthesis -> CHARLIT 
-- On MULEQUAL reduce production complexPrimaryNoParenthesis -> CHARLIT 
-- On MUL reduce production complexPrimaryNoParenthesis -> CHARLIT 
-- On MODEQUAL reduce production complexPrimaryNoParenthesis -> CHARLIT 
-- On MOD reduce production complexPrimaryNoParenthesis -> CHARLIT 
-- On MINUSEQUAL reduce production complexPrimaryNoParenthesis -> CHARLIT 
-- On MINUS reduce production complexPrimaryNoParenthesis -> CHARLIT 
-- On LTHAN reduce production complexPrimaryNoParenthesis -> CHARLIT 
-- On LSHIFTEQUAL reduce production complexPrimaryNoParenthesis -> CHARLIT 
-- On LSHIFT reduce production complexPrimaryNoParenthesis -> CHARLIT 
-- On LPAR reduce production complexPrimaryNoParenthesis -> CHARLIT 
-- On LOGSHIFTEQUAL reduce production complexPrimaryNoParenthesis -> CHARLIT 
-- On LOGSHIFT reduce production complexPrimaryNoParenthesis -> CHARLIT 
-- On LETHAN reduce production complexPrimaryNoParenthesis -> CHARLIT 
-- On LBRAC reduce production complexPrimaryNoParenthesis -> CHARLIT 
-- On INSTANCEOF reduce production complexPrimaryNoParenthesis -> CHARLIT 
-- On INCREMENT reduce production complexPrimaryNoParenthesis -> CHARLIT 
-- On GTHAN reduce production complexPrimaryNoParenthesis -> CHARLIT 
-- On GETHAN reduce production complexPrimaryNoParenthesis -> CHARLIT 
-- On EQUAL reduce production complexPrimaryNoParenthesis -> CHARLIT 
-- On DOT reduce production complexPrimaryNoParenthesis -> CHARLIT 
-- On DIVEQUAL reduce production complexPrimaryNoParenthesis -> CHARLIT 
-- On DIV reduce production complexPrimaryNoParenthesis -> CHARLIT 
-- On DECREMENT reduce production complexPrimaryNoParenthesis -> CHARLIT 
-- On COMM reduce production complexPrimaryNoParenthesis -> CHARLIT 
-- On COL reduce production complexPrimaryNoParenthesis -> CHARLIT 
-- On BOR reduce production complexPrimaryNoParenthesis -> CHARLIT 
-- On BAND reduce production complexPrimaryNoParenthesis -> CHARLIT 
-- On ASSIGN reduce production complexPrimaryNoParenthesis -> CHARLIT 
-- On ANDEQUAL reduce production complexPrimaryNoParenthesis -> CHARLIT 
-- On AND reduce production complexPrimaryNoParenthesis -> CHARLIT 

State 35:
complexPrimaryNoParenthesis -> BOOLEANLIT . [ XOREQUAL XOR SEMI RSHIFTEQUAL RSHIFT RPAR RCURL RBRAC QM PLUS PEQUAL OREQUAL OR NEQUAL MULEQUAL MUL MODEQUAL MOD MINUSEQUAL MINUS LTHAN LSHIFTEQUAL LSHIFT LPAR LOGSHIFTEQUAL LOGSHIFT LETHAN LBRAC INSTANCEOF INCREMENT GTHAN GETHAN EQUAL DOT DIVEQUAL DIV DECREMENT COMM COL BOR BAND ASSIGN ANDEQUAL AND ]
-- On XOREQUAL reduce production complexPrimaryNoParenthesis -> BOOLEANLIT 
-- On XOR reduce production complexPrimaryNoParenthesis -> BOOLEANLIT 
-- On SEMI reduce production complexPrimaryNoParenthesis -> BOOLEANLIT 
-- On RSHIFTEQUAL reduce production complexPrimaryNoParenthesis -> BOOLEANLIT 
-- On RSHIFT reduce production complexPrimaryNoParenthesis -> BOOLEANLIT 
-- On RPAR reduce production complexPrimaryNoParenthesis -> BOOLEANLIT 
-- On RCURL reduce production complexPrimaryNoParenthesis -> BOOLEANLIT 
-- On RBRAC reduce production complexPrimaryNoParenthesis -> BOOLEANLIT 
-- On QM reduce production complexPrimaryNoParenthesis -> BOOLEANLIT 
-- On PLUS reduce production complexPrimaryNoParenthesis -> BOOLEANLIT 
-- On PEQUAL reduce production complexPrimaryNoParenthesis -> BOOLEANLIT 
-- On OREQUAL reduce production complexPrimaryNoParenthesis -> BOOLEANLIT 
-- On OR reduce production complexPrimaryNoParenthesis -> BOOLEANLIT 
-- On NEQUAL reduce production complexPrimaryNoParenthesis -> BOOLEANLIT 
-- On MULEQUAL reduce production complexPrimaryNoParenthesis -> BOOLEANLIT 
-- On MUL reduce production complexPrimaryNoParenthesis -> BOOLEANLIT 
-- On MODEQUAL reduce production complexPrimaryNoParenthesis -> BOOLEANLIT 
-- On MOD reduce production complexPrimaryNoParenthesis -> BOOLEANLIT 
-- On MINUSEQUAL reduce production complexPrimaryNoParenthesis -> BOOLEANLIT 
-- On MINUS reduce production complexPrimaryNoParenthesis -> BOOLEANLIT 
-- On LTHAN reduce production complexPrimaryNoParenthesis -> BOOLEANLIT 
-- On LSHIFTEQUAL reduce production complexPrimaryNoParenthesis -> BOOLEANLIT 
-- On LSHIFT reduce production complexPrimaryNoParenthesis -> BOOLEANLIT 
-- On LPAR reduce production complexPrimaryNoParenthesis -> BOOLEANLIT 
-- On LOGSHIFTEQUAL reduce production complexPrimaryNoParenthesis -> BOOLEANLIT 
-- On LOGSHIFT reduce production complexPrimaryNoParenthesis -> BOOLEANLIT 
-- On LETHAN reduce production complexPrimaryNoParenthesis -> BOOLEANLIT 
-- On LBRAC reduce production complexPrimaryNoParenthesis -> BOOLEANLIT 
-- On INSTANCEOF reduce production complexPrimaryNoParenthesis -> BOOLEANLIT 
-- On INCREMENT reduce production complexPrimaryNoParenthesis -> BOOLEANLIT 
-- On GTHAN reduce production complexPrimaryNoParenthesis -> BOOLEANLIT 
-- On GETHAN reduce production complexPrimaryNoParenthesis -> BOOLEANLIT 
-- On EQUAL reduce production complexPrimaryNoParenthesis -> BOOLEANLIT 
-- On DOT reduce production complexPrimaryNoParenthesis -> BOOLEANLIT 
-- On DIVEQUAL reduce production complexPrimaryNoParenthesis -> BOOLEANLIT 
-- On DIV reduce production complexPrimaryNoParenthesis -> BOOLEANLIT 
-- On DECREMENT reduce production complexPrimaryNoParenthesis -> BOOLEANLIT 
-- On COMM reduce production complexPrimaryNoParenthesis -> BOOLEANLIT 
-- On COL reduce production complexPrimaryNoParenthesis -> BOOLEANLIT 
-- On BOR reduce production complexPrimaryNoParenthesis -> BOOLEANLIT 
-- On BAND reduce production complexPrimaryNoParenthesis -> BOOLEANLIT 
-- On ASSIGN reduce production complexPrimaryNoParenthesis -> BOOLEANLIT 
-- On ANDEQUAL reduce production complexPrimaryNoParenthesis -> BOOLEANLIT 
-- On AND reduce production complexPrimaryNoParenthesis -> BOOLEANLIT 

State 36:
logicalUnaryOperator -> BNOT . [ VOID THIS SUPER STRLIT SHORT PLUS NULLLIT NOT NEW MINUS LPAR LONG INTLIT INT INCREMENT IDENTIFIER FLOATLIT FLOAT DOUBLELIT DOUBLE DECREMENT CHARLIT CHAR BYTE BOOLEANLIT BOOLEAN BNOT ]
-- On VOID reduce production logicalUnaryOperator -> BNOT 
-- On THIS reduce production logicalUnaryOperator -> BNOT 
-- On SUPER reduce production logicalUnaryOperator -> BNOT 
-- On STRLIT reduce production logicalUnaryOperator -> BNOT 
-- On SHORT reduce production logicalUnaryOperator -> BNOT 
-- On PLUS reduce production logicalUnaryOperator -> BNOT 
-- On NULLLIT reduce production logicalUnaryOperator -> BNOT 
-- On NOT reduce production logicalUnaryOperator -> BNOT 
-- On NEW reduce production logicalUnaryOperator -> BNOT 
-- On MINUS reduce production logicalUnaryOperator -> BNOT 
-- On LPAR reduce production logicalUnaryOperator -> BNOT 
-- On LONG reduce production logicalUnaryOperator -> BNOT 
-- On INTLIT reduce production logicalUnaryOperator -> BNOT 
-- On INT reduce production logicalUnaryOperator -> BNOT 
-- On INCREMENT reduce production logicalUnaryOperator -> BNOT 
-- On IDENTIFIER reduce production logicalUnaryOperator -> BNOT 
-- On FLOATLIT reduce production logicalUnaryOperator -> BNOT 
-- On FLOAT reduce production logicalUnaryOperator -> BNOT 
-- On DOUBLELIT reduce production logicalUnaryOperator -> BNOT 
-- On DOUBLE reduce production logicalUnaryOperator -> BNOT 
-- On DECREMENT reduce production logicalUnaryOperator -> BNOT 
-- On CHARLIT reduce production logicalUnaryOperator -> BNOT 
-- On CHAR reduce production logicalUnaryOperator -> BNOT 
-- On BYTE reduce production logicalUnaryOperator -> BNOT 
-- On BOOLEANLIT reduce production logicalUnaryOperator -> BNOT 
-- On BOOLEAN reduce production logicalUnaryOperator -> BNOT 
-- On BNOT reduce production logicalUnaryOperator -> BNOT 

State 37:
unaryExpression -> DECREMENT unaryExpression . [ XOREQUAL XOR SEMI RSHIFTEQUAL RSHIFT RPAR RCURL RBRAC QM PLUS PEQUAL OREQUAL OR NEQUAL MULEQUAL MUL MODEQUAL MOD MINUSEQUAL MINUS LTHAN LSHIFTEQUAL LSHIFT LOGSHIFTEQUAL LOGSHIFT LETHAN INSTANCEOF GTHAN GETHAN EQUAL DIVEQUAL DIV COMM COL BOR BAND ASSIGN ANDEQUAL AND ]
-- On XOREQUAL reduce production unaryExpression -> DECREMENT unaryExpression 
-- On XOR reduce production unaryExpression -> DECREMENT unaryExpression 
-- On SEMI reduce production unaryExpression -> DECREMENT unaryExpression 
-- On RSHIFTEQUAL reduce production unaryExpression -> DECREMENT unaryExpression 
-- On RSHIFT reduce production unaryExpression -> DECREMENT unaryExpression 
-- On RPAR reduce production unaryExpression -> DECREMENT unaryExpression 
-- On RCURL reduce production unaryExpression -> DECREMENT unaryExpression 
-- On RBRAC reduce production unaryExpression -> DECREMENT unaryExpression 
-- On QM reduce production unaryExpression -> DECREMENT unaryExpression 
-- On PLUS reduce production unaryExpression -> DECREMENT unaryExpression 
-- On PEQUAL reduce production unaryExpression -> DECREMENT unaryExpression 
-- On OREQUAL reduce production unaryExpression -> DECREMENT unaryExpression 
-- On OR reduce production unaryExpression -> DECREMENT unaryExpression 
-- On NEQUAL reduce production unaryExpression -> DECREMENT unaryExpression 
-- On MULEQUAL reduce production unaryExpression -> DECREMENT unaryExpression 
-- On MUL reduce production unaryExpression -> DECREMENT unaryExpression 
-- On MODEQUAL reduce production unaryExpression -> DECREMENT unaryExpression 
-- On MOD reduce production unaryExpression -> DECREMENT unaryExpression 
-- On MINUSEQUAL reduce production unaryExpression -> DECREMENT unaryExpression 
-- On MINUS reduce production unaryExpression -> DECREMENT unaryExpression 
-- On LTHAN reduce production unaryExpression -> DECREMENT unaryExpression 
-- On LSHIFTEQUAL reduce production unaryExpression -> DECREMENT unaryExpression 
-- On LSHIFT reduce production unaryExpression -> DECREMENT unaryExpression 
-- On LOGSHIFTEQUAL reduce production unaryExpression -> DECREMENT unaryExpression 
-- On LOGSHIFT reduce production unaryExpression -> DECREMENT unaryExpression 
-- On LETHAN reduce production unaryExpression -> DECREMENT unaryExpression 
-- On INSTANCEOF reduce production unaryExpression -> DECREMENT unaryExpression 
-- On GTHAN reduce production unaryExpression -> DECREMENT unaryExpression 
-- On GETHAN reduce production unaryExpression -> DECREMENT unaryExpression 
-- On EQUAL reduce production unaryExpression -> DECREMENT unaryExpression 
-- On DIVEQUAL reduce production unaryExpression -> DECREMENT unaryExpression 
-- On DIV reduce production unaryExpression -> DECREMENT unaryExpression 
-- On COMM reduce production unaryExpression -> DECREMENT unaryExpression 
-- On COL reduce production unaryExpression -> DECREMENT unaryExpression 
-- On BOR reduce production unaryExpression -> DECREMENT unaryExpression 
-- On BAND reduce production unaryExpression -> DECREMENT unaryExpression 
-- On ASSIGN reduce production unaryExpression -> DECREMENT unaryExpression 
-- On ANDEQUAL reduce production unaryExpression -> DECREMENT unaryExpression 
-- On AND reduce production unaryExpression -> DECREMENT unaryExpression 

State 38:
methodAccess -> specialName . [ LPAR ]
notJustName -> specialName . [ XOREQUAL XOR SEMI RSHIFTEQUAL RSHIFT RPAR RCURL RBRAC QM PLUS PEQUAL OREQUAL OR NEQUAL MULEQUAL MUL MODEQUAL MOD MINUSEQUAL MINUS LTHAN LSHIFTEQUAL LSHIFT LOGSHIFTEQUAL LOGSHIFT LETHAN INSTANCEOF INCREMENT GTHAN GETHAN EQUAL DOT DIVEQUAL DIV DECREMENT COMM COL BOR BAND ASSIGN ANDEQUAL AND ]
-- On XOREQUAL reduce production notJustName -> specialName 
-- On XOR reduce production notJustName -> specialName 
-- On SEMI reduce production notJustName -> specialName 
-- On RSHIFTEQUAL reduce production notJustName -> specialName 
-- On RSHIFT reduce production notJustName -> specialName 
-- On RPAR reduce production notJustName -> specialName 
-- On RCURL reduce production notJustName -> specialName 
-- On RBRAC reduce production notJustName -> specialName 
-- On QM reduce production notJustName -> specialName 
-- On PLUS reduce production notJustName -> specialName 
-- On PEQUAL reduce production notJustName -> specialName 
-- On OREQUAL reduce production notJustName -> specialName 
-- On OR reduce production notJustName -> specialName 
-- On NEQUAL reduce production notJustName -> specialName 
-- On MULEQUAL reduce production notJustName -> specialName 
-- On MUL reduce production notJustName -> specialName 
-- On MODEQUAL reduce production notJustName -> specialName 
-- On MOD reduce production notJustName -> specialName 
-- On MINUSEQUAL reduce production notJustName -> specialName 
-- On MINUS reduce production notJustName -> specialName 
-- On LTHAN reduce production notJustName -> specialName 
-- On LSHIFTEQUAL reduce production notJustName -> specialName 
-- On LSHIFT reduce production notJustName -> specialName 
-- On LPAR reduce production methodAccess -> specialName 
-- On LOGSHIFTEQUAL reduce production notJustName -> specialName 
-- On LOGSHIFT reduce production notJustName -> specialName 
-- On LETHAN reduce production notJustName -> specialName 
-- On INSTANCEOF reduce production notJustName -> specialName 
-- On INCREMENT reduce production notJustName -> specialName 
-- On GTHAN reduce production notJustName -> specialName 
-- On GETHAN reduce production notJustName -> specialName 
-- On EQUAL reduce production notJustName -> specialName 
-- On DOT reduce production notJustName -> specialName 
-- On DIVEQUAL reduce production notJustName -> specialName 
-- On DIV reduce production notJustName -> specialName 
-- On DECREMENT reduce production notJustName -> specialName 
-- On COMM reduce production notJustName -> specialName 
-- On COL reduce production notJustName -> specialName 
-- On BOR reduce production notJustName -> specialName 
-- On BAND reduce production notJustName -> specialName 
-- On ASSIGN reduce production notJustName -> specialName 
-- On ANDEQUAL reduce production notJustName -> specialName 
-- On AND reduce production notJustName -> specialName 

State 39:
fieldAccess -> realPostfixExpression . DOT IDENTIFIER [ XOREQUAL XOR SEMI RSHIFTEQUAL RSHIFT RPAR RCURL RBRAC QM PLUS PEQUAL OREQUAL OR NEQUAL MULEQUAL MUL MODEQUAL MOD MINUSEQUAL MINUS LTHAN LSHIFTEQUAL LSHIFT LPAR LOGSHIFTEQUAL LOGSHIFT LETHAN LBRAC INSTANCEOF INCREMENT GTHAN GETHAN EQUAL DOT DIVEQUAL DIV DECREMENT COMM COL BOR BAND ASSIGN ANDEQUAL AND ]
postfixExpression -> realPostfixExpression . [ XOREQUAL XOR SEMI RSHIFTEQUAL RSHIFT RPAR RCURL RBRAC QM PLUS PEQUAL OREQUAL OR NEQUAL MULEQUAL MUL MODEQUAL MOD MINUSEQUAL MINUS LTHAN LSHIFTEQUAL LSHIFT LOGSHIFTEQUAL LOGSHIFT LETHAN INSTANCEOF INCREMENT GTHAN GETHAN EQUAL DIVEQUAL DIV DECREMENT COMM COL BOR BAND ASSIGN ANDEQUAL AND ]
-- On DOT shift to state 40
-- On XOREQUAL reduce production postfixExpression -> realPostfixExpression 
-- On XOR reduce production postfixExpression -> realPostfixExpression 
-- On SEMI reduce production postfixExpression -> realPostfixExpression 
-- On RSHIFTEQUAL reduce production postfixExpression -> realPostfixExpression 
-- On RSHIFT reduce production postfixExpression -> realPostfixExpression 
-- On RPAR reduce production postfixExpression -> realPostfixExpression 
-- On RCURL reduce production postfixExpression -> realPostfixExpression 
-- On RBRAC reduce production postfixExpression -> realPostfixExpression 
-- On QM reduce production postfixExpression -> realPostfixExpression 
-- On PLUS reduce production postfixExpression -> realPostfixExpression 
-- On PEQUAL reduce production postfixExpression -> realPostfixExpression 
-- On OREQUAL reduce production postfixExpression -> realPostfixExpression 
-- On OR reduce production postfixExpression -> realPostfixExpression 
-- On NEQUAL reduce production postfixExpression -> realPostfixExpression 
-- On MULEQUAL reduce production postfixExpression -> realPostfixExpression 
-- On MUL reduce production postfixExpression -> realPostfixExpression 
-- On MODEQUAL reduce production postfixExpression -> realPostfixExpression 
-- On MOD reduce production postfixExpression -> realPostfixExpression 
-- On MINUSEQUAL reduce production postfixExpression -> realPostfixExpression 
-- On MINUS reduce production postfixExpression -> realPostfixExpression 
-- On LTHAN reduce production postfixExpression -> realPostfixExpression 
-- On LSHIFTEQUAL reduce production postfixExpression -> realPostfixExpression 
-- On LSHIFT reduce production postfixExpression -> realPostfixExpression 
-- On LOGSHIFTEQUAL reduce production postfixExpression -> realPostfixExpression 
-- On LOGSHIFT reduce production postfixExpression -> realPostfixExpression 
-- On LETHAN reduce production postfixExpression -> realPostfixExpression 
-- On INSTANCEOF reduce production postfixExpression -> realPostfixExpression 
-- On INCREMENT reduce production postfixExpression -> realPostfixExpression 
-- On GTHAN reduce production postfixExpression -> realPostfixExpression 
-- On GETHAN reduce production postfixExpression -> realPostfixExpression 
-- On EQUAL reduce production postfixExpression -> realPostfixExpression 
-- On DIVEQUAL reduce production postfixExpression -> realPostfixExpression 
-- On DIV reduce production postfixExpression -> realPostfixExpression 
-- On DECREMENT reduce production postfixExpression -> realPostfixExpression 
-- On COMM reduce production postfixExpression -> realPostfixExpression 
-- On COL reduce production postfixExpression -> realPostfixExpression 
-- On BOR reduce production postfixExpression -> realPostfixExpression 
-- On BAND reduce production postfixExpression -> realPostfixExpression 
-- On ASSIGN reduce production postfixExpression -> realPostfixExpression 
-- On ANDEQUAL reduce production postfixExpression -> realPostfixExpression 
-- On AND reduce production postfixExpression -> realPostfixExpression 

State 40:
fieldAccess -> realPostfixExpression DOT . IDENTIFIER [ XOREQUAL XOR SEMI RSHIFTEQUAL RSHIFT RPAR RCURL RBRAC QM PLUS PEQUAL OREQUAL OR NEQUAL MULEQUAL MUL MODEQUAL MOD MINUSEQUAL MINUS LTHAN LSHIFTEQUAL LSHIFT LPAR LOGSHIFTEQUAL LOGSHIFT LETHAN LBRAC INSTANCEOF INCREMENT GTHAN GETHAN EQUAL DOT DIVEQUAL DIV DECREMENT COMM COL BOR BAND ASSIGN ANDEQUAL AND ]
-- On IDENTIFIER shift to state 41

State 41:
fieldAccess -> realPostfixExpression DOT IDENTIFIER . [ XOREQUAL XOR SEMI RSHIFTEQUAL RSHIFT RPAR RCURL RBRAC QM PLUS PEQUAL OREQUAL OR NEQUAL MULEQUAL MUL MODEQUAL MOD MINUSEQUAL MINUS LTHAN LSHIFTEQUAL LSHIFT LPAR LOGSHIFTEQUAL LOGSHIFT LETHAN LBRAC INSTANCEOF INCREMENT GTHAN GETHAN EQUAL DOT DIVEQUAL DIV DECREMENT COMM COL BOR BAND ASSIGN ANDEQUAL AND ]
-- On XOREQUAL reduce production fieldAccess -> realPostfixExpression DOT IDENTIFIER 
-- On XOR reduce production fieldAccess -> realPostfixExpression DOT IDENTIFIER 
-- On SEMI reduce production fieldAccess -> realPostfixExpression DOT IDENTIFIER 
-- On RSHIFTEQUAL reduce production fieldAccess -> realPostfixExpression DOT IDENTIFIER 
-- On RSHIFT reduce production fieldAccess -> realPostfixExpression DOT IDENTIFIER 
-- On RPAR reduce production fieldAccess -> realPostfixExpression DOT IDENTIFIER 
-- On RCURL reduce production fieldAccess -> realPostfixExpression DOT IDENTIFIER 
-- On RBRAC reduce production fieldAccess -> realPostfixExpression DOT IDENTIFIER 
-- On QM reduce production fieldAccess -> realPostfixExpression DOT IDENTIFIER 
-- On PLUS reduce production fieldAccess -> realPostfixExpression DOT IDENTIFIER 
-- On PEQUAL reduce production fieldAccess -> realPostfixExpression DOT IDENTIFIER 
-- On OREQUAL reduce production fieldAccess -> realPostfixExpression DOT IDENTIFIER 
-- On OR reduce production fieldAccess -> realPostfixExpression DOT IDENTIFIER 
-- On NEQUAL reduce production fieldAccess -> realPostfixExpression DOT IDENTIFIER 
-- On MULEQUAL reduce production fieldAccess -> realPostfixExpression DOT IDENTIFIER 
-- On MUL reduce production fieldAccess -> realPostfixExpression DOT IDENTIFIER 
-- On MODEQUAL reduce production fieldAccess -> realPostfixExpression DOT IDENTIFIER 
-- On MOD reduce production fieldAccess -> realPostfixExpression DOT IDENTIFIER 
-- On MINUSEQUAL reduce production fieldAccess -> realPostfixExpression DOT IDENTIFIER 
-- On MINUS reduce production fieldAccess -> realPostfixExpression DOT IDENTIFIER 
-- On LTHAN reduce production fieldAccess -> realPostfixExpression DOT IDENTIFIER 
-- On LSHIFTEQUAL reduce production fieldAccess -> realPostfixExpression DOT IDENTIFIER 
-- On LSHIFT reduce production fieldAccess -> realPostfixExpression DOT IDENTIFIER 
-- On LPAR reduce production fieldAccess -> realPostfixExpression DOT IDENTIFIER 
-- On LOGSHIFTEQUAL reduce production fieldAccess -> realPostfixExpression DOT IDENTIFIER 
-- On LOGSHIFT reduce production fieldAccess -> realPostfixExpression DOT IDENTIFIER 
-- On LETHAN reduce production fieldAccess -> realPostfixExpression DOT IDENTIFIER 
-- On LBRAC reduce production fieldAccess -> realPostfixExpression DOT IDENTIFIER 
-- On INSTANCEOF reduce production fieldAccess -> realPostfixExpression DOT IDENTIFIER 
-- On INCREMENT reduce production fieldAccess -> realPostfixExpression DOT IDENTIFIER 
-- On GTHAN reduce production fieldAccess -> realPostfixExpression DOT IDENTIFIER 
-- On GETHAN reduce production fieldAccess -> realPostfixExpression DOT IDENTIFIER 
-- On EQUAL reduce production fieldAccess -> realPostfixExpression DOT IDENTIFIER 
-- On DOT reduce production fieldAccess -> realPostfixExpression DOT IDENTIFIER 
-- On DIVEQUAL reduce production fieldAccess -> realPostfixExpression DOT IDENTIFIER 
-- On DIV reduce production fieldAccess -> realPostfixExpression DOT IDENTIFIER 
-- On DECREMENT reduce production fieldAccess -> realPostfixExpression DOT IDENTIFIER 
-- On COMM reduce production fieldAccess -> realPostfixExpression DOT IDENTIFIER 
-- On COL reduce production fieldAccess -> realPostfixExpression DOT IDENTIFIER 
-- On BOR reduce production fieldAccess -> realPostfixExpression DOT IDENTIFIER 
-- On BAND reduce production fieldAccess -> realPostfixExpression DOT IDENTIFIER 
-- On ASSIGN reduce production fieldAccess -> realPostfixExpression DOT IDENTIFIER 
-- On ANDEQUAL reduce production fieldAccess -> realPostfixExpression DOT IDENTIFIER 
-- On AND reduce production fieldAccess -> realPostfixExpression DOT IDENTIFIER 

State 42:
arrayAccess -> qualifiedName . LBRAC expression RBRAC [ XOREQUAL XOR SEMI RSHIFTEQUAL RSHIFT RPAR RCURL RBRAC QM PLUS PEQUAL OREQUAL OR NEQUAL MULEQUAL MUL MODEQUAL MOD MINUSEQUAL MINUS LTHAN LSHIFTEQUAL LSHIFT LPAR LOGSHIFTEQUAL LOGSHIFT LETHAN LBRAC INSTANCEOF INCREMENT GTHAN GETHAN EQUAL DOT DIVEQUAL DIV DECREMENT COMM COL BOR BAND ASSIGN ANDEQUAL AND ]
fieldAccess -> qualifiedName . DOT THIS [ XOREQUAL XOR SEMI RSHIFTEQUAL RSHIFT RPAR RCURL RBRAC QM PLUS PEQUAL OREQUAL OR NEQUAL MULEQUAL MUL MODEQUAL MOD MINUSEQUAL MINUS LTHAN LSHIFTEQUAL LSHIFT LPAR LOGSHIFTEQUAL LOGSHIFT LETHAN LBRAC INSTANCEOF INCREMENT GTHAN GETHAN EQUAL DOT DIVEQUAL DIV DECREMENT COMM COL BOR BAND ASSIGN ANDEQUAL AND ]
fieldAccess -> qualifiedName . DOT CLASS [ XOREQUAL XOR SEMI RSHIFTEQUAL RSHIFT RPAR RCURL RBRAC QM PLUS PEQUAL OREQUAL OR NEQUAL MULEQUAL MUL MODEQUAL MOD MINUSEQUAL MINUS LTHAN LSHIFTEQUAL LSHIFT LPAR LOGSHIFTEQUAL LOGSHIFT LETHAN LBRAC INSTANCEOF INCREMENT GTHAN GETHAN EQUAL DOT DIVEQUAL DIV DECREMENT COMM COL BOR BAND ASSIGN ANDEQUAL AND ]
methodAccess -> qualifiedName . [ LPAR ]
newAllocationExpression -> qualifiedName . DOT plainNewAllocationExpression [ XOREQUAL XOR SEMI RSHIFTEQUAL RSHIFT RPAR RCURL RBRAC QM PLUS PEQUAL OREQUAL OR NEQUAL MULEQUAL MUL MODEQUAL MOD MINUSEQUAL MINUS LTHAN LSHIFTEQUAL LSHIFT LOGSHIFTEQUAL LOGSHIFT LETHAN INSTANCEOF INCREMENT GTHAN GETHAN EQUAL DOT DIVEQUAL DIV DECREMENT COMM COL BOR BAND ASSIGN ANDEQUAL AND ]
primaryExpression -> qualifiedName . [ XOREQUAL XOR SEMI RSHIFTEQUAL RSHIFT RPAR RCURL RBRAC QM PLUS PEQUAL OREQUAL OR NEQUAL MULEQUAL MUL MODEQUAL MOD MINUSEQUAL MINUS LTHAN LSHIFTEQUAL LSHIFT LOGSHIFTEQUAL LOGSHIFT LETHAN INSTANCEOF INCREMENT GTHAN GETHAN EQUAL DIVEQUAL DIV DECREMENT COMM COL BOR BAND ASSIGN ANDEQUAL AND ]
qualifiedName -> qualifiedName . DOT IDENTIFIER [ XOREQUAL XOR SEMI RSHIFTEQUAL RSHIFT RPAR RCURL RBRAC QM PLUS PEQUAL OREQUAL OR NEQUAL MULEQUAL MUL MODEQUAL MOD MINUSEQUAL MINUS LTHAN LSHIFTEQUAL LSHIFT LPAR LOGSHIFTEQUAL LOGSHIFT LETHAN LBRAC INSTANCEOF INCREMENT GTHAN GETHAN EQUAL DOT DIVEQUAL DIV DECREMENT COMM COL BOR BAND ASSIGN ANDEQUAL AND ]
-- On LBRAC shift to state 43
-- On DOT shift to state 176
-- On XOREQUAL reduce production primaryExpression -> qualifiedName 
-- On XOR reduce production primaryExpression -> qualifiedName 
-- On SEMI reduce production primaryExpression -> qualifiedName 
-- On RSHIFTEQUAL reduce production primaryExpression -> qualifiedName 
-- On RSHIFT reduce production primaryExpression -> qualifiedName 
-- On RPAR reduce production primaryExpression -> qualifiedName 
-- On RCURL reduce production primaryExpression -> qualifiedName 
-- On RBRAC reduce production primaryExpression -> qualifiedName 
-- On QM reduce production primaryExpression -> qualifiedName 
-- On PLUS reduce production primaryExpression -> qualifiedName 
-- On PEQUAL reduce production primaryExpression -> qualifiedName 
-- On OREQUAL reduce production primaryExpression -> qualifiedName 
-- On OR reduce production primaryExpression -> qualifiedName 
-- On NEQUAL reduce production primaryExpression -> qualifiedName 
-- On MULEQUAL reduce production primaryExpression -> qualifiedName 
-- On MUL reduce production primaryExpression -> qualifiedName 
-- On MODEQUAL reduce production primaryExpression -> qualifiedName 
-- On MOD reduce production primaryExpression -> qualifiedName 
-- On MINUSEQUAL reduce production primaryExpression -> qualifiedName 
-- On MINUS reduce production primaryExpression -> qualifiedName 
-- On LTHAN reduce production primaryExpression -> qualifiedName 
-- On LSHIFTEQUAL reduce production primaryExpression -> qualifiedName 
-- On LSHIFT reduce production primaryExpression -> qualifiedName 
-- On LPAR reduce production methodAccess -> qualifiedName 
-- On LOGSHIFTEQUAL reduce production primaryExpression -> qualifiedName 
-- On LOGSHIFT reduce production primaryExpression -> qualifiedName 
-- On LETHAN reduce production primaryExpression -> qualifiedName 
-- On INSTANCEOF reduce production primaryExpression -> qualifiedName 
-- On INCREMENT reduce production primaryExpression -> qualifiedName 
-- On GTHAN reduce production primaryExpression -> qualifiedName 
-- On GETHAN reduce production primaryExpression -> qualifiedName 
-- On EQUAL reduce production primaryExpression -> qualifiedName 
-- On DIVEQUAL reduce production primaryExpression -> qualifiedName 
-- On DIV reduce production primaryExpression -> qualifiedName 
-- On DECREMENT reduce production primaryExpression -> qualifiedName 
-- On COMM reduce production primaryExpression -> qualifiedName 
-- On COL reduce production primaryExpression -> qualifiedName 
-- On BOR reduce production primaryExpression -> qualifiedName 
-- On BAND reduce production primaryExpression -> qualifiedName 
-- On ASSIGN reduce production primaryExpression -> qualifiedName 
-- On ANDEQUAL reduce production primaryExpression -> qualifiedName 
-- On AND reduce production primaryExpression -> qualifiedName 

State 43:
arrayAccess -> qualifiedName LBRAC . expression RBRAC [ XOREQUAL XOR SEMI RSHIFTEQUAL RSHIFT RPAR RCURL RBRAC QM PLUS PEQUAL OREQUAL OR NEQUAL MULEQUAL MUL MODEQUAL MOD MINUSEQUAL MINUS LTHAN LSHIFTEQUAL LSHIFT LPAR LOGSHIFTEQUAL LOGSHIFT LETHAN LBRAC INSTANCEOF INCREMENT GTHAN GETHAN EQUAL DOT DIVEQUAL DIV DECREMENT COMM COL BOR BAND ASSIGN ANDEQUAL AND ]
-- On error shift to state 3
-- On VOID shift to state 6
-- On THIS shift to state 7
-- On SUPER shift to state 8
-- On STRLIT shift to state 9
-- On SHORT shift to state 10
-- On PLUS shift to state 11
-- On NULLLIT shift to state 12
-- On NOT shift to state 13
-- On NEW shift to state 14
-- On MINUS shift to state 26
-- On LPAR shift to state 27
-- On LONG shift to state 15
-- On INTLIT shift to state 28
-- On INT shift to state 16
-- On INCREMENT shift to state 29
-- On IDENTIFIER shift to state 17
-- On FLOATLIT shift to state 31
-- On FLOAT shift to state 18
-- On DOUBLELIT shift to state 32
-- On DOUBLE shift to state 19
-- On DECREMENT shift to state 33
-- On CHARLIT shift to state 34
-- On CHAR shift to state 20
-- On BYTE shift to state 21
-- On BOOLEANLIT shift to state 35
-- On BOOLEAN shift to state 22
-- On BNOT shift to state 36
-- On unaryExpression shift to state 44
-- On specialName shift to state 38
-- On shiftExpression shift to state 58
-- On relationalExpression shift to state 79
-- On realPostfixExpression shift to state 39
-- On qualifiedName shift to state 42
-- On primitiveType shift to state 61
-- On primaryExpression shift to state 64
-- On postfixExpression shift to state 65
-- On plainNewAllocationExpression shift to state 68
-- On notJustName shift to state 69
-- On newAllocationExpression shift to state 72
-- On multiplicativeExpression shift to state 73
-- On methodCall shift to state 75
-- On methodAccess shift to state 76
-- On logicalUnaryOperator shift to state 83
-- On logicalUnaryExpression shift to state 85
-- On inclusiveOrExpression shift to state 90
-- On fieldAccess shift to state 86
-- On expression shift to state 174
-- On exclusiveOrExpression shift to state 111
-- On equalityExpression shift to state 94
-- On conditionalOrExpression shift to state 112
-- On conditionalExpression shift to state 151
-- On conditionalAndExpression shift to state 117
-- On complexPrimaryNoParenthesis shift to state 87
-- On complexPrimary shift to state 88
-- On classAllocationExpression shift to state 100
-- On castExpression shift to state 103
-- On assignmentExpression shift to state 152
-- On arrayAllocationExpression shift to state 104
-- On arrayAccess shift to state 120
-- On arithmeticUnaryOperator shift to state 121
-- On andExpression shift to state 123
-- On additiveExpression shift to state 140

State 44:
assignmentExpression -> unaryExpression . assignmentOperator assignmentExpression [ SEMI RPAR RCURL RBRAC COMM COL ]
castExpression -> unaryExpression . [ XOR SEMI RSHIFT RPAR RCURL RBRAC QM PLUS OR NEQUAL MUL MOD MINUS LTHAN LSHIFT LOGSHIFT LETHAN INSTANCEOF GTHAN GETHAN EQUAL DIV COMM COL BOR BAND AND ]
-- On XOREQUAL shift to state 45
-- On RSHIFTEQUAL shift to state 46
-- On PEQUAL shift to state 47
-- On OREQUAL shift to state 48
-- On MULEQUAL shift to state 49
-- On MODEQUAL shift to state 50
-- On MINUSEQUAL shift to state 51
-- On LSHIFTEQUAL shift to state 52
-- On LOGSHIFTEQUAL shift to state 53
-- On DIVEQUAL shift to state 54
-- On ASSIGN shift to state 55
-- On ANDEQUAL shift to state 56
-- On assignmentOperator shift to state 57
-- On XOR reduce production castExpression -> unaryExpression 
-- On SEMI reduce production castExpression -> unaryExpression 
-- On RSHIFT reduce production castExpression -> unaryExpression 
-- On RPAR reduce production castExpression -> unaryExpression 
-- On RCURL reduce production castExpression -> unaryExpression 
-- On RBRAC reduce production castExpression -> unaryExpression 
-- On QM reduce production castExpression -> unaryExpression 
-- On PLUS reduce production castExpression -> unaryExpression 
-- On OR reduce production castExpression -> unaryExpression 
-- On NEQUAL reduce production castExpression -> unaryExpression 
-- On MUL reduce production castExpression -> unaryExpression 
-- On MOD reduce production castExpression -> unaryExpression 
-- On MINUS reduce production castExpression -> unaryExpression 
-- On LTHAN reduce production castExpression -> unaryExpression 
-- On LSHIFT reduce production castExpression -> unaryExpression 
-- On LOGSHIFT reduce production castExpression -> unaryExpression 
-- On LETHAN reduce production castExpression -> unaryExpression 
-- On INSTANCEOF reduce production castExpression -> unaryExpression 
-- On GTHAN reduce production castExpression -> unaryExpression 
-- On GETHAN reduce production castExpression -> unaryExpression 
-- On EQUAL reduce production castExpression -> unaryExpression 
-- On DIV reduce production castExpression -> unaryExpression 
-- On COMM reduce production castExpression -> unaryExpression 
-- On COL reduce production castExpression -> unaryExpression 
-- On BOR reduce production castExpression -> unaryExpression 
-- On BAND reduce production castExpression -> unaryExpression 
-- On AND reduce production castExpression -> unaryExpression 

State 45:
assignmentOperator -> XOREQUAL . [ VOID THIS SUPER STRLIT SHORT PLUS NULLLIT NOT NEW MINUS LPAR LONG INTLIT INT INCREMENT IDENTIFIER FLOATLIT FLOAT DOUBLELIT DOUBLE DECREMENT CHARLIT CHAR BYTE BOOLEANLIT BOOLEAN BNOT ]
-- On VOID reduce production assignmentOperator -> XOREQUAL 
-- On THIS reduce production assignmentOperator -> XOREQUAL 
-- On SUPER reduce production assignmentOperator -> XOREQUAL 
-- On STRLIT reduce production assignmentOperator -> XOREQUAL 
-- On SHORT reduce production assignmentOperator -> XOREQUAL 
-- On PLUS reduce production assignmentOperator -> XOREQUAL 
-- On NULLLIT reduce production assignmentOperator -> XOREQUAL 
-- On NOT reduce production assignmentOperator -> XOREQUAL 
-- On NEW reduce production assignmentOperator -> XOREQUAL 
-- On MINUS reduce production assignmentOperator -> XOREQUAL 
-- On LPAR reduce production assignmentOperator -> XOREQUAL 
-- On LONG reduce production assignmentOperator -> XOREQUAL 
-- On INTLIT reduce production assignmentOperator -> XOREQUAL 
-- On INT reduce production assignmentOperator -> XOREQUAL 
-- On INCREMENT reduce production assignmentOperator -> XOREQUAL 
-- On IDENTIFIER reduce production assignmentOperator -> XOREQUAL 
-- On FLOATLIT reduce production assignmentOperator -> XOREQUAL 
-- On FLOAT reduce production assignmentOperator -> XOREQUAL 
-- On DOUBLELIT reduce production assignmentOperator -> XOREQUAL 
-- On DOUBLE reduce production assignmentOperator -> XOREQUAL 
-- On DECREMENT reduce production assignmentOperator -> XOREQUAL 
-- On CHARLIT reduce production assignmentOperator -> XOREQUAL 
-- On CHAR reduce production assignmentOperator -> XOREQUAL 
-- On BYTE reduce production assignmentOperator -> XOREQUAL 
-- On BOOLEANLIT reduce production assignmentOperator -> XOREQUAL 
-- On BOOLEAN reduce production assignmentOperator -> XOREQUAL 
-- On BNOT reduce production assignmentOperator -> XOREQUAL 

State 46:
assignmentOperator -> RSHIFTEQUAL . [ VOID THIS SUPER STRLIT SHORT PLUS NULLLIT NOT NEW MINUS LPAR LONG INTLIT INT INCREMENT IDENTIFIER FLOATLIT FLOAT DOUBLELIT DOUBLE DECREMENT CHARLIT CHAR BYTE BOOLEANLIT BOOLEAN BNOT ]
-- On VOID reduce production assignmentOperator -> RSHIFTEQUAL 
-- On THIS reduce production assignmentOperator -> RSHIFTEQUAL 
-- On SUPER reduce production assignmentOperator -> RSHIFTEQUAL 
-- On STRLIT reduce production assignmentOperator -> RSHIFTEQUAL 
-- On SHORT reduce production assignmentOperator -> RSHIFTEQUAL 
-- On PLUS reduce production assignmentOperator -> RSHIFTEQUAL 
-- On NULLLIT reduce production assignmentOperator -> RSHIFTEQUAL 
-- On NOT reduce production assignmentOperator -> RSHIFTEQUAL 
-- On NEW reduce production assignmentOperator -> RSHIFTEQUAL 
-- On MINUS reduce production assignmentOperator -> RSHIFTEQUAL 
-- On LPAR reduce production assignmentOperator -> RSHIFTEQUAL 
-- On LONG reduce production assignmentOperator -> RSHIFTEQUAL 
-- On INTLIT reduce production assignmentOperator -> RSHIFTEQUAL 
-- On INT reduce production assignmentOperator -> RSHIFTEQUAL 
-- On INCREMENT reduce production assignmentOperator -> RSHIFTEQUAL 
-- On IDENTIFIER reduce production assignmentOperator -> RSHIFTEQUAL 
-- On FLOATLIT reduce production assignmentOperator -> RSHIFTEQUAL 
-- On FLOAT reduce production assignmentOperator -> RSHIFTEQUAL 
-- On DOUBLELIT reduce production assignmentOperator -> RSHIFTEQUAL 
-- On DOUBLE reduce production assignmentOperator -> RSHIFTEQUAL 
-- On DECREMENT reduce production assignmentOperator -> RSHIFTEQUAL 
-- On CHARLIT reduce production assignmentOperator -> RSHIFTEQUAL 
-- On CHAR reduce production assignmentOperator -> RSHIFTEQUAL 
-- On BYTE reduce production assignmentOperator -> RSHIFTEQUAL 
-- On BOOLEANLIT reduce production assignmentOperator -> RSHIFTEQUAL 
-- On BOOLEAN reduce production assignmentOperator -> RSHIFTEQUAL 
-- On BNOT reduce production assignmentOperator -> RSHIFTEQUAL 

State 47:
assignmentOperator -> PEQUAL . [ VOID THIS SUPER STRLIT SHORT PLUS NULLLIT NOT NEW MINUS LPAR LONG INTLIT INT INCREMENT IDENTIFIER FLOATLIT FLOAT DOUBLELIT DOUBLE DECREMENT CHARLIT CHAR BYTE BOOLEANLIT BOOLEAN BNOT ]
-- On VOID reduce production assignmentOperator -> PEQUAL 
-- On THIS reduce production assignmentOperator -> PEQUAL 
-- On SUPER reduce production assignmentOperator -> PEQUAL 
-- On STRLIT reduce production assignmentOperator -> PEQUAL 
-- On SHORT reduce production assignmentOperator -> PEQUAL 
-- On PLUS reduce production assignmentOperator -> PEQUAL 
-- On NULLLIT reduce production assignmentOperator -> PEQUAL 
-- On NOT reduce production assignmentOperator -> PEQUAL 
-- On NEW reduce production assignmentOperator -> PEQUAL 
-- On MINUS reduce production assignmentOperator -> PEQUAL 
-- On LPAR reduce production assignmentOperator -> PEQUAL 
-- On LONG reduce production assignmentOperator -> PEQUAL 
-- On INTLIT reduce production assignmentOperator -> PEQUAL 
-- On INT reduce production assignmentOperator -> PEQUAL 
-- On INCREMENT reduce production assignmentOperator -> PEQUAL 
-- On IDENTIFIER reduce production assignmentOperator -> PEQUAL 
-- On FLOATLIT reduce production assignmentOperator -> PEQUAL 
-- On FLOAT reduce production assignmentOperator -> PEQUAL 
-- On DOUBLELIT reduce production assignmentOperator -> PEQUAL 
-- On DOUBLE reduce production assignmentOperator -> PEQUAL 
-- On DECREMENT reduce production assignmentOperator -> PEQUAL 
-- On CHARLIT reduce production assignmentOperator -> PEQUAL 
-- On CHAR reduce production assignmentOperator -> PEQUAL 
-- On BYTE reduce production assignmentOperator -> PEQUAL 
-- On BOOLEANLIT reduce production assignmentOperator -> PEQUAL 
-- On BOOLEAN reduce production assignmentOperator -> PEQUAL 
-- On BNOT reduce production assignmentOperator -> PEQUAL 

State 48:
assignmentOperator -> OREQUAL . [ VOID THIS SUPER STRLIT SHORT PLUS NULLLIT NOT NEW MINUS LPAR LONG INTLIT INT INCREMENT IDENTIFIER FLOATLIT FLOAT DOUBLELIT DOUBLE DECREMENT CHARLIT CHAR BYTE BOOLEANLIT BOOLEAN BNOT ]
-- On VOID reduce production assignmentOperator -> OREQUAL 
-- On THIS reduce production assignmentOperator -> OREQUAL 
-- On SUPER reduce production assignmentOperator -> OREQUAL 
-- On STRLIT reduce production assignmentOperator -> OREQUAL 
-- On SHORT reduce production assignmentOperator -> OREQUAL 
-- On PLUS reduce production assignmentOperator -> OREQUAL 
-- On NULLLIT reduce production assignmentOperator -> OREQUAL 
-- On NOT reduce production assignmentOperator -> OREQUAL 
-- On NEW reduce production assignmentOperator -> OREQUAL 
-- On MINUS reduce production assignmentOperator -> OREQUAL 
-- On LPAR reduce production assignmentOperator -> OREQUAL 
-- On LONG reduce production assignmentOperator -> OREQUAL 
-- On INTLIT reduce production assignmentOperator -> OREQUAL 
-- On INT reduce production assignmentOperator -> OREQUAL 
-- On INCREMENT reduce production assignmentOperator -> OREQUAL 
-- On IDENTIFIER reduce production assignmentOperator -> OREQUAL 
-- On FLOATLIT reduce production assignmentOperator -> OREQUAL 
-- On FLOAT reduce production assignmentOperator -> OREQUAL 
-- On DOUBLELIT reduce production assignmentOperator -> OREQUAL 
-- On DOUBLE reduce production assignmentOperator -> OREQUAL 
-- On DECREMENT reduce production assignmentOperator -> OREQUAL 
-- On CHARLIT reduce production assignmentOperator -> OREQUAL 
-- On CHAR reduce production assignmentOperator -> OREQUAL 
-- On BYTE reduce production assignmentOperator -> OREQUAL 
-- On BOOLEANLIT reduce production assignmentOperator -> OREQUAL 
-- On BOOLEAN reduce production assignmentOperator -> OREQUAL 
-- On BNOT reduce production assignmentOperator -> OREQUAL 

State 49:
assignmentOperator -> MULEQUAL . [ VOID THIS SUPER STRLIT SHORT PLUS NULLLIT NOT NEW MINUS LPAR LONG INTLIT INT INCREMENT IDENTIFIER FLOATLIT FLOAT DOUBLELIT DOUBLE DECREMENT CHARLIT CHAR BYTE BOOLEANLIT BOOLEAN BNOT ]
-- On VOID reduce production assignmentOperator -> MULEQUAL 
-- On THIS reduce production assignmentOperator -> MULEQUAL 
-- On SUPER reduce production assignmentOperator -> MULEQUAL 
-- On STRLIT reduce production assignmentOperator -> MULEQUAL 
-- On SHORT reduce production assignmentOperator -> MULEQUAL 
-- On PLUS reduce production assignmentOperator -> MULEQUAL 
-- On NULLLIT reduce production assignmentOperator -> MULEQUAL 
-- On NOT reduce production assignmentOperator -> MULEQUAL 
-- On NEW reduce production assignmentOperator -> MULEQUAL 
-- On MINUS reduce production assignmentOperator -> MULEQUAL 
-- On LPAR reduce production assignmentOperator -> MULEQUAL 
-- On LONG reduce production assignmentOperator -> MULEQUAL 
-- On INTLIT reduce production assignmentOperator -> MULEQUAL 
-- On INT reduce production assignmentOperator -> MULEQUAL 
-- On INCREMENT reduce production assignmentOperator -> MULEQUAL 
-- On IDENTIFIER reduce production assignmentOperator -> MULEQUAL 
-- On FLOATLIT reduce production assignmentOperator -> MULEQUAL 
-- On FLOAT reduce production assignmentOperator -> MULEQUAL 
-- On DOUBLELIT reduce production assignmentOperator -> MULEQUAL 
-- On DOUBLE reduce production assignmentOperator -> MULEQUAL 
-- On DECREMENT reduce production assignmentOperator -> MULEQUAL 
-- On CHARLIT reduce production assignmentOperator -> MULEQUAL 
-- On CHAR reduce production assignmentOperator -> MULEQUAL 
-- On BYTE reduce production assignmentOperator -> MULEQUAL 
-- On BOOLEANLIT reduce production assignmentOperator -> MULEQUAL 
-- On BOOLEAN reduce production assignmentOperator -> MULEQUAL 
-- On BNOT reduce production assignmentOperator -> MULEQUAL 

State 50:
assignmentOperator -> MODEQUAL . [ VOID THIS SUPER STRLIT SHORT PLUS NULLLIT NOT NEW MINUS LPAR LONG INTLIT INT INCREMENT IDENTIFIER FLOATLIT FLOAT DOUBLELIT DOUBLE DECREMENT CHARLIT CHAR BYTE BOOLEANLIT BOOLEAN BNOT ]
-- On VOID reduce production assignmentOperator -> MODEQUAL 
-- On THIS reduce production assignmentOperator -> MODEQUAL 
-- On SUPER reduce production assignmentOperator -> MODEQUAL 
-- On STRLIT reduce production assignmentOperator -> MODEQUAL 
-- On SHORT reduce production assignmentOperator -> MODEQUAL 
-- On PLUS reduce production assignmentOperator -> MODEQUAL 
-- On NULLLIT reduce production assignmentOperator -> MODEQUAL 
-- On NOT reduce production assignmentOperator -> MODEQUAL 
-- On NEW reduce production assignmentOperator -> MODEQUAL 
-- On MINUS reduce production assignmentOperator -> MODEQUAL 
-- On LPAR reduce production assignmentOperator -> MODEQUAL 
-- On LONG reduce production assignmentOperator -> MODEQUAL 
-- On INTLIT reduce production assignmentOperator -> MODEQUAL 
-- On INT reduce production assignmentOperator -> MODEQUAL 
-- On INCREMENT reduce production assignmentOperator -> MODEQUAL 
-- On IDENTIFIER reduce production assignmentOperator -> MODEQUAL 
-- On FLOATLIT reduce production assignmentOperator -> MODEQUAL 
-- On FLOAT reduce production assignmentOperator -> MODEQUAL 
-- On DOUBLELIT reduce production assignmentOperator -> MODEQUAL 
-- On DOUBLE reduce production assignmentOperator -> MODEQUAL 
-- On DECREMENT reduce production assignmentOperator -> MODEQUAL 
-- On CHARLIT reduce production assignmentOperator -> MODEQUAL 
-- On CHAR reduce production assignmentOperator -> MODEQUAL 
-- On BYTE reduce production assignmentOperator -> MODEQUAL 
-- On BOOLEANLIT reduce production assignmentOperator -> MODEQUAL 
-- On BOOLEAN reduce production assignmentOperator -> MODEQUAL 
-- On BNOT reduce production assignmentOperator -> MODEQUAL 

State 51:
assignmentOperator -> MINUSEQUAL . [ VOID THIS SUPER STRLIT SHORT PLUS NULLLIT NOT NEW MINUS LPAR LONG INTLIT INT INCREMENT IDENTIFIER FLOATLIT FLOAT DOUBLELIT DOUBLE DECREMENT CHARLIT CHAR BYTE BOOLEANLIT BOOLEAN BNOT ]
-- On VOID reduce production assignmentOperator -> MINUSEQUAL 
-- On THIS reduce production assignmentOperator -> MINUSEQUAL 
-- On SUPER reduce production assignmentOperator -> MINUSEQUAL 
-- On STRLIT reduce production assignmentOperator -> MINUSEQUAL 
-- On SHORT reduce production assignmentOperator -> MINUSEQUAL 
-- On PLUS reduce production assignmentOperator -> MINUSEQUAL 
-- On NULLLIT reduce production assignmentOperator -> MINUSEQUAL 
-- On NOT reduce production assignmentOperator -> MINUSEQUAL 
-- On NEW reduce production assignmentOperator -> MINUSEQUAL 
-- On MINUS reduce production assignmentOperator -> MINUSEQUAL 
-- On LPAR reduce production assignmentOperator -> MINUSEQUAL 
-- On LONG reduce production assignmentOperator -> MINUSEQUAL 
-- On INTLIT reduce production assignmentOperator -> MINUSEQUAL 
-- On INT reduce production assignmentOperator -> MINUSEQUAL 
-- On INCREMENT reduce production assignmentOperator -> MINUSEQUAL 
-- On IDENTIFIER reduce production assignmentOperator -> MINUSEQUAL 
-- On FLOATLIT reduce production assignmentOperator -> MINUSEQUAL 
-- On FLOAT reduce production assignmentOperator -> MINUSEQUAL 
-- On DOUBLELIT reduce production assignmentOperator -> MINUSEQUAL 
-- On DOUBLE reduce production assignmentOperator -> MINUSEQUAL 
-- On DECREMENT reduce production assignmentOperator -> MINUSEQUAL 
-- On CHARLIT reduce production assignmentOperator -> MINUSEQUAL 
-- On CHAR reduce production assignmentOperator -> MINUSEQUAL 
-- On BYTE reduce production assignmentOperator -> MINUSEQUAL 
-- On BOOLEANLIT reduce production assignmentOperator -> MINUSEQUAL 
-- On BOOLEAN reduce production assignmentOperator -> MINUSEQUAL 
-- On BNOT reduce production assignmentOperator -> MINUSEQUAL 

State 52:
assignmentOperator -> LSHIFTEQUAL . [ VOID THIS SUPER STRLIT SHORT PLUS NULLLIT NOT NEW MINUS LPAR LONG INTLIT INT INCREMENT IDENTIFIER FLOATLIT FLOAT DOUBLELIT DOUBLE DECREMENT CHARLIT CHAR BYTE BOOLEANLIT BOOLEAN BNOT ]
-- On VOID reduce production assignmentOperator -> LSHIFTEQUAL 
-- On THIS reduce production assignmentOperator -> LSHIFTEQUAL 
-- On SUPER reduce production assignmentOperator -> LSHIFTEQUAL 
-- On STRLIT reduce production assignmentOperator -> LSHIFTEQUAL 
-- On SHORT reduce production assignmentOperator -> LSHIFTEQUAL 
-- On PLUS reduce production assignmentOperator -> LSHIFTEQUAL 
-- On NULLLIT reduce production assignmentOperator -> LSHIFTEQUAL 
-- On NOT reduce production assignmentOperator -> LSHIFTEQUAL 
-- On NEW reduce production assignmentOperator -> LSHIFTEQUAL 
-- On MINUS reduce production assignmentOperator -> LSHIFTEQUAL 
-- On LPAR reduce production assignmentOperator -> LSHIFTEQUAL 
-- On LONG reduce production assignmentOperator -> LSHIFTEQUAL 
-- On INTLIT reduce production assignmentOperator -> LSHIFTEQUAL 
-- On INT reduce production assignmentOperator -> LSHIFTEQUAL 
-- On INCREMENT reduce production assignmentOperator -> LSHIFTEQUAL 
-- On IDENTIFIER reduce production assignmentOperator -> LSHIFTEQUAL 
-- On FLOATLIT reduce production assignmentOperator -> LSHIFTEQUAL 
-- On FLOAT reduce production assignmentOperator -> LSHIFTEQUAL 
-- On DOUBLELIT reduce production assignmentOperator -> LSHIFTEQUAL 
-- On DOUBLE reduce production assignmentOperator -> LSHIFTEQUAL 
-- On DECREMENT reduce production assignmentOperator -> LSHIFTEQUAL 
-- On CHARLIT reduce production assignmentOperator -> LSHIFTEQUAL 
-- On CHAR reduce production assignmentOperator -> LSHIFTEQUAL 
-- On BYTE reduce production assignmentOperator -> LSHIFTEQUAL 
-- On BOOLEANLIT reduce production assignmentOperator -> LSHIFTEQUAL 
-- On BOOLEAN reduce production assignmentOperator -> LSHIFTEQUAL 
-- On BNOT reduce production assignmentOperator -> LSHIFTEQUAL 

State 53:
assignmentOperator -> LOGSHIFTEQUAL . [ VOID THIS SUPER STRLIT SHORT PLUS NULLLIT NOT NEW MINUS LPAR LONG INTLIT INT INCREMENT IDENTIFIER FLOATLIT FLOAT DOUBLELIT DOUBLE DECREMENT CHARLIT CHAR BYTE BOOLEANLIT BOOLEAN BNOT ]
-- On VOID reduce production assignmentOperator -> LOGSHIFTEQUAL 
-- On THIS reduce production assignmentOperator -> LOGSHIFTEQUAL 
-- On SUPER reduce production assignmentOperator -> LOGSHIFTEQUAL 
-- On STRLIT reduce production assignmentOperator -> LOGSHIFTEQUAL 
-- On SHORT reduce production assignmentOperator -> LOGSHIFTEQUAL 
-- On PLUS reduce production assignmentOperator -> LOGSHIFTEQUAL 
-- On NULLLIT reduce production assignmentOperator -> LOGSHIFTEQUAL 
-- On NOT reduce production assignmentOperator -> LOGSHIFTEQUAL 
-- On NEW reduce production assignmentOperator -> LOGSHIFTEQUAL 
-- On MINUS reduce production assignmentOperator -> LOGSHIFTEQUAL 
-- On LPAR reduce production assignmentOperator -> LOGSHIFTEQUAL 
-- On LONG reduce production assignmentOperator -> LOGSHIFTEQUAL 
-- On INTLIT reduce production assignmentOperator -> LOGSHIFTEQUAL 
-- On INT reduce production assignmentOperator -> LOGSHIFTEQUAL 
-- On INCREMENT reduce production assignmentOperator -> LOGSHIFTEQUAL 
-- On IDENTIFIER reduce production assignmentOperator -> LOGSHIFTEQUAL 
-- On FLOATLIT reduce production assignmentOperator -> LOGSHIFTEQUAL 
-- On FLOAT reduce production assignmentOperator -> LOGSHIFTEQUAL 
-- On DOUBLELIT reduce production assignmentOperator -> LOGSHIFTEQUAL 
-- On DOUBLE reduce production assignmentOperator -> LOGSHIFTEQUAL 
-- On DECREMENT reduce production assignmentOperator -> LOGSHIFTEQUAL 
-- On CHARLIT reduce production assignmentOperator -> LOGSHIFTEQUAL 
-- On CHAR reduce production assignmentOperator -> LOGSHIFTEQUAL 
-- On BYTE reduce production assignmentOperator -> LOGSHIFTEQUAL 
-- On BOOLEANLIT reduce production assignmentOperator -> LOGSHIFTEQUAL 
-- On BOOLEAN reduce production assignmentOperator -> LOGSHIFTEQUAL 
-- On BNOT reduce production assignmentOperator -> LOGSHIFTEQUAL 

State 54:
assignmentOperator -> DIVEQUAL . [ VOID THIS SUPER STRLIT SHORT PLUS NULLLIT NOT NEW MINUS LPAR LONG INTLIT INT INCREMENT IDENTIFIER FLOATLIT FLOAT DOUBLELIT DOUBLE DECREMENT CHARLIT CHAR BYTE BOOLEANLIT BOOLEAN BNOT ]
-- On VOID reduce production assignmentOperator -> DIVEQUAL 
-- On THIS reduce production assignmentOperator -> DIVEQUAL 
-- On SUPER reduce production assignmentOperator -> DIVEQUAL 
-- On STRLIT reduce production assignmentOperator -> DIVEQUAL 
-- On SHORT reduce production assignmentOperator -> DIVEQUAL 
-- On PLUS reduce production assignmentOperator -> DIVEQUAL 
-- On NULLLIT reduce production assignmentOperator -> DIVEQUAL 
-- On NOT reduce production assignmentOperator -> DIVEQUAL 
-- On NEW reduce production assignmentOperator -> DIVEQUAL 
-- On MINUS reduce production assignmentOperator -> DIVEQUAL 
-- On LPAR reduce production assignmentOperator -> DIVEQUAL 
-- On LONG reduce production assignmentOperator -> DIVEQUAL 
-- On INTLIT reduce production assignmentOperator -> DIVEQUAL 
-- On INT reduce production assignmentOperator -> DIVEQUAL 
-- On INCREMENT reduce production assignmentOperator -> DIVEQUAL 
-- On IDENTIFIER reduce production assignmentOperator -> DIVEQUAL 
-- On FLOATLIT reduce production assignmentOperator -> DIVEQUAL 
-- On FLOAT reduce production assignmentOperator -> DIVEQUAL 
-- On DOUBLELIT reduce production assignmentOperator -> DIVEQUAL 
-- On DOUBLE reduce production assignmentOperator -> DIVEQUAL 
-- On DECREMENT reduce production assignmentOperator -> DIVEQUAL 
-- On CHARLIT reduce production assignmentOperator -> DIVEQUAL 
-- On CHAR reduce production assignmentOperator -> DIVEQUAL 
-- On BYTE reduce production assignmentOperator -> DIVEQUAL 
-- On BOOLEANLIT reduce production assignmentOperator -> DIVEQUAL 
-- On BOOLEAN reduce production assignmentOperator -> DIVEQUAL 
-- On BNOT reduce production assignmentOperator -> DIVEQUAL 

State 55:
assignmentOperator -> ASSIGN . [ VOID THIS SUPER STRLIT SHORT PLUS NULLLIT NOT NEW MINUS LPAR LONG INTLIT INT INCREMENT IDENTIFIER FLOATLIT FLOAT DOUBLELIT DOUBLE DECREMENT CHARLIT CHAR BYTE BOOLEANLIT BOOLEAN BNOT ]
-- On VOID reduce production assignmentOperator -> ASSIGN 
-- On THIS reduce production assignmentOperator -> ASSIGN 
-- On SUPER reduce production assignmentOperator -> ASSIGN 
-- On STRLIT reduce production assignmentOperator -> ASSIGN 
-- On SHORT reduce production assignmentOperator -> ASSIGN 
-- On PLUS reduce production assignmentOperator -> ASSIGN 
-- On NULLLIT reduce production assignmentOperator -> ASSIGN 
-- On NOT reduce production assignmentOperator -> ASSIGN 
-- On NEW reduce production assignmentOperator -> ASSIGN 
-- On MINUS reduce production assignmentOperator -> ASSIGN 
-- On LPAR reduce production assignmentOperator -> ASSIGN 
-- On LONG reduce production assignmentOperator -> ASSIGN 
-- On INTLIT reduce production assignmentOperator -> ASSIGN 
-- On INT reduce production assignmentOperator -> ASSIGN 
-- On INCREMENT reduce production assignmentOperator -> ASSIGN 
-- On IDENTIFIER reduce production assignmentOperator -> ASSIGN 
-- On FLOATLIT reduce production assignmentOperator -> ASSIGN 
-- On FLOAT reduce production assignmentOperator -> ASSIGN 
-- On DOUBLELIT reduce production assignmentOperator -> ASSIGN 
-- On DOUBLE reduce production assignmentOperator -> ASSIGN 
-- On DECREMENT reduce production assignmentOperator -> ASSIGN 
-- On CHARLIT reduce production assignmentOperator -> ASSIGN 
-- On CHAR reduce production assignmentOperator -> ASSIGN 
-- On BYTE reduce production assignmentOperator -> ASSIGN 
-- On BOOLEANLIT reduce production assignmentOperator -> ASSIGN 
-- On BOOLEAN reduce production assignmentOperator -> ASSIGN 
-- On BNOT reduce production assignmentOperator -> ASSIGN 

State 56:
assignmentOperator -> ANDEQUAL . [ VOID THIS SUPER STRLIT SHORT PLUS NULLLIT NOT NEW MINUS LPAR LONG INTLIT INT INCREMENT IDENTIFIER FLOATLIT FLOAT DOUBLELIT DOUBLE DECREMENT CHARLIT CHAR BYTE BOOLEANLIT BOOLEAN BNOT ]
-- On VOID reduce production assignmentOperator -> ANDEQUAL 
-- On THIS reduce production assignmentOperator -> ANDEQUAL 
-- On SUPER reduce production assignmentOperator -> ANDEQUAL 
-- On STRLIT reduce production assignmentOperator -> ANDEQUAL 
-- On SHORT reduce production assignmentOperator -> ANDEQUAL 
-- On PLUS reduce production assignmentOperator -> ANDEQUAL 
-- On NULLLIT reduce production assignmentOperator -> ANDEQUAL 
-- On NOT reduce production assignmentOperator -> ANDEQUAL 
-- On NEW reduce production assignmentOperator -> ANDEQUAL 
-- On MINUS reduce production assignmentOperator -> ANDEQUAL 
-- On LPAR reduce production assignmentOperator -> ANDEQUAL 
-- On LONG reduce production assignmentOperator -> ANDEQUAL 
-- On INTLIT reduce production assignmentOperator -> ANDEQUAL 
-- On INT reduce production assignmentOperator -> ANDEQUAL 
-- On INCREMENT reduce production assignmentOperator -> ANDEQUAL 
-- On IDENTIFIER reduce production assignmentOperator -> ANDEQUAL 
-- On FLOATLIT reduce production assignmentOperator -> ANDEQUAL 
-- On FLOAT reduce production assignmentOperator -> ANDEQUAL 
-- On DOUBLELIT reduce production assignmentOperator -> ANDEQUAL 
-- On DOUBLE reduce production assignmentOperator -> ANDEQUAL 
-- On DECREMENT reduce production assignmentOperator -> ANDEQUAL 
-- On CHARLIT reduce production assignmentOperator -> ANDEQUAL 
-- On CHAR reduce production assignmentOperator -> ANDEQUAL 
-- On BYTE reduce production assignmentOperator -> ANDEQUAL 
-- On BOOLEANLIT reduce production assignmentOperator -> ANDEQUAL 
-- On BOOLEAN reduce production assignmentOperator -> ANDEQUAL 
-- On BNOT reduce production assignmentOperator -> ANDEQUAL 

State 57:
assignmentExpression -> unaryExpression assignmentOperator . assignmentExpression [ SEMI RPAR RCURL RBRAC COMM COL ]
-- On VOID shift to state 6
-- On THIS shift to state 7
-- On SUPER shift to state 8
-- On STRLIT shift to state 9
-- On SHORT shift to state 10
-- On PLUS shift to state 11
-- On NULLLIT shift to state 12
-- On NOT shift to state 13
-- On NEW shift to state 14
-- On MINUS shift to state 26
-- On LPAR shift to state 27
-- On LONG shift to state 15
-- On INTLIT shift to state 28
-- On INT shift to state 16
-- On INCREMENT shift to state 29
-- On IDENTIFIER shift to state 17
-- On FLOATLIT shift to state 31
-- On FLOAT shift to state 18
-- On DOUBLELIT shift to state 32
-- On DOUBLE shift to state 19
-- On DECREMENT shift to state 33
-- On CHARLIT shift to state 34
-- On CHAR shift to state 20
-- On BYTE shift to state 21
-- On BOOLEANLIT shift to state 35
-- On BOOLEAN shift to state 22
-- On BNOT shift to state 36
-- On unaryExpression shift to state 44
-- On specialName shift to state 38
-- On shiftExpression shift to state 58
-- On relationalExpression shift to state 79
-- On realPostfixExpression shift to state 39
-- On qualifiedName shift to state 42
-- On primitiveType shift to state 61
-- On primaryExpression shift to state 64
-- On postfixExpression shift to state 65
-- On plainNewAllocationExpression shift to state 68
-- On notJustName shift to state 69
-- On newAllocationExpression shift to state 72
-- On multiplicativeExpression shift to state 73
-- On methodCall shift to state 75
-- On methodAccess shift to state 76
-- On logicalUnaryOperator shift to state 83
-- On logicalUnaryExpression shift to state 85
-- On inclusiveOrExpression shift to state 90
-- On fieldAccess shift to state 86
-- On exclusiveOrExpression shift to state 111
-- On equalityExpression shift to state 94
-- On conditionalOrExpression shift to state 112
-- On conditionalExpression shift to state 151
-- On conditionalAndExpression shift to state 117
-- On complexPrimaryNoParenthesis shift to state 87
-- On complexPrimary shift to state 88
-- On classAllocationExpression shift to state 100
-- On castExpression shift to state 103
-- On assignmentExpression shift to state 173
-- On arrayAllocationExpression shift to state 104
-- On arrayAccess shift to state 120
-- On arithmeticUnaryOperator shift to state 121
-- On andExpression shift to state 123
-- On additiveExpression shift to state 140

State 58:
relationalExpression -> shiftExpression . [ XOR SEMI RPAR RCURL RBRAC QM OR NEQUAL LTHAN LETHAN INSTANCEOF GTHAN GETHAN EQUAL COMM COL BOR BAND AND ]
shiftExpression -> shiftExpression . LSHIFT additiveExpression [ XOR SEMI RSHIFT RPAR RCURL RBRAC QM OR NEQUAL LTHAN LSHIFT LOGSHIFT LETHAN INSTANCEOF GTHAN GETHAN EQUAL COMM COL BOR BAND AND ]
shiftExpression -> shiftExpression . RSHIFT additiveExpression [ XOR SEMI RSHIFT RPAR RCURL RBRAC QM OR NEQUAL LTHAN LSHIFT LOGSHIFT LETHAN INSTANCEOF GTHAN GETHAN EQUAL COMM COL BOR BAND AND ]
shiftExpression -> shiftExpression . LOGSHIFT additiveExpression [ XOR SEMI RSHIFT RPAR RCURL RBRAC QM OR NEQUAL LTHAN LSHIFT LOGSHIFT LETHAN INSTANCEOF GTHAN GETHAN EQUAL COMM COL BOR BAND AND ]
-- On RSHIFT shift to state 59
-- On LSHIFT shift to state 82
-- On LOGSHIFT shift to state 99
-- On XOR reduce production relationalExpression -> shiftExpression 
-- On SEMI reduce production relationalExpression -> shiftExpression 
-- On RPAR reduce production relationalExpression -> shiftExpression 
-- On RCURL reduce production relationalExpression -> shiftExpression 
-- On RBRAC reduce production relationalExpression -> shiftExpression 
-- On QM reduce production relationalExpression -> shiftExpression 
-- On OR reduce production relationalExpression -> shiftExpression 
-- On NEQUAL reduce production relationalExpression -> shiftExpression 
-- On LTHAN reduce production relationalExpression -> shiftExpression 
-- On LETHAN reduce production relationalExpression -> shiftExpression 
-- On INSTANCEOF reduce production relationalExpression -> shiftExpression 
-- On GTHAN reduce production relationalExpression -> shiftExpression 
-- On GETHAN reduce production relationalExpression -> shiftExpression 
-- On EQUAL reduce production relationalExpression -> shiftExpression 
-- On COMM reduce production relationalExpression -> shiftExpression 
-- On COL reduce production relationalExpression -> shiftExpression 
-- On BOR reduce production relationalExpression -> shiftExpression 
-- On BAND reduce production relationalExpression -> shiftExpression 
-- On AND reduce production relationalExpression -> shiftExpression 

State 59:
shiftExpression -> shiftExpression RSHIFT . additiveExpression [ XOR SEMI RSHIFT RPAR RCURL RBRAC QM OR NEQUAL LTHAN LSHIFT LOGSHIFT LETHAN INSTANCEOF GTHAN GETHAN EQUAL COMM COL BOR BAND AND ]
-- On VOID shift to state 6
-- On THIS shift to state 7
-- On SUPER shift to state 8
-- On STRLIT shift to state 9
-- On SHORT shift to state 10
-- On PLUS shift to state 11
-- On NULLLIT shift to state 12
-- On NOT shift to state 13
-- On NEW shift to state 14
-- On MINUS shift to state 26
-- On LPAR shift to state 27
-- On LONG shift to state 15
-- On INTLIT shift to state 28
-- On INT shift to state 16
-- On INCREMENT shift to state 29
-- On IDENTIFIER shift to state 17
-- On FLOATLIT shift to state 31
-- On FLOAT shift to state 18
-- On DOUBLELIT shift to state 32
-- On DOUBLE shift to state 19
-- On DECREMENT shift to state 33
-- On CHARLIT shift to state 34
-- On CHAR shift to state 20
-- On BYTE shift to state 21
-- On BOOLEANLIT shift to state 35
-- On BOOLEAN shift to state 22
-- On BNOT shift to state 36
-- On unaryExpression shift to state 60
-- On specialName shift to state 38
-- On realPostfixExpression shift to state 39
-- On qualifiedName shift to state 42
-- On primitiveType shift to state 61
-- On primaryExpression shift to state 64
-- On postfixExpression shift to state 65
-- On plainNewAllocationExpression shift to state 68
-- On notJustName shift to state 69
-- On newAllocationExpression shift to state 72
-- On multiplicativeExpression shift to state 73
-- On methodCall shift to state 75
-- On methodAccess shift to state 76
-- On logicalUnaryOperator shift to state 83
-- On logicalUnaryExpression shift to state 85
-- On fieldAccess shift to state 86
-- On complexPrimaryNoParenthesis shift to state 87
-- On complexPrimary shift to state 88
-- On classAllocationExpression shift to state 100
-- On castExpression shift to state 103
-- On arrayAllocationExpression shift to state 104
-- On arrayAccess shift to state 120
-- On arithmeticUnaryOperator shift to state 121
-- On additiveExpression shift to state 172

State 60:
castExpression -> unaryExpression . [ XOREQUAL XOR SEMI RSHIFTEQUAL RSHIFT RPAR RCURL RBRAC QM PLUS PEQUAL OREQUAL OR NEQUAL MULEQUAL MUL MODEQUAL MOD MINUSEQUAL MINUS LTHAN LSHIFTEQUAL LSHIFT LOGSHIFTEQUAL LOGSHIFT LETHAN INSTANCEOF GTHAN GETHAN EQUAL DIVEQUAL DIV COMM COL BOR BAND ASSIGN ANDEQUAL AND ]
-- On XOREQUAL reduce production castExpression -> unaryExpression 
-- On XOR reduce production castExpression -> unaryExpression 
-- On SEMI reduce production castExpression -> unaryExpression 
-- On RSHIFTEQUAL reduce production castExpression -> unaryExpression 
-- On RSHIFT reduce production castExpression -> unaryExpression 
-- On RPAR reduce production castExpression -> unaryExpression 
-- On RCURL reduce production castExpression -> unaryExpression 
-- On RBRAC reduce production castExpression -> unaryExpression 
-- On QM reduce production castExpression -> unaryExpression 
-- On PLUS reduce production castExpression -> unaryExpression 
-- On PEQUAL reduce production castExpression -> unaryExpression 
-- On OREQUAL reduce production castExpression -> unaryExpression 
-- On OR reduce production castExpression -> unaryExpression 
-- On NEQUAL reduce production castExpression -> unaryExpression 
-- On MULEQUAL reduce production castExpression -> unaryExpression 
-- On MUL reduce production castExpression -> unaryExpression 
-- On MODEQUAL reduce production castExpression -> unaryExpression 
-- On MOD reduce production castExpression -> unaryExpression 
-- On MINUSEQUAL reduce production castExpression -> unaryExpression 
-- On MINUS reduce production castExpression -> unaryExpression 
-- On LTHAN reduce production castExpression -> unaryExpression 
-- On LSHIFTEQUAL reduce production castExpression -> unaryExpression 
-- On LSHIFT reduce production castExpression -> unaryExpression 
-- On LOGSHIFTEQUAL reduce production castExpression -> unaryExpression 
-- On LOGSHIFT reduce production castExpression -> unaryExpression 
-- On LETHAN reduce production castExpression -> unaryExpression 
-- On INSTANCEOF reduce production castExpression -> unaryExpression 
-- On GTHAN reduce production castExpression -> unaryExpression 
-- On GETHAN reduce production castExpression -> unaryExpression 
-- On EQUAL reduce production castExpression -> unaryExpression 
-- On DIVEQUAL reduce production castExpression -> unaryExpression 
-- On DIV reduce production castExpression -> unaryExpression 
-- On COMM reduce production castExpression -> unaryExpression 
-- On COL reduce production castExpression -> unaryExpression 
-- On BOR reduce production castExpression -> unaryExpression 
-- On BAND reduce production castExpression -> unaryExpression 
-- On ASSIGN reduce production castExpression -> unaryExpression 
-- On ANDEQUAL reduce production castExpression -> unaryExpression 
-- On AND reduce production castExpression -> unaryExpression 

State 61:
fieldAccess -> primitiveType . DOT CLASS [ XOREQUAL XOR SEMI RSHIFTEQUAL RSHIFT RPAR RCURL RBRAC QM PLUS PEQUAL OREQUAL OR NEQUAL MULEQUAL MUL MODEQUAL MOD MINUSEQUAL MINUS LTHAN LSHIFTEQUAL LSHIFT LPAR LOGSHIFTEQUAL LOGSHIFT LETHAN LBRAC INSTANCEOF INCREMENT GTHAN GETHAN EQUAL DOT DIVEQUAL DIV DECREMENT COMM COL BOR BAND ASSIGN ANDEQUAL AND ]
-- On DOT shift to state 62

State 62:
fieldAccess -> primitiveType DOT . CLASS [ XOREQUAL XOR SEMI RSHIFTEQUAL RSHIFT RPAR RCURL RBRAC QM PLUS PEQUAL OREQUAL OR NEQUAL MULEQUAL MUL MODEQUAL MOD MINUSEQUAL MINUS LTHAN LSHIFTEQUAL LSHIFT LPAR LOGSHIFTEQUAL LOGSHIFT LETHAN LBRAC INSTANCEOF INCREMENT GTHAN GETHAN EQUAL DOT DIVEQUAL DIV DECREMENT COMM COL BOR BAND ASSIGN ANDEQUAL AND ]
-- On CLASS shift to state 63

State 63:
fieldAccess -> primitiveType DOT CLASS . [ XOREQUAL XOR SEMI RSHIFTEQUAL RSHIFT RPAR RCURL RBRAC QM PLUS PEQUAL OREQUAL OR NEQUAL MULEQUAL MUL MODEQUAL MOD MINUSEQUAL MINUS LTHAN LSHIFTEQUAL LSHIFT LPAR LOGSHIFTEQUAL LOGSHIFT LETHAN LBRAC INSTANCEOF INCREMENT GTHAN GETHAN EQUAL DOT DIVEQUAL DIV DECREMENT COMM COL BOR BAND ASSIGN ANDEQUAL AND ]
-- On XOREQUAL reduce production fieldAccess -> primitiveType DOT CLASS 
-- On XOR reduce production fieldAccess -> primitiveType DOT CLASS 
-- On SEMI reduce production fieldAccess -> primitiveType DOT CLASS 
-- On RSHIFTEQUAL reduce production fieldAccess -> primitiveType DOT CLASS 
-- On RSHIFT reduce production fieldAccess -> primitiveType DOT CLASS 
-- On RPAR reduce production fieldAccess -> primitiveType DOT CLASS 
-- On RCURL reduce production fieldAccess -> primitiveType DOT CLASS 
-- On RBRAC reduce production fieldAccess -> primitiveType DOT CLASS 
-- On QM reduce production fieldAccess -> primitiveType DOT CLASS 
-- On PLUS reduce production fieldAccess -> primitiveType DOT CLASS 
-- On PEQUAL reduce production fieldAccess -> primitiveType DOT CLASS 
-- On OREQUAL reduce production fieldAccess -> primitiveType DOT CLASS 
-- On OR reduce production fieldAccess -> primitiveType DOT CLASS 
-- On NEQUAL reduce production fieldAccess -> primitiveType DOT CLASS 
-- On MULEQUAL reduce production fieldAccess -> primitiveType DOT CLASS 
-- On MUL reduce production fieldAccess -> primitiveType DOT CLASS 
-- On MODEQUAL reduce production fieldAccess -> primitiveType DOT CLASS 
-- On MOD reduce production fieldAccess -> primitiveType DOT CLASS 
-- On MINUSEQUAL reduce production fieldAccess -> primitiveType DOT CLASS 
-- On MINUS reduce production fieldAccess -> primitiveType DOT CLASS 
-- On LTHAN reduce production fieldAccess -> primitiveType DOT CLASS 
-- On LSHIFTEQUAL reduce production fieldAccess -> primitiveType DOT CLASS 
-- On LSHIFT reduce production fieldAccess -> primitiveType DOT CLASS 
-- On LPAR reduce production fieldAccess -> primitiveType DOT CLASS 
-- On LOGSHIFTEQUAL reduce production fieldAccess -> primitiveType DOT CLASS 
-- On LOGSHIFT reduce production fieldAccess -> primitiveType DOT CLASS 
-- On LETHAN reduce production fieldAccess -> primitiveType DOT CLASS 
-- On LBRAC reduce production fieldAccess -> primitiveType DOT CLASS 
-- On INSTANCEOF reduce production fieldAccess -> primitiveType DOT CLASS 
-- On INCREMENT reduce production fieldAccess -> primitiveType DOT CLASS 
-- On GTHAN reduce production fieldAccess -> primitiveType DOT CLASS 
-- On GETHAN reduce production fieldAccess -> primitiveType DOT CLASS 
-- On EQUAL reduce production fieldAccess -> primitiveType DOT CLASS 
-- On DOT reduce production fieldAccess -> primitiveType DOT CLASS 
-- On DIVEQUAL reduce production fieldAccess -> primitiveType DOT CLASS 
-- On DIV reduce production fieldAccess -> primitiveType DOT CLASS 
-- On DECREMENT reduce production fieldAccess -> primitiveType DOT CLASS 
-- On COMM reduce production fieldAccess -> primitiveType DOT CLASS 
-- On COL reduce production fieldAccess -> primitiveType DOT CLASS 
-- On BOR reduce production fieldAccess -> primitiveType DOT CLASS 
-- On BAND reduce production fieldAccess -> primitiveType DOT CLASS 
-- On ASSIGN reduce production fieldAccess -> primitiveType DOT CLASS 
-- On ANDEQUAL reduce production fieldAccess -> primitiveType DOT CLASS 
-- On AND reduce production fieldAccess -> primitiveType DOT CLASS 

State 64:
postfixExpression -> primaryExpression . [ XOREQUAL XOR SEMI RSHIFTEQUAL RSHIFT RPAR RCURL RBRAC QM PLUS PEQUAL OREQUAL OR NEQUAL MULEQUAL MUL MODEQUAL MOD MINUSEQUAL MINUS LTHAN LSHIFTEQUAL LSHIFT LOGSHIFTEQUAL LOGSHIFT LETHAN INSTANCEOF INCREMENT GTHAN GETHAN EQUAL DIVEQUAL DIV DECREMENT COMM COL BOR BAND ASSIGN ANDEQUAL AND ]
-- On XOREQUAL reduce production postfixExpression -> primaryExpression 
-- On XOR reduce production postfixExpression -> primaryExpression 
-- On SEMI reduce production postfixExpression -> primaryExpression 
-- On RSHIFTEQUAL reduce production postfixExpression -> primaryExpression 
-- On RSHIFT reduce production postfixExpression -> primaryExpression 
-- On RPAR reduce production postfixExpression -> primaryExpression 
-- On RCURL reduce production postfixExpression -> primaryExpression 
-- On RBRAC reduce production postfixExpression -> primaryExpression 
-- On QM reduce production postfixExpression -> primaryExpression 
-- On PLUS reduce production postfixExpression -> primaryExpression 
-- On PEQUAL reduce production postfixExpression -> primaryExpression 
-- On OREQUAL reduce production postfixExpression -> primaryExpression 
-- On OR reduce production postfixExpression -> primaryExpression 
-- On NEQUAL reduce production postfixExpression -> primaryExpression 
-- On MULEQUAL reduce production postfixExpression -> primaryExpression 
-- On MUL reduce production postfixExpression -> primaryExpression 
-- On MODEQUAL reduce production postfixExpression -> primaryExpression 
-- On MOD reduce production postfixExpression -> primaryExpression 
-- On MINUSEQUAL reduce production postfixExpression -> primaryExpression 
-- On MINUS reduce production postfixExpression -> primaryExpression 
-- On LTHAN reduce production postfixExpression -> primaryExpression 
-- On LSHIFTEQUAL reduce production postfixExpression -> primaryExpression 
-- On LSHIFT reduce production postfixExpression -> primaryExpression 
-- On LOGSHIFTEQUAL reduce production postfixExpression -> primaryExpression 
-- On LOGSHIFT reduce production postfixExpression -> primaryExpression 
-- On LETHAN reduce production postfixExpression -> primaryExpression 
-- On INSTANCEOF reduce production postfixExpression -> primaryExpression 
-- On INCREMENT reduce production postfixExpression -> primaryExpression 
-- On GTHAN reduce production postfixExpression -> primaryExpression 
-- On GETHAN reduce production postfixExpression -> primaryExpression 
-- On EQUAL reduce production postfixExpression -> primaryExpression 
-- On DIVEQUAL reduce production postfixExpression -> primaryExpression 
-- On DIV reduce production postfixExpression -> primaryExpression 
-- On DECREMENT reduce production postfixExpression -> primaryExpression 
-- On COMM reduce production postfixExpression -> primaryExpression 
-- On COL reduce production postfixExpression -> primaryExpression 
-- On BOR reduce production postfixExpression -> primaryExpression 
-- On BAND reduce production postfixExpression -> primaryExpression 
-- On ASSIGN reduce production postfixExpression -> primaryExpression 
-- On ANDEQUAL reduce production postfixExpression -> primaryExpression 
-- On AND reduce production postfixExpression -> primaryExpression 

State 65:
logicalUnaryExpression -> postfixExpression . [ XOREQUAL XOR SEMI RSHIFTEQUAL RSHIFT RPAR RCURL RBRAC QM PLUS PEQUAL OREQUAL OR NEQUAL MULEQUAL MUL MODEQUAL MOD MINUSEQUAL MINUS LTHAN LSHIFTEQUAL LSHIFT LOGSHIFTEQUAL LOGSHIFT LETHAN INSTANCEOF GTHAN GETHAN EQUAL DIVEQUAL DIV COMM COL BOR BAND ASSIGN ANDEQUAL AND ]
realPostfixExpression -> postfixExpression . INCREMENT [ XOREQUAL XOR SEMI RSHIFTEQUAL RSHIFT RPAR RCURL RBRAC QM PLUS PEQUAL OREQUAL OR NEQUAL MULEQUAL MUL MODEQUAL MOD MINUSEQUAL MINUS LTHAN LSHIFTEQUAL LSHIFT LOGSHIFTEQUAL LOGSHIFT LETHAN INSTANCEOF INCREMENT GTHAN GETHAN EQUAL DOT DIVEQUAL DIV DECREMENT COMM COL BOR BAND ASSIGN ANDEQUAL AND ]
realPostfixExpression -> postfixExpression . DECREMENT [ XOREQUAL XOR SEMI RSHIFTEQUAL RSHIFT RPAR RCURL RBRAC QM PLUS PEQUAL OREQUAL OR NEQUAL MULEQUAL MUL MODEQUAL MOD MINUSEQUAL MINUS LTHAN LSHIFTEQUAL LSHIFT LOGSHIFTEQUAL LOGSHIFT LETHAN INSTANCEOF INCREMENT GTHAN GETHAN EQUAL DOT DIVEQUAL DIV DECREMENT COMM COL BOR BAND ASSIGN ANDEQUAL AND ]
-- On INCREMENT shift to state 66
-- On DECREMENT shift to state 67
-- On XOREQUAL reduce production logicalUnaryExpression -> postfixExpression 
-- On XOR reduce production logicalUnaryExpression -> postfixExpression 
-- On SEMI reduce production logicalUnaryExpression -> postfixExpression 
-- On RSHIFTEQUAL reduce production logicalUnaryExpression -> postfixExpression 
-- On RSHIFT reduce production logicalUnaryExpression -> postfixExpression 
-- On RPAR reduce production logicalUnaryExpression -> postfixExpression 
-- On RCURL reduce production logicalUnaryExpression -> postfixExpression 
-- On RBRAC reduce production logicalUnaryExpression -> postfixExpression 
-- On QM reduce production logicalUnaryExpression -> postfixExpression 
-- On PLUS reduce production logicalUnaryExpression -> postfixExpression 
-- On PEQUAL reduce production logicalUnaryExpression -> postfixExpression 
-- On OREQUAL reduce production logicalUnaryExpression -> postfixExpression 
-- On OR reduce production logicalUnaryExpression -> postfixExpression 
-- On NEQUAL reduce production logicalUnaryExpression -> postfixExpression 
-- On MULEQUAL reduce production logicalUnaryExpression -> postfixExpression 
-- On MUL reduce production logicalUnaryExpression -> postfixExpression 
-- On MODEQUAL reduce production logicalUnaryExpression -> postfixExpression 
-- On MOD reduce production logicalUnaryExpression -> postfixExpression 
-- On MINUSEQUAL reduce production logicalUnaryExpression -> postfixExpression 
-- On MINUS reduce production logicalUnaryExpression -> postfixExpression 
-- On LTHAN reduce production logicalUnaryExpression -> postfixExpression 
-- On LSHIFTEQUAL reduce production logicalUnaryExpression -> postfixExpression 
-- On LSHIFT reduce production logicalUnaryExpression -> postfixExpression 
-- On LOGSHIFTEQUAL reduce production logicalUnaryExpression -> postfixExpression 
-- On LOGSHIFT reduce production logicalUnaryExpression -> postfixExpression 
-- On LETHAN reduce production logicalUnaryExpression -> postfixExpression 
-- On INSTANCEOF reduce production logicalUnaryExpression -> postfixExpression 
-- On GTHAN reduce production logicalUnaryExpression -> postfixExpression 
-- On GETHAN reduce production logicalUnaryExpression -> postfixExpression 
-- On EQUAL reduce production logicalUnaryExpression -> postfixExpression 
-- On DIVEQUAL reduce production logicalUnaryExpression -> postfixExpression 
-- On DIV reduce production logicalUnaryExpression -> postfixExpression 
-- On COMM reduce production logicalUnaryExpression -> postfixExpression 
-- On COL reduce production logicalUnaryExpression -> postfixExpression 
-- On BOR reduce production logicalUnaryExpression -> postfixExpression 
-- On BAND reduce production logicalUnaryExpression -> postfixExpression 
-- On ASSIGN reduce production logicalUnaryExpression -> postfixExpression 
-- On ANDEQUAL reduce production logicalUnaryExpression -> postfixExpression 
-- On AND reduce production logicalUnaryExpression -> postfixExpression 

State 66:
realPostfixExpression -> postfixExpression INCREMENT . [ XOREQUAL XOR SEMI RSHIFTEQUAL RSHIFT RPAR RCURL RBRAC QM PLUS PEQUAL OREQUAL OR NEQUAL MULEQUAL MUL MODEQUAL MOD MINUSEQUAL MINUS LTHAN LSHIFTEQUAL LSHIFT LOGSHIFTEQUAL LOGSHIFT LETHAN INSTANCEOF INCREMENT GTHAN GETHAN EQUAL DOT DIVEQUAL DIV DECREMENT COMM COL BOR BAND ASSIGN ANDEQUAL AND ]
-- On XOREQUAL reduce production realPostfixExpression -> postfixExpression INCREMENT 
-- On XOR reduce production realPostfixExpression -> postfixExpression INCREMENT 
-- On SEMI reduce production realPostfixExpression -> postfixExpression INCREMENT 
-- On RSHIFTEQUAL reduce production realPostfixExpression -> postfixExpression INCREMENT 
-- On RSHIFT reduce production realPostfixExpression -> postfixExpression INCREMENT 
-- On RPAR reduce production realPostfixExpression -> postfixExpression INCREMENT 
-- On RCURL reduce production realPostfixExpression -> postfixExpression INCREMENT 
-- On RBRAC reduce production realPostfixExpression -> postfixExpression INCREMENT 
-- On QM reduce production realPostfixExpression -> postfixExpression INCREMENT 
-- On PLUS reduce production realPostfixExpression -> postfixExpression INCREMENT 
-- On PEQUAL reduce production realPostfixExpression -> postfixExpression INCREMENT 
-- On OREQUAL reduce production realPostfixExpression -> postfixExpression INCREMENT 
-- On OR reduce production realPostfixExpression -> postfixExpression INCREMENT 
-- On NEQUAL reduce production realPostfixExpression -> postfixExpression INCREMENT 
-- On MULEQUAL reduce production realPostfixExpression -> postfixExpression INCREMENT 
-- On MUL reduce production realPostfixExpression -> postfixExpression INCREMENT 
-- On MODEQUAL reduce production realPostfixExpression -> postfixExpression INCREMENT 
-- On MOD reduce production realPostfixExpression -> postfixExpression INCREMENT 
-- On MINUSEQUAL reduce production realPostfixExpression -> postfixExpression INCREMENT 
-- On MINUS reduce production realPostfixExpression -> postfixExpression INCREMENT 
-- On LTHAN reduce production realPostfixExpression -> postfixExpression INCREMENT 
-- On LSHIFTEQUAL reduce production realPostfixExpression -> postfixExpression INCREMENT 
-- On LSHIFT reduce production realPostfixExpression -> postfixExpression INCREMENT 
-- On LOGSHIFTEQUAL reduce production realPostfixExpression -> postfixExpression INCREMENT 
-- On LOGSHIFT reduce production realPostfixExpression -> postfixExpression INCREMENT 
-- On LETHAN reduce production realPostfixExpression -> postfixExpression INCREMENT 
-- On INSTANCEOF reduce production realPostfixExpression -> postfixExpression INCREMENT 
-- On INCREMENT reduce production realPostfixExpression -> postfixExpression INCREMENT 
-- On GTHAN reduce production realPostfixExpression -> postfixExpression INCREMENT 
-- On GETHAN reduce production realPostfixExpression -> postfixExpression INCREMENT 
-- On EQUAL reduce production realPostfixExpression -> postfixExpression INCREMENT 
-- On DOT reduce production realPostfixExpression -> postfixExpression INCREMENT 
-- On DIVEQUAL reduce production realPostfixExpression -> postfixExpression INCREMENT 
-- On DIV reduce production realPostfixExpression -> postfixExpression INCREMENT 
-- On DECREMENT reduce production realPostfixExpression -> postfixExpression INCREMENT 
-- On COMM reduce production realPostfixExpression -> postfixExpression INCREMENT 
-- On COL reduce production realPostfixExpression -> postfixExpression INCREMENT 
-- On BOR reduce production realPostfixExpression -> postfixExpression INCREMENT 
-- On BAND reduce production realPostfixExpression -> postfixExpression INCREMENT 
-- On ASSIGN reduce production realPostfixExpression -> postfixExpression INCREMENT 
-- On ANDEQUAL reduce production realPostfixExpression -> postfixExpression INCREMENT 
-- On AND reduce production realPostfixExpression -> postfixExpression INCREMENT 

State 67:
realPostfixExpression -> postfixExpression DECREMENT . [ XOREQUAL XOR SEMI RSHIFTEQUAL RSHIFT RPAR RCURL RBRAC QM PLUS PEQUAL OREQUAL OR NEQUAL MULEQUAL MUL MODEQUAL MOD MINUSEQUAL MINUS LTHAN LSHIFTEQUAL LSHIFT LOGSHIFTEQUAL LOGSHIFT LETHAN INSTANCEOF INCREMENT GTHAN GETHAN EQUAL DOT DIVEQUAL DIV DECREMENT COMM COL BOR BAND ASSIGN ANDEQUAL AND ]
-- On XOREQUAL reduce production realPostfixExpression -> postfixExpression DECREMENT 
-- On XOR reduce production realPostfixExpression -> postfixExpression DECREMENT 
-- On SEMI reduce production realPostfixExpression -> postfixExpression DECREMENT 
-- On RSHIFTEQUAL reduce production realPostfixExpression -> postfixExpression DECREMENT 
-- On RSHIFT reduce production realPostfixExpression -> postfixExpression DECREMENT 
-- On RPAR reduce production realPostfixExpression -> postfixExpression DECREMENT 
-- On RCURL reduce production realPostfixExpression -> postfixExpression DECREMENT 
-- On RBRAC reduce production realPostfixExpression -> postfixExpression DECREMENT 
-- On QM reduce production realPostfixExpression -> postfixExpression DECREMENT 
-- On PLUS reduce production realPostfixExpression -> postfixExpression DECREMENT 
-- On PEQUAL reduce production realPostfixExpression -> postfixExpression DECREMENT 
-- On OREQUAL reduce production realPostfixExpression -> postfixExpression DECREMENT 
-- On OR reduce production realPostfixExpression -> postfixExpression DECREMENT 
-- On NEQUAL reduce production realPostfixExpression -> postfixExpression DECREMENT 
-- On MULEQUAL reduce production realPostfixExpression -> postfixExpression DECREMENT 
-- On MUL reduce production realPostfixExpression -> postfixExpression DECREMENT 
-- On MODEQUAL reduce production realPostfixExpression -> postfixExpression DECREMENT 
-- On MOD reduce production realPostfixExpression -> postfixExpression DECREMENT 
-- On MINUSEQUAL reduce production realPostfixExpression -> postfixExpression DECREMENT 
-- On MINUS reduce production realPostfixExpression -> postfixExpression DECREMENT 
-- On LTHAN reduce production realPostfixExpression -> postfixExpression DECREMENT 
-- On LSHIFTEQUAL reduce production realPostfixExpression -> postfixExpression DECREMENT 
-- On LSHIFT reduce production realPostfixExpression -> postfixExpression DECREMENT 
-- On LOGSHIFTEQUAL reduce production realPostfixExpression -> postfixExpression DECREMENT 
-- On LOGSHIFT reduce production realPostfixExpression -> postfixExpression DECREMENT 
-- On LETHAN reduce production realPostfixExpression -> postfixExpression DECREMENT 
-- On INSTANCEOF reduce production realPostfixExpression -> postfixExpression DECREMENT 
-- On INCREMENT reduce production realPostfixExpression -> postfixExpression DECREMENT 
-- On GTHAN reduce production realPostfixExpression -> postfixExpression DECREMENT 
-- On GETHAN reduce production realPostfixExpression -> postfixExpression DECREMENT 
-- On EQUAL reduce production realPostfixExpression -> postfixExpression DECREMENT 
-- On DOT reduce production realPostfixExpression -> postfixExpression DECREMENT 
-- On DIVEQUAL reduce production realPostfixExpression -> postfixExpression DECREMENT 
-- On DIV reduce production realPostfixExpression -> postfixExpression DECREMENT 
-- On DECREMENT reduce production realPostfixExpression -> postfixExpression DECREMENT 
-- On COMM reduce production realPostfixExpression -> postfixExpression DECREMENT 
-- On COL reduce production realPostfixExpression -> postfixExpression DECREMENT 
-- On BOR reduce production realPostfixExpression -> postfixExpression DECREMENT 
-- On BAND reduce production realPostfixExpression -> postfixExpression DECREMENT 
-- On ASSIGN reduce production realPostfixExpression -> postfixExpression DECREMENT 
-- On ANDEQUAL reduce production realPostfixExpression -> postfixExpression DECREMENT 
-- On AND reduce production realPostfixExpression -> postfixExpression DECREMENT 

State 68:
newAllocationExpression -> plainNewAllocationExpression . [ XOREQUAL XOR SEMI RSHIFTEQUAL RSHIFT RPAR RCURL RBRAC QM PLUS PEQUAL OREQUAL OR NEQUAL MULEQUAL MUL MODEQUAL MOD MINUSEQUAL MINUS LTHAN LSHIFTEQUAL LSHIFT LOGSHIFTEQUAL LOGSHIFT LETHAN INSTANCEOF INCREMENT GTHAN GETHAN EQUAL DOT DIVEQUAL DIV DECREMENT COMM COL BOR BAND ASSIGN ANDEQUAL AND ]
-- On XOREQUAL reduce production newAllocationExpression -> plainNewAllocationExpression 
-- On XOR reduce production newAllocationExpression -> plainNewAllocationExpression 
-- On SEMI reduce production newAllocationExpression -> plainNewAllocationExpression 
-- On RSHIFTEQUAL reduce production newAllocationExpression -> plainNewAllocationExpression 
-- On RSHIFT reduce production newAllocationExpression -> plainNewAllocationExpression 
-- On RPAR reduce production newAllocationExpression -> plainNewAllocationExpression 
-- On RCURL reduce production newAllocationExpression -> plainNewAllocationExpression 
-- On RBRAC reduce production newAllocationExpression -> plainNewAllocationExpression 
-- On QM reduce production newAllocationExpression -> plainNewAllocationExpression 
-- On PLUS reduce production newAllocationExpression -> plainNewAllocationExpression 
-- On PEQUAL reduce production newAllocationExpression -> plainNewAllocationExpression 
-- On OREQUAL reduce production newAllocationExpression -> plainNewAllocationExpression 
-- On OR reduce production newAllocationExpression -> plainNewAllocationExpression 
-- On NEQUAL reduce production newAllocationExpression -> plainNewAllocationExpression 
-- On MULEQUAL reduce production newAllocationExpression -> plainNewAllocationExpression 
-- On MUL reduce production newAllocationExpression -> plainNewAllocationExpression 
-- On MODEQUAL reduce production newAllocationExpression -> plainNewAllocationExpression 
-- On MOD reduce production newAllocationExpression -> plainNewAllocationExpression 
-- On MINUSEQUAL reduce production newAllocationExpression -> plainNewAllocationExpression 
-- On MINUS reduce production newAllocationExpression -> plainNewAllocationExpression 
-- On LTHAN reduce production newAllocationExpression -> plainNewAllocationExpression 
-- On LSHIFTEQUAL reduce production newAllocationExpression -> plainNewAllocationExpression 
-- On LSHIFT reduce production newAllocationExpression -> plainNewAllocationExpression 
-- On LOGSHIFTEQUAL reduce production newAllocationExpression -> plainNewAllocationExpression 
-- On LOGSHIFT reduce production newAllocationExpression -> plainNewAllocationExpression 
-- On LETHAN reduce production newAllocationExpression -> plainNewAllocationExpression 
-- On INSTANCEOF reduce production newAllocationExpression -> plainNewAllocationExpression 
-- On INCREMENT reduce production newAllocationExpression -> plainNewAllocationExpression 
-- On GTHAN reduce production newAllocationExpression -> plainNewAllocationExpression 
-- On GETHAN reduce production newAllocationExpression -> plainNewAllocationExpression 
-- On EQUAL reduce production newAllocationExpression -> plainNewAllocationExpression 
-- On DOT reduce production newAllocationExpression -> plainNewAllocationExpression 
-- On DIVEQUAL reduce production newAllocationExpression -> plainNewAllocationExpression 
-- On DIV reduce production newAllocationExpression -> plainNewAllocationExpression 
-- On DECREMENT reduce production newAllocationExpression -> plainNewAllocationExpression 
-- On COMM reduce production newAllocationExpression -> plainNewAllocationExpression 
-- On COL reduce production newAllocationExpression -> plainNewAllocationExpression 
-- On BOR reduce production newAllocationExpression -> plainNewAllocationExpression 
-- On BAND reduce production newAllocationExpression -> plainNewAllocationExpression 
-- On ASSIGN reduce production newAllocationExpression -> plainNewAllocationExpression 
-- On ANDEQUAL reduce production newAllocationExpression -> plainNewAllocationExpression 
-- On AND reduce production newAllocationExpression -> plainNewAllocationExpression 

State 69:
fieldAccess -> notJustName . DOT IDENTIFIER [ XOREQUAL XOR SEMI RSHIFTEQUAL RSHIFT RPAR RCURL RBRAC QM PLUS PEQUAL OREQUAL OR NEQUAL MULEQUAL MUL MODEQUAL MOD MINUSEQUAL MINUS LTHAN LSHIFTEQUAL LSHIFT LPAR LOGSHIFTEQUAL LOGSHIFT LETHAN LBRAC INSTANCEOF INCREMENT GTHAN GETHAN EQUAL DOT DIVEQUAL DIV DECREMENT COMM COL BOR BAND ASSIGN ANDEQUAL AND ]
primaryExpression -> notJustName . [ XOREQUAL XOR SEMI RSHIFTEQUAL RSHIFT RPAR RCURL RBRAC QM PLUS PEQUAL OREQUAL OR NEQUAL MULEQUAL MUL MODEQUAL MOD MINUSEQUAL MINUS LTHAN LSHIFTEQUAL LSHIFT LOGSHIFTEQUAL LOGSHIFT LETHAN INSTANCEOF INCREMENT GTHAN GETHAN EQUAL DIVEQUAL DIV DECREMENT COMM COL BOR BAND ASSIGN ANDEQUAL AND ]
-- On DOT shift to state 70
-- On XOREQUAL reduce production primaryExpression -> notJustName 
-- On XOR reduce production primaryExpression -> notJustName 
-- On SEMI reduce production primaryExpression -> notJustName 
-- On RSHIFTEQUAL reduce production primaryExpression -> notJustName 
-- On RSHIFT reduce production primaryExpression -> notJustName 
-- On RPAR reduce production primaryExpression -> notJustName 
-- On RCURL reduce production primaryExpression -> notJustName 
-- On RBRAC reduce production primaryExpression -> notJustName 
-- On QM reduce production primaryExpression -> notJustName 
-- On PLUS reduce production primaryExpression -> notJustName 
-- On PEQUAL reduce production primaryExpression -> notJustName 
-- On OREQUAL reduce production primaryExpression -> notJustName 
-- On OR reduce production primaryExpression -> notJustName 
-- On NEQUAL reduce production primaryExpression -> notJustName 
-- On MULEQUAL reduce production primaryExpression -> notJustName 
-- On MUL reduce production primaryExpression -> notJustName 
-- On MODEQUAL reduce production primaryExpression -> notJustName 
-- On MOD reduce production primaryExpression -> notJustName 
-- On MINUSEQUAL reduce production primaryExpression -> notJustName 
-- On MINUS reduce production primaryExpression -> notJustName 
-- On LTHAN reduce production primaryExpression -> notJustName 
-- On LSHIFTEQUAL reduce production primaryExpression -> notJustName 
-- On LSHIFT reduce production primaryExpression -> notJustName 
-- On LOGSHIFTEQUAL reduce production primaryExpression -> notJustName 
-- On LOGSHIFT reduce production primaryExpression -> notJustName 
-- On LETHAN reduce production primaryExpression -> notJustName 
-- On INSTANCEOF reduce production primaryExpression -> notJustName 
-- On INCREMENT reduce production primaryExpression -> notJustName 
-- On GTHAN reduce production primaryExpression -> notJustName 
-- On GETHAN reduce production primaryExpression -> notJustName 
-- On EQUAL reduce production primaryExpression -> notJustName 
-- On DIVEQUAL reduce production primaryExpression -> notJustName 
-- On DIV reduce production primaryExpression -> notJustName 
-- On DECREMENT reduce production primaryExpression -> notJustName 
-- On COMM reduce production primaryExpression -> notJustName 
-- On COL reduce production primaryExpression -> notJustName 
-- On BOR reduce production primaryExpression -> notJustName 
-- On BAND reduce production primaryExpression -> notJustName 
-- On ASSIGN reduce production primaryExpression -> notJustName 
-- On ANDEQUAL reduce production primaryExpression -> notJustName 
-- On AND reduce production primaryExpression -> notJustName 

State 70:
fieldAccess -> notJustName DOT . IDENTIFIER [ XOREQUAL XOR SEMI RSHIFTEQUAL RSHIFT RPAR RCURL RBRAC QM PLUS PEQUAL OREQUAL OR NEQUAL MULEQUAL MUL MODEQUAL MOD MINUSEQUAL MINUS LTHAN LSHIFTEQUAL LSHIFT LPAR LOGSHIFTEQUAL LOGSHIFT LETHAN LBRAC INSTANCEOF INCREMENT GTHAN GETHAN EQUAL DOT DIVEQUAL DIV DECREMENT COMM COL BOR BAND ASSIGN ANDEQUAL AND ]
-- On IDENTIFIER shift to state 71

State 71:
fieldAccess -> notJustName DOT IDENTIFIER . [ XOREQUAL XOR SEMI RSHIFTEQUAL RSHIFT RPAR RCURL RBRAC QM PLUS PEQUAL OREQUAL OR NEQUAL MULEQUAL MUL MODEQUAL MOD MINUSEQUAL MINUS LTHAN LSHIFTEQUAL LSHIFT LPAR LOGSHIFTEQUAL LOGSHIFT LETHAN LBRAC INSTANCEOF INCREMENT GTHAN GETHAN EQUAL DOT DIVEQUAL DIV DECREMENT COMM COL BOR BAND ASSIGN ANDEQUAL AND ]
-- On XOREQUAL reduce production fieldAccess -> notJustName DOT IDENTIFIER 
-- On XOR reduce production fieldAccess -> notJustName DOT IDENTIFIER 
-- On SEMI reduce production fieldAccess -> notJustName DOT IDENTIFIER 
-- On RSHIFTEQUAL reduce production fieldAccess -> notJustName DOT IDENTIFIER 
-- On RSHIFT reduce production fieldAccess -> notJustName DOT IDENTIFIER 
-- On RPAR reduce production fieldAccess -> notJustName DOT IDENTIFIER 
-- On RCURL reduce production fieldAccess -> notJustName DOT IDENTIFIER 
-- On RBRAC reduce production fieldAccess -> notJustName DOT IDENTIFIER 
-- On QM reduce production fieldAccess -> notJustName DOT IDENTIFIER 
-- On PLUS reduce production fieldAccess -> notJustName DOT IDENTIFIER 
-- On PEQUAL reduce production fieldAccess -> notJustName DOT IDENTIFIER 
-- On OREQUAL reduce production fieldAccess -> notJustName DOT IDENTIFIER 
-- On OR reduce production fieldAccess -> notJustName DOT IDENTIFIER 
-- On NEQUAL reduce production fieldAccess -> notJustName DOT IDENTIFIER 
-- On MULEQUAL reduce production fieldAccess -> notJustName DOT IDENTIFIER 
-- On MUL reduce production fieldAccess -> notJustName DOT IDENTIFIER 
-- On MODEQUAL reduce production fieldAccess -> notJustName DOT IDENTIFIER 
-- On MOD reduce production fieldAccess -> notJustName DOT IDENTIFIER 
-- On MINUSEQUAL reduce production fieldAccess -> notJustName DOT IDENTIFIER 
-- On MINUS reduce production fieldAccess -> notJustName DOT IDENTIFIER 
-- On LTHAN reduce production fieldAccess -> notJustName DOT IDENTIFIER 
-- On LSHIFTEQUAL reduce production fieldAccess -> notJustName DOT IDENTIFIER 
-- On LSHIFT reduce production fieldAccess -> notJustName DOT IDENTIFIER 
-- On LPAR reduce production fieldAccess -> notJustName DOT IDENTIFIER 
-- On LOGSHIFTEQUAL reduce production fieldAccess -> notJustName DOT IDENTIFIER 
-- On LOGSHIFT reduce production fieldAccess -> notJustName DOT IDENTIFIER 
-- On LETHAN reduce production fieldAccess -> notJustName DOT IDENTIFIER 
-- On LBRAC reduce production fieldAccess -> notJustName DOT IDENTIFIER 
-- On INSTANCEOF reduce production fieldAccess -> notJustName DOT IDENTIFIER 
-- On INCREMENT reduce production fieldAccess -> notJustName DOT IDENTIFIER 
-- On GTHAN reduce production fieldAccess -> notJustName DOT IDENTIFIER 
-- On GETHAN reduce production fieldAccess -> notJustName DOT IDENTIFIER 
-- On EQUAL reduce production fieldAccess -> notJustName DOT IDENTIFIER 
-- On DOT reduce production fieldAccess -> notJustName DOT IDENTIFIER 
-- On DIVEQUAL reduce production fieldAccess -> notJustName DOT IDENTIFIER 
-- On DIV reduce production fieldAccess -> notJustName DOT IDENTIFIER 
-- On DECREMENT reduce production fieldAccess -> notJustName DOT IDENTIFIER 
-- On COMM reduce production fieldAccess -> notJustName DOT IDENTIFIER 
-- On COL reduce production fieldAccess -> notJustName DOT IDENTIFIER 
-- On BOR reduce production fieldAccess -> notJustName DOT IDENTIFIER 
-- On BAND reduce production fieldAccess -> notJustName DOT IDENTIFIER 
-- On ASSIGN reduce production fieldAccess -> notJustName DOT IDENTIFIER 
-- On ANDEQUAL reduce production fieldAccess -> notJustName DOT IDENTIFIER 
-- On AND reduce production fieldAccess -> notJustName DOT IDENTIFIER 

State 72:
notJustName -> newAllocationExpression . [ XOREQUAL XOR SEMI RSHIFTEQUAL RSHIFT RPAR RCURL RBRAC QM PLUS PEQUAL OREQUAL OR NEQUAL MULEQUAL MUL MODEQUAL MOD MINUSEQUAL MINUS LTHAN LSHIFTEQUAL LSHIFT LOGSHIFTEQUAL LOGSHIFT LETHAN INSTANCEOF INCREMENT GTHAN GETHAN EQUAL DOT DIVEQUAL DIV DECREMENT COMM COL BOR BAND ASSIGN ANDEQUAL AND ]
-- On XOREQUAL reduce production notJustName -> newAllocationExpression 
-- On XOR reduce production notJustName -> newAllocationExpression 
-- On SEMI reduce production notJustName -> newAllocationExpression 
-- On RSHIFTEQUAL reduce production notJustName -> newAllocationExpression 
-- On RSHIFT reduce production notJustName -> newAllocationExpression 
-- On RPAR reduce production notJustName -> newAllocationExpression 
-- On RCURL reduce production notJustName -> newAllocationExpression 
-- On RBRAC reduce production notJustName -> newAllocationExpression 
-- On QM reduce production notJustName -> newAllocationExpression 
-- On PLUS reduce production notJustName -> newAllocationExpression 
-- On PEQUAL reduce production notJustName -> newAllocationExpression 
-- On OREQUAL reduce production notJustName -> newAllocationExpression 
-- On OR reduce production notJustName -> newAllocationExpression 
-- On NEQUAL reduce production notJustName -> newAllocationExpression 
-- On MULEQUAL reduce production notJustName -> newAllocationExpression 
-- On MUL reduce production notJustName -> newAllocationExpression 
-- On MODEQUAL reduce production notJustName -> newAllocationExpression 
-- On MOD reduce production notJustName -> newAllocationExpression 
-- On MINUSEQUAL reduce production notJustName -> newAllocationExpression 
-- On MINUS reduce production notJustName -> newAllocationExpression 
-- On LTHAN reduce production notJustName -> newAllocationExpression 
-- On LSHIFTEQUAL reduce production notJustName -> newAllocationExpression 
-- On LSHIFT reduce production notJustName -> newAllocationExpression 
-- On LOGSHIFTEQUAL reduce production notJustName -> newAllocationExpression 
-- On LOGSHIFT reduce production notJustName -> newAllocationExpression 
-- On LETHAN reduce production notJustName -> newAllocationExpression 
-- On INSTANCEOF reduce production notJustName -> newAllocationExpression 
-- On INCREMENT reduce production notJustName -> newAllocationExpression 
-- On GTHAN reduce production notJustName -> newAllocationExpression 
-- On GETHAN reduce production notJustName -> newAllocationExpression 
-- On EQUAL reduce production notJustName -> newAllocationExpression 
-- On DOT reduce production notJustName -> newAllocationExpression 
-- On DIVEQUAL reduce production notJustName -> newAllocationExpression 
-- On DIV reduce production notJustName -> newAllocationExpression 
-- On DECREMENT reduce production notJustName -> newAllocationExpression 
-- On COMM reduce production notJustName -> newAllocationExpression 
-- On COL reduce production notJustName -> newAllocationExpression 
-- On BOR reduce production notJustName -> newAllocationExpression 
-- On BAND reduce production notJustName -> newAllocationExpression 
-- On ASSIGN reduce production notJustName -> newAllocationExpression 
-- On ANDEQUAL reduce production notJustName -> newAllocationExpression 
-- On AND reduce production notJustName -> newAllocationExpression 

State 73:
additiveExpression -> multiplicativeExpression . [ XOR SEMI RSHIFT RPAR RCURL RBRAC QM PLUS OR NEQUAL MINUS LTHAN LSHIFT LOGSHIFT LETHAN INSTANCEOF GTHAN GETHAN EQUAL COMM COL BOR BAND AND ]
multiplicativeExpression -> multiplicativeExpression . MUL castExpression [ XOR SEMI RSHIFT RPAR RCURL RBRAC QM PLUS OR NEQUAL MUL MOD MINUS LTHAN LSHIFT LOGSHIFT LETHAN INSTANCEOF GTHAN GETHAN EQUAL DIV COMM COL BOR BAND AND ]
multiplicativeExpression -> multiplicativeExpression . DIV castExpression [ XOR SEMI RSHIFT RPAR RCURL RBRAC QM PLUS OR NEQUAL MUL MOD MINUS LTHAN LSHIFT LOGSHIFT LETHAN INSTANCEOF GTHAN GETHAN EQUAL DIV COMM COL BOR BAND AND ]
multiplicativeExpression -> multiplicativeExpression . MOD castExpression [ XOR SEMI RSHIFT RPAR RCURL RBRAC QM PLUS OR NEQUAL MUL MOD MINUS LTHAN LSHIFT LOGSHIFT LETHAN INSTANCEOF GTHAN GETHAN EQUAL DIV COMM COL BOR BAND AND ]
-- On MUL shift to state 74
-- On MOD shift to state 143
-- On DIV shift to state 145
-- On XOR reduce production additiveExpression -> multiplicativeExpression 
-- On SEMI reduce production additiveExpression -> multiplicativeExpression 
-- On RSHIFT reduce production additiveExpression -> multiplicativeExpression 
-- On RPAR reduce production additiveExpression -> multiplicativeExpression 
-- On RCURL reduce production additiveExpression -> multiplicativeExpression 
-- On RBRAC reduce production additiveExpression -> multiplicativeExpression 
-- On QM reduce production additiveExpression -> multiplicativeExpression 
-- On PLUS reduce production additiveExpression -> multiplicativeExpression 
-- On OR reduce production additiveExpression -> multiplicativeExpression 
-- On NEQUAL reduce production additiveExpression -> multiplicativeExpression 
-- On MINUS reduce production additiveExpression -> multiplicativeExpression 
-- On LTHAN reduce production additiveExpression -> multiplicativeExpression 
-- On LSHIFT reduce production additiveExpression -> multiplicativeExpression 
-- On LOGSHIFT reduce production additiveExpression -> multiplicativeExpression 
-- On LETHAN reduce production additiveExpression -> multiplicativeExpression 
-- On INSTANCEOF reduce production additiveExpression -> multiplicativeExpression 
-- On GTHAN reduce production additiveExpression -> multiplicativeExpression 
-- On GETHAN reduce production additiveExpression -> multiplicativeExpression 
-- On EQUAL reduce production additiveExpression -> multiplicativeExpression 
-- On COMM reduce production additiveExpression -> multiplicativeExpression 
-- On COL reduce production additiveExpression -> multiplicativeExpression 
-- On BOR reduce production additiveExpression -> multiplicativeExpression 
-- On BAND reduce production additiveExpression -> multiplicativeExpression 
-- On AND reduce production additiveExpression -> multiplicativeExpression 

State 74:
multiplicativeExpression -> multiplicativeExpression MUL . castExpression [ XOR SEMI RSHIFT RPAR RCURL RBRAC QM PLUS OR NEQUAL MUL MOD MINUS LTHAN LSHIFT LOGSHIFT LETHAN INSTANCEOF GTHAN GETHAN EQUAL DIV COMM COL BOR BAND AND ]
-- On VOID shift to state 6
-- On THIS shift to state 7
-- On SUPER shift to state 8
-- On STRLIT shift to state 9
-- On SHORT shift to state 10
-- On PLUS shift to state 11
-- On NULLLIT shift to state 12
-- On NOT shift to state 13
-- On NEW shift to state 14
-- On MINUS shift to state 26
-- On LPAR shift to state 27
-- On LONG shift to state 15
-- On INTLIT shift to state 28
-- On INT shift to state 16
-- On INCREMENT shift to state 29
-- On IDENTIFIER shift to state 17
-- On FLOATLIT shift to state 31
-- On FLOAT shift to state 18
-- On DOUBLELIT shift to state 32
-- On DOUBLE shift to state 19
-- On DECREMENT shift to state 33
-- On CHARLIT shift to state 34
-- On CHAR shift to state 20
-- On BYTE shift to state 21
-- On BOOLEANLIT shift to state 35
-- On BOOLEAN shift to state 22
-- On BNOT shift to state 36
-- On unaryExpression shift to state 60
-- On specialName shift to state 38
-- On realPostfixExpression shift to state 39
-- On qualifiedName shift to state 42
-- On primitiveType shift to state 61
-- On primaryExpression shift to state 64
-- On postfixExpression shift to state 65
-- On plainNewAllocationExpression shift to state 68
-- On notJustName shift to state 69
-- On newAllocationExpression shift to state 72
-- On methodCall shift to state 75
-- On methodAccess shift to state 76
-- On logicalUnaryOperator shift to state 83
-- On logicalUnaryExpression shift to state 85
-- On fieldAccess shift to state 86
-- On complexPrimaryNoParenthesis shift to state 87
-- On complexPrimary shift to state 88
-- On classAllocationExpression shift to state 100
-- On castExpression shift to state 171
-- On arrayAllocationExpression shift to state 104
-- On arrayAccess shift to state 120
-- On arithmeticUnaryOperator shift to state 121

State 75:
complexPrimaryNoParenthesis -> methodCall . [ XOREQUAL XOR SEMI RSHIFTEQUAL RSHIFT RPAR RCURL RBRAC QM PLUS PEQUAL OREQUAL OR NEQUAL MULEQUAL MUL MODEQUAL MOD MINUSEQUAL MINUS LTHAN LSHIFTEQUAL LSHIFT LPAR LOGSHIFTEQUAL LOGSHIFT LETHAN LBRAC INSTANCEOF INCREMENT GTHAN GETHAN EQUAL DOT DIVEQUAL DIV DECREMENT COMM COL BOR BAND ASSIGN ANDEQUAL AND ]
-- On XOREQUAL reduce production complexPrimaryNoParenthesis -> methodCall 
-- On XOR reduce production complexPrimaryNoParenthesis -> methodCall 
-- On SEMI reduce production complexPrimaryNoParenthesis -> methodCall 
-- On RSHIFTEQUAL reduce production complexPrimaryNoParenthesis -> methodCall 
-- On RSHIFT reduce production complexPrimaryNoParenthesis -> methodCall 
-- On RPAR reduce production complexPrimaryNoParenthesis -> methodCall 
-- On RCURL reduce production complexPrimaryNoParenthesis -> methodCall 
-- On RBRAC reduce production complexPrimaryNoParenthesis -> methodCall 
-- On QM reduce production complexPrimaryNoParenthesis -> methodCall 
-- On PLUS reduce production complexPrimaryNoParenthesis -> methodCall 
-- On PEQUAL reduce production complexPrimaryNoParenthesis -> methodCall 
-- On OREQUAL reduce production complexPrimaryNoParenthesis -> methodCall 
-- On OR reduce production complexPrimaryNoParenthesis -> methodCall 
-- On NEQUAL reduce production complexPrimaryNoParenthesis -> methodCall 
-- On MULEQUAL reduce production complexPrimaryNoParenthesis -> methodCall 
-- On MUL reduce production complexPrimaryNoParenthesis -> methodCall 
-- On MODEQUAL reduce production complexPrimaryNoParenthesis -> methodCall 
-- On MOD reduce production complexPrimaryNoParenthesis -> methodCall 
-- On MINUSEQUAL reduce production complexPrimaryNoParenthesis -> methodCall 
-- On MINUS reduce production complexPrimaryNoParenthesis -> methodCall 
-- On LTHAN reduce production complexPrimaryNoParenthesis -> methodCall 
-- On LSHIFTEQUAL reduce production complexPrimaryNoParenthesis -> methodCall 
-- On LSHIFT reduce production complexPrimaryNoParenthesis -> methodCall 
-- On LPAR reduce production complexPrimaryNoParenthesis -> methodCall 
-- On LOGSHIFTEQUAL reduce production complexPrimaryNoParenthesis -> methodCall 
-- On LOGSHIFT reduce production complexPrimaryNoParenthesis -> methodCall 
-- On LETHAN reduce production complexPrimaryNoParenthesis -> methodCall 
-- On LBRAC reduce production complexPrimaryNoParenthesis -> methodCall 
-- On INSTANCEOF reduce production complexPrimaryNoParenthesis -> methodCall 
-- On INCREMENT reduce production complexPrimaryNoParenthesis -> methodCall 
-- On GTHAN reduce production complexPrimaryNoParenthesis -> methodCall 
-- On GETHAN reduce production complexPrimaryNoParenthesis -> methodCall 
-- On EQUAL reduce production complexPrimaryNoParenthesis -> methodCall 
-- On DOT reduce production complexPrimaryNoParenthesis -> methodCall 
-- On DIVEQUAL reduce production complexPrimaryNoParenthesis -> methodCall 
-- On DIV reduce production complexPrimaryNoParenthesis -> methodCall 
-- On DECREMENT reduce production complexPrimaryNoParenthesis -> methodCall 
-- On COMM reduce production complexPrimaryNoParenthesis -> methodCall 
-- On COL reduce production complexPrimaryNoParenthesis -> methodCall 
-- On BOR reduce production complexPrimaryNoParenthesis -> methodCall 
-- On BAND reduce production complexPrimaryNoParenthesis -> methodCall 
-- On ASSIGN reduce production complexPrimaryNoParenthesis -> methodCall 
-- On ANDEQUAL reduce production complexPrimaryNoParenthesis -> methodCall 
-- On AND reduce production complexPrimaryNoParenthesis -> methodCall 

State 76:
methodCall -> methodAccess . LPAR argumentList RPAR [ XOREQUAL XOR SEMI RSHIFTEQUAL RSHIFT RPAR RCURL RBRAC QM PLUS PEQUAL OREQUAL OR NEQUAL MULEQUAL MUL MODEQUAL MOD MINUSEQUAL MINUS LTHAN LSHIFTEQUAL LSHIFT LPAR LOGSHIFTEQUAL LOGSHIFT LETHAN LBRAC INSTANCEOF INCREMENT GTHAN GETHAN EQUAL DOT DIVEQUAL DIV DECREMENT COMM COL BOR BAND ASSIGN ANDEQUAL AND ]
methodCall -> methodAccess . LPAR RPAR [ XOREQUAL XOR SEMI RSHIFTEQUAL RSHIFT RPAR RCURL RBRAC QM PLUS PEQUAL OREQUAL OR NEQUAL MULEQUAL MUL MODEQUAL MOD MINUSEQUAL MINUS LTHAN LSHIFTEQUAL LSHIFT LPAR LOGSHIFTEQUAL LOGSHIFT LETHAN LBRAC INSTANCEOF INCREMENT GTHAN GETHAN EQUAL DOT DIVEQUAL DIV DECREMENT COMM COL BOR BAND ASSIGN ANDEQUAL AND ]
-- On LPAR shift to state 77

State 77:
methodCall -> methodAccess LPAR . argumentList RPAR [ XOREQUAL XOR SEMI RSHIFTEQUAL RSHIFT RPAR RCURL RBRAC QM PLUS PEQUAL OREQUAL OR NEQUAL MULEQUAL MUL MODEQUAL MOD MINUSEQUAL MINUS LTHAN LSHIFTEQUAL LSHIFT LPAR LOGSHIFTEQUAL LOGSHIFT LETHAN LBRAC INSTANCEOF INCREMENT GTHAN GETHAN EQUAL DOT DIVEQUAL DIV DECREMENT COMM COL BOR BAND ASSIGN ANDEQUAL AND ]
methodCall -> methodAccess LPAR . RPAR [ XOREQUAL XOR SEMI RSHIFTEQUAL RSHIFT RPAR RCURL RBRAC QM PLUS PEQUAL OREQUAL OR NEQUAL MULEQUAL MUL MODEQUAL MOD MINUSEQUAL MINUS LTHAN LSHIFTEQUAL LSHIFT LPAR LOGSHIFTEQUAL LOGSHIFT LETHAN LBRAC INSTANCEOF INCREMENT GTHAN GETHAN EQUAL DOT DIVEQUAL DIV DECREMENT COMM COL BOR BAND ASSIGN ANDEQUAL AND ]
-- On error shift to state 3
-- On VOID shift to state 6
-- On THIS shift to state 7
-- On SUPER shift to state 8
-- On STRLIT shift to state 9
-- On SHORT shift to state 10
-- On RPAR shift to state 78
-- On PLUS shift to state 11
-- On NULLLIT shift to state 12
-- On NOT shift to state 13
-- On NEW shift to state 14
-- On MINUS shift to state 26
-- On LPAR shift to state 27
-- On LONG shift to state 15
-- On INTLIT shift to state 28
-- On INT shift to state 16
-- On INCREMENT shift to state 29
-- On IDENTIFIER shift to state 17
-- On FLOATLIT shift to state 31
-- On FLOAT shift to state 18
-- On DOUBLELIT shift to state 32
-- On DOUBLE shift to state 19
-- On DECREMENT shift to state 33
-- On CHARLIT shift to state 34
-- On CHAR shift to state 20
-- On BYTE shift to state 21
-- On BOOLEANLIT shift to state 35
-- On BOOLEAN shift to state 22
-- On BNOT shift to state 36
-- On unaryExpression shift to state 44
-- On specialName shift to state 38
-- On shiftExpression shift to state 58
-- On relationalExpression shift to state 79
-- On realPostfixExpression shift to state 39
-- On qualifiedName shift to state 42
-- On primitiveType shift to state 61
-- On primaryExpression shift to state 64
-- On postfixExpression shift to state 65
-- On plainNewAllocationExpression shift to state 68
-- On notJustName shift to state 69
-- On newAllocationExpression shift to state 72
-- On multiplicativeExpression shift to state 73
-- On methodCall shift to state 75
-- On methodAccess shift to state 76
-- On logicalUnaryOperator shift to state 83
-- On logicalUnaryExpression shift to state 85
-- On inclusiveOrExpression shift to state 90
-- On fieldAccess shift to state 86
-- On expression shift to state 166
-- On exclusiveOrExpression shift to state 111
-- On equalityExpression shift to state 94
-- On conditionalOrExpression shift to state 112
-- On conditionalExpression shift to state 151
-- On conditionalAndExpression shift to state 117
-- On complexPrimaryNoParenthesis shift to state 87
-- On complexPrimary shift to state 88
-- On classAllocationExpression shift to state 100
-- On castExpression shift to state 103
-- On assignmentExpression shift to state 152
-- On arrayAllocationExpression shift to state 104
-- On arrayAccess shift to state 120
-- On arithmeticUnaryOperator shift to state 121
-- On argumentList shift to state 167
-- On andExpression shift to state 123
-- On additiveExpression shift to state 140

State 78:
methodCall -> methodAccess LPAR RPAR . [ XOREQUAL XOR SEMI RSHIFTEQUAL RSHIFT RPAR RCURL RBRAC QM PLUS PEQUAL OREQUAL OR NEQUAL MULEQUAL MUL MODEQUAL MOD MINUSEQUAL MINUS LTHAN LSHIFTEQUAL LSHIFT LPAR LOGSHIFTEQUAL LOGSHIFT LETHAN LBRAC INSTANCEOF INCREMENT GTHAN GETHAN EQUAL DOT DIVEQUAL DIV DECREMENT COMM COL BOR BAND ASSIGN ANDEQUAL AND ]
-- On XOREQUAL reduce production methodCall -> methodAccess LPAR RPAR 
-- On XOR reduce production methodCall -> methodAccess LPAR RPAR 
-- On SEMI reduce production methodCall -> methodAccess LPAR RPAR 
-- On RSHIFTEQUAL reduce production methodCall -> methodAccess LPAR RPAR 
-- On RSHIFT reduce production methodCall -> methodAccess LPAR RPAR 
-- On RPAR reduce production methodCall -> methodAccess LPAR RPAR 
-- On RCURL reduce production methodCall -> methodAccess LPAR RPAR 
-- On RBRAC reduce production methodCall -> methodAccess LPAR RPAR 
-- On QM reduce production methodCall -> methodAccess LPAR RPAR 
-- On PLUS reduce production methodCall -> methodAccess LPAR RPAR 
-- On PEQUAL reduce production methodCall -> methodAccess LPAR RPAR 
-- On OREQUAL reduce production methodCall -> methodAccess LPAR RPAR 
-- On OR reduce production methodCall -> methodAccess LPAR RPAR 
-- On NEQUAL reduce production methodCall -> methodAccess LPAR RPAR 
-- On MULEQUAL reduce production methodCall -> methodAccess LPAR RPAR 
-- On MUL reduce production methodCall -> methodAccess LPAR RPAR 
-- On MODEQUAL reduce production methodCall -> methodAccess LPAR RPAR 
-- On MOD reduce production methodCall -> methodAccess LPAR RPAR 
-- On MINUSEQUAL reduce production methodCall -> methodAccess LPAR RPAR 
-- On MINUS reduce production methodCall -> methodAccess LPAR RPAR 
-- On LTHAN reduce production methodCall -> methodAccess LPAR RPAR 
-- On LSHIFTEQUAL reduce production methodCall -> methodAccess LPAR RPAR 
-- On LSHIFT reduce production methodCall -> methodAccess LPAR RPAR 
-- On LPAR reduce production methodCall -> methodAccess LPAR RPAR 
-- On LOGSHIFTEQUAL reduce production methodCall -> methodAccess LPAR RPAR 
-- On LOGSHIFT reduce production methodCall -> methodAccess LPAR RPAR 
-- On LETHAN reduce production methodCall -> methodAccess LPAR RPAR 
-- On LBRAC reduce production methodCall -> methodAccess LPAR RPAR 
-- On INSTANCEOF reduce production methodCall -> methodAccess LPAR RPAR 
-- On INCREMENT reduce production methodCall -> methodAccess LPAR RPAR 
-- On GTHAN reduce production methodCall -> methodAccess LPAR RPAR 
-- On GETHAN reduce production methodCall -> methodAccess LPAR RPAR 
-- On EQUAL reduce production methodCall -> methodAccess LPAR RPAR 
-- On DOT reduce production methodCall -> methodAccess LPAR RPAR 
-- On DIVEQUAL reduce production methodCall -> methodAccess LPAR RPAR 
-- On DIV reduce production methodCall -> methodAccess LPAR RPAR 
-- On DECREMENT reduce production methodCall -> methodAccess LPAR RPAR 
-- On COMM reduce production methodCall -> methodAccess LPAR RPAR 
-- On COL reduce production methodCall -> methodAccess LPAR RPAR 
-- On BOR reduce production methodCall -> methodAccess LPAR RPAR 
-- On BAND reduce production methodCall -> methodAccess LPAR RPAR 
-- On ASSIGN reduce production methodCall -> methodAccess LPAR RPAR 
-- On ANDEQUAL reduce production methodCall -> methodAccess LPAR RPAR 
-- On AND reduce production methodCall -> methodAccess LPAR RPAR 

State 79:
equalityExpression -> relationalExpression . [ XOR SEMI RPAR RCURL RBRAC QM OR NEQUAL EQUAL COMM COL BOR BAND AND ]
relationalExpression -> relationalExpression . LTHAN shiftExpression [ XOR SEMI RPAR RCURL RBRAC QM OR NEQUAL LTHAN LETHAN INSTANCEOF GTHAN GETHAN EQUAL COMM COL BOR BAND AND ]
relationalExpression -> relationalExpression . GTHAN shiftExpression [ XOR SEMI RPAR RCURL RBRAC QM OR NEQUAL LTHAN LETHAN INSTANCEOF GTHAN GETHAN EQUAL COMM COL BOR BAND AND ]
relationalExpression -> relationalExpression . LETHAN shiftExpression [ XOR SEMI RPAR RCURL RBRAC QM OR NEQUAL LTHAN LETHAN INSTANCEOF GTHAN GETHAN EQUAL COMM COL BOR BAND AND ]
relationalExpression -> relationalExpression . GETHAN shiftExpression [ XOR SEMI RPAR RCURL RBRAC QM OR NEQUAL LTHAN LETHAN INSTANCEOF GTHAN GETHAN EQUAL COMM COL BOR BAND AND ]
relationalExpression -> relationalExpression . INSTANCEOF typeSpecifier [ XOR SEMI RPAR RCURL RBRAC QM OR NEQUAL LTHAN LETHAN INSTANCEOF GTHAN GETHAN EQUAL COMM COL BOR BAND AND ]
-- On LTHAN shift to state 80
-- On LETHAN shift to state 97
-- On INSTANCEOF shift to state 128
-- On GTHAN shift to state 138
-- On GETHAN shift to state 149
-- On XOR reduce production equalityExpression -> relationalExpression 
-- On SEMI reduce production equalityExpression -> relationalExpression 
-- On RPAR reduce production equalityExpression -> relationalExpression 
-- On RCURL reduce production equalityExpression -> relationalExpression 
-- On RBRAC reduce production equalityExpression -> relationalExpression 
-- On QM reduce production equalityExpression -> relationalExpression 
-- On OR reduce production equalityExpression -> relationalExpression 
-- On NEQUAL reduce production equalityExpression -> relationalExpression 
-- On EQUAL reduce production equalityExpression -> relationalExpression 
-- On COMM reduce production equalityExpression -> relationalExpression 
-- On COL reduce production equalityExpression -> relationalExpression 
-- On BOR reduce production equalityExpression -> relationalExpression 
-- On BAND reduce production equalityExpression -> relationalExpression 
-- On AND reduce production equalityExpression -> relationalExpression 

State 80:
relationalExpression -> relationalExpression LTHAN . shiftExpression [ XOR SEMI RPAR RCURL RBRAC QM OR NEQUAL LTHAN LETHAN INSTANCEOF GTHAN GETHAN EQUAL COMM COL BOR BAND AND ]
-- On VOID shift to state 6
-- On THIS shift to state 7
-- On SUPER shift to state 8
-- On STRLIT shift to state 9
-- On SHORT shift to state 10
-- On PLUS shift to state 11
-- On NULLLIT shift to state 12
-- On NOT shift to state 13
-- On NEW shift to state 14
-- On MINUS shift to state 26
-- On LPAR shift to state 27
-- On LONG shift to state 15
-- On INTLIT shift to state 28
-- On INT shift to state 16
-- On INCREMENT shift to state 29
-- On IDENTIFIER shift to state 17
-- On FLOATLIT shift to state 31
-- On FLOAT shift to state 18
-- On DOUBLELIT shift to state 32
-- On DOUBLE shift to state 19
-- On DECREMENT shift to state 33
-- On CHARLIT shift to state 34
-- On CHAR shift to state 20
-- On BYTE shift to state 21
-- On BOOLEANLIT shift to state 35
-- On BOOLEAN shift to state 22
-- On BNOT shift to state 36
-- On unaryExpression shift to state 60
-- On specialName shift to state 38
-- On shiftExpression shift to state 81
-- On realPostfixExpression shift to state 39
-- On qualifiedName shift to state 42
-- On primitiveType shift to state 61
-- On primaryExpression shift to state 64
-- On postfixExpression shift to state 65
-- On plainNewAllocationExpression shift to state 68
-- On notJustName shift to state 69
-- On newAllocationExpression shift to state 72
-- On multiplicativeExpression shift to state 73
-- On methodCall shift to state 75
-- On methodAccess shift to state 76
-- On logicalUnaryOperator shift to state 83
-- On logicalUnaryExpression shift to state 85
-- On fieldAccess shift to state 86
-- On complexPrimaryNoParenthesis shift to state 87
-- On complexPrimary shift to state 88
-- On classAllocationExpression shift to state 100
-- On castExpression shift to state 103
-- On arrayAllocationExpression shift to state 104
-- On arrayAccess shift to state 120
-- On arithmeticUnaryOperator shift to state 121
-- On additiveExpression shift to state 140

State 81:
relationalExpression -> relationalExpression LTHAN shiftExpression . [ XOR SEMI RPAR RCURL RBRAC QM OR NEQUAL LTHAN LETHAN INSTANCEOF GTHAN GETHAN EQUAL COMM COL BOR BAND AND ]
shiftExpression -> shiftExpression . LSHIFT additiveExpression [ XOR SEMI RSHIFT RPAR RCURL RBRAC QM OR NEQUAL LTHAN LSHIFT LOGSHIFT LETHAN INSTANCEOF GTHAN GETHAN EQUAL COMM COL BOR BAND AND ]
shiftExpression -> shiftExpression . RSHIFT additiveExpression [ XOR SEMI RSHIFT RPAR RCURL RBRAC QM OR NEQUAL LTHAN LSHIFT LOGSHIFT LETHAN INSTANCEOF GTHAN GETHAN EQUAL COMM COL BOR BAND AND ]
shiftExpression -> shiftExpression . LOGSHIFT additiveExpression [ XOR SEMI RSHIFT RPAR RCURL RBRAC QM OR NEQUAL LTHAN LSHIFT LOGSHIFT LETHAN INSTANCEOF GTHAN GETHAN EQUAL COMM COL BOR BAND AND ]
-- On RSHIFT shift to state 59
-- On LSHIFT shift to state 82
-- On LOGSHIFT shift to state 99
-- On XOR reduce production relationalExpression -> relationalExpression LTHAN shiftExpression 
-- On SEMI reduce production relationalExpression -> relationalExpression LTHAN shiftExpression 
-- On RPAR reduce production relationalExpression -> relationalExpression LTHAN shiftExpression 
-- On RCURL reduce production relationalExpression -> relationalExpression LTHAN shiftExpression 
-- On RBRAC reduce production relationalExpression -> relationalExpression LTHAN shiftExpression 
-- On QM reduce production relationalExpression -> relationalExpression LTHAN shiftExpression 
-- On OR reduce production relationalExpression -> relationalExpression LTHAN shiftExpression 
-- On NEQUAL reduce production relationalExpression -> relationalExpression LTHAN shiftExpression 
-- On LTHAN reduce production relationalExpression -> relationalExpression LTHAN shiftExpression 
-- On LETHAN reduce production relationalExpression -> relationalExpression LTHAN shiftExpression 
-- On INSTANCEOF reduce production relationalExpression -> relationalExpression LTHAN shiftExpression 
-- On GTHAN reduce production relationalExpression -> relationalExpression LTHAN shiftExpression 
-- On GETHAN reduce production relationalExpression -> relationalExpression LTHAN shiftExpression 
-- On EQUAL reduce production relationalExpression -> relationalExpression LTHAN shiftExpression 
-- On COMM reduce production relationalExpression -> relationalExpression LTHAN shiftExpression 
-- On COL reduce production relationalExpression -> relationalExpression LTHAN shiftExpression 
-- On BOR reduce production relationalExpression -> relationalExpression LTHAN shiftExpression 
-- On BAND reduce production relationalExpression -> relationalExpression LTHAN shiftExpression 
-- On AND reduce production relationalExpression -> relationalExpression LTHAN shiftExpression 

State 82:
shiftExpression -> shiftExpression LSHIFT . additiveExpression [ XOR SEMI RSHIFT RPAR RCURL RBRAC QM OR NEQUAL LTHAN LSHIFT LOGSHIFT LETHAN INSTANCEOF GTHAN GETHAN EQUAL COMM COL BOR BAND AND ]
-- On VOID shift to state 6
-- On THIS shift to state 7
-- On SUPER shift to state 8
-- On STRLIT shift to state 9
-- On SHORT shift to state 10
-- On PLUS shift to state 11
-- On NULLLIT shift to state 12
-- On NOT shift to state 13
-- On NEW shift to state 14
-- On MINUS shift to state 26
-- On LPAR shift to state 27
-- On LONG shift to state 15
-- On INTLIT shift to state 28
-- On INT shift to state 16
-- On INCREMENT shift to state 29
-- On IDENTIFIER shift to state 17
-- On FLOATLIT shift to state 31
-- On FLOAT shift to state 18
-- On DOUBLELIT shift to state 32
-- On DOUBLE shift to state 19
-- On DECREMENT shift to state 33
-- On CHARLIT shift to state 34
-- On CHAR shift to state 20
-- On BYTE shift to state 21
-- On BOOLEANLIT shift to state 35
-- On BOOLEAN shift to state 22
-- On BNOT shift to state 36
-- On unaryExpression shift to state 60
-- On specialName shift to state 38
-- On realPostfixExpression shift to state 39
-- On qualifiedName shift to state 42
-- On primitiveType shift to state 61
-- On primaryExpression shift to state 64
-- On postfixExpression shift to state 65
-- On plainNewAllocationExpression shift to state 68
-- On notJustName shift to state 69
-- On newAllocationExpression shift to state 72
-- On multiplicativeExpression shift to state 73
-- On methodCall shift to state 75
-- On methodAccess shift to state 76
-- On logicalUnaryOperator shift to state 83
-- On logicalUnaryExpression shift to state 85
-- On fieldAccess shift to state 86
-- On complexPrimaryNoParenthesis shift to state 87
-- On complexPrimary shift to state 88
-- On classAllocationExpression shift to state 100
-- On castExpression shift to state 103
-- On arrayAllocationExpression shift to state 104
-- On arrayAccess shift to state 120
-- On arithmeticUnaryOperator shift to state 121
-- On additiveExpression shift to state 165

State 83:
logicalUnaryExpression -> logicalUnaryOperator . unaryExpression [ XOREQUAL XOR SEMI RSHIFTEQUAL RSHIFT RPAR RCURL RBRAC QM PLUS PEQUAL OREQUAL OR NEQUAL MULEQUAL MUL MODEQUAL MOD MINUSEQUAL MINUS LTHAN LSHIFTEQUAL LSHIFT LOGSHIFTEQUAL LOGSHIFT LETHAN INSTANCEOF GTHAN GETHAN EQUAL DIVEQUAL DIV COMM COL BOR BAND ASSIGN ANDEQUAL AND ]
-- On VOID shift to state 6
-- On THIS shift to state 7
-- On SUPER shift to state 8
-- On STRLIT shift to state 9
-- On SHORT shift to state 10
-- On PLUS shift to state 11
-- On NULLLIT shift to state 12
-- On NOT shift to state 13
-- On NEW shift to state 14
-- On MINUS shift to state 26
-- On LPAR shift to state 30
-- On LONG shift to state 15
-- On INTLIT shift to state 28
-- On INT shift to state 16
-- On INCREMENT shift to state 29
-- On IDENTIFIER shift to state 17
-- On FLOATLIT shift to state 31
-- On FLOAT shift to state 18
-- On DOUBLELIT shift to state 32
-- On DOUBLE shift to state 19
-- On DECREMENT shift to state 33
-- On CHARLIT shift to state 34
-- On CHAR shift to state 20
-- On BYTE shift to state 21
-- On BOOLEANLIT shift to state 35
-- On BOOLEAN shift to state 22
-- On BNOT shift to state 36
-- On unaryExpression shift to state 84
-- On specialName shift to state 38
-- On realPostfixExpression shift to state 39
-- On qualifiedName shift to state 42
-- On primitiveType shift to state 61
-- On primaryExpression shift to state 64
-- On postfixExpression shift to state 65
-- On plainNewAllocationExpression shift to state 68
-- On notJustName shift to state 69
-- On newAllocationExpression shift to state 72
-- On methodCall shift to state 75
-- On methodAccess shift to state 76
-- On logicalUnaryOperator shift to state 83
-- On logicalUnaryExpression shift to state 85
-- On fieldAccess shift to state 86
-- On complexPrimaryNoParenthesis shift to state 87
-- On complexPrimary shift to state 88
-- On classAllocationExpression shift to state 100
-- On arrayAllocationExpression shift to state 104
-- On arrayAccess shift to state 120
-- On arithmeticUnaryOperator shift to state 121

State 84:
logicalUnaryExpression -> logicalUnaryOperator unaryExpression . [ XOREQUAL XOR SEMI RSHIFTEQUAL RSHIFT RPAR RCURL RBRAC QM PLUS PEQUAL OREQUAL OR NEQUAL MULEQUAL MUL MODEQUAL MOD MINUSEQUAL MINUS LTHAN LSHIFTEQUAL LSHIFT LOGSHIFTEQUAL LOGSHIFT LETHAN INSTANCEOF GTHAN GETHAN EQUAL DIVEQUAL DIV COMM COL BOR BAND ASSIGN ANDEQUAL AND ]
-- On XOREQUAL reduce production logicalUnaryExpression -> logicalUnaryOperator unaryExpression 
-- On XOR reduce production logicalUnaryExpression -> logicalUnaryOperator unaryExpression 
-- On SEMI reduce production logicalUnaryExpression -> logicalUnaryOperator unaryExpression 
-- On RSHIFTEQUAL reduce production logicalUnaryExpression -> logicalUnaryOperator unaryExpression 
-- On RSHIFT reduce production logicalUnaryExpression -> logicalUnaryOperator unaryExpression 
-- On RPAR reduce production logicalUnaryExpression -> logicalUnaryOperator unaryExpression 
-- On RCURL reduce production logicalUnaryExpression -> logicalUnaryOperator unaryExpression 
-- On RBRAC reduce production logicalUnaryExpression -> logicalUnaryOperator unaryExpression 
-- On QM reduce production logicalUnaryExpression -> logicalUnaryOperator unaryExpression 
-- On PLUS reduce production logicalUnaryExpression -> logicalUnaryOperator unaryExpression 
-- On PEQUAL reduce production logicalUnaryExpression -> logicalUnaryOperator unaryExpression 
-- On OREQUAL reduce production logicalUnaryExpression -> logicalUnaryOperator unaryExpression 
-- On OR reduce production logicalUnaryExpression -> logicalUnaryOperator unaryExpression 
-- On NEQUAL reduce production logicalUnaryExpression -> logicalUnaryOperator unaryExpression 
-- On MULEQUAL reduce production logicalUnaryExpression -> logicalUnaryOperator unaryExpression 
-- On MUL reduce production logicalUnaryExpression -> logicalUnaryOperator unaryExpression 
-- On MODEQUAL reduce production logicalUnaryExpression -> logicalUnaryOperator unaryExpression 
-- On MOD reduce production logicalUnaryExpression -> logicalUnaryOperator unaryExpression 
-- On MINUSEQUAL reduce production logicalUnaryExpression -> logicalUnaryOperator unaryExpression 
-- On MINUS reduce production logicalUnaryExpression -> logicalUnaryOperator unaryExpression 
-- On LTHAN reduce production logicalUnaryExpression -> logicalUnaryOperator unaryExpression 
-- On LSHIFTEQUAL reduce production logicalUnaryExpression -> logicalUnaryOperator unaryExpression 
-- On LSHIFT reduce production logicalUnaryExpression -> logicalUnaryOperator unaryExpression 
-- On LOGSHIFTEQUAL reduce production logicalUnaryExpression -> logicalUnaryOperator unaryExpression 
-- On LOGSHIFT reduce production logicalUnaryExpression -> logicalUnaryOperator unaryExpression 
-- On LETHAN reduce production logicalUnaryExpression -> logicalUnaryOperator unaryExpression 
-- On INSTANCEOF reduce production logicalUnaryExpression -> logicalUnaryOperator unaryExpression 
-- On GTHAN reduce production logicalUnaryExpression -> logicalUnaryOperator unaryExpression 
-- On GETHAN reduce production logicalUnaryExpression -> logicalUnaryOperator unaryExpression 
-- On EQUAL reduce production logicalUnaryExpression -> logicalUnaryOperator unaryExpression 
-- On DIVEQUAL reduce production logicalUnaryExpression -> logicalUnaryOperator unaryExpression 
-- On DIV reduce production logicalUnaryExpression -> logicalUnaryOperator unaryExpression 
-- On COMM reduce production logicalUnaryExpression -> logicalUnaryOperator unaryExpression 
-- On COL reduce production logicalUnaryExpression -> logicalUnaryOperator unaryExpression 
-- On BOR reduce production logicalUnaryExpression -> logicalUnaryOperator unaryExpression 
-- On BAND reduce production logicalUnaryExpression -> logicalUnaryOperator unaryExpression 
-- On ASSIGN reduce production logicalUnaryExpression -> logicalUnaryOperator unaryExpression 
-- On ANDEQUAL reduce production logicalUnaryExpression -> logicalUnaryOperator unaryExpression 
-- On AND reduce production logicalUnaryExpression -> logicalUnaryOperator unaryExpression 

State 85:
unaryExpression -> logicalUnaryExpression . [ XOREQUAL XOR SEMI RSHIFTEQUAL RSHIFT RPAR RCURL RBRAC QM PLUS PEQUAL OREQUAL OR NEQUAL MULEQUAL MUL MODEQUAL MOD MINUSEQUAL MINUS LTHAN LSHIFTEQUAL LSHIFT LOGSHIFTEQUAL LOGSHIFT LETHAN INSTANCEOF GTHAN GETHAN EQUAL DIVEQUAL DIV COMM COL BOR BAND ASSIGN ANDEQUAL AND ]
-- On XOREQUAL reduce production unaryExpression -> logicalUnaryExpression 
-- On XOR reduce production unaryExpression -> logicalUnaryExpression 
-- On SEMI reduce production unaryExpression -> logicalUnaryExpression 
-- On RSHIFTEQUAL reduce production unaryExpression -> logicalUnaryExpression 
-- On RSHIFT reduce production unaryExpression -> logicalUnaryExpression 
-- On RPAR reduce production unaryExpression -> logicalUnaryExpression 
-- On RCURL reduce production unaryExpression -> logicalUnaryExpression 
-- On RBRAC reduce production unaryExpression -> logicalUnaryExpression 
-- On QM reduce production unaryExpression -> logicalUnaryExpression 
-- On PLUS reduce production unaryExpression -> logicalUnaryExpression 
-- On PEQUAL reduce production unaryExpression -> logicalUnaryExpression 
-- On OREQUAL reduce production unaryExpression -> logicalUnaryExpression 
-- On OR reduce production unaryExpression -> logicalUnaryExpression 
-- On NEQUAL reduce production unaryExpression -> logicalUnaryExpression 
-- On MULEQUAL reduce production unaryExpression -> logicalUnaryExpression 
-- On MUL reduce production unaryExpression -> logicalUnaryExpression 
-- On MODEQUAL reduce production unaryExpression -> logicalUnaryExpression 
-- On MOD reduce production unaryExpression -> logicalUnaryExpression 
-- On MINUSEQUAL reduce production unaryExpression -> logicalUnaryExpression 
-- On MINUS reduce production unaryExpression -> logicalUnaryExpression 
-- On LTHAN reduce production unaryExpression -> logicalUnaryExpression 
-- On LSHIFTEQUAL reduce production unaryExpression -> logicalUnaryExpression 
-- On LSHIFT reduce production unaryExpression -> logicalUnaryExpression 
-- On LOGSHIFTEQUAL reduce production unaryExpression -> logicalUnaryExpression 
-- On LOGSHIFT reduce production unaryExpression -> logicalUnaryExpression 
-- On LETHAN reduce production unaryExpression -> logicalUnaryExpression 
-- On INSTANCEOF reduce production unaryExpression -> logicalUnaryExpression 
-- On GTHAN reduce production unaryExpression -> logicalUnaryExpression 
-- On GETHAN reduce production unaryExpression -> logicalUnaryExpression 
-- On EQUAL reduce production unaryExpression -> logicalUnaryExpression 
-- On DIVEQUAL reduce production unaryExpression -> logicalUnaryExpression 
-- On DIV reduce production unaryExpression -> logicalUnaryExpression 
-- On COMM reduce production unaryExpression -> logicalUnaryExpression 
-- On COL reduce production unaryExpression -> logicalUnaryExpression 
-- On BOR reduce production unaryExpression -> logicalUnaryExpression 
-- On BAND reduce production unaryExpression -> logicalUnaryExpression 
-- On ASSIGN reduce production unaryExpression -> logicalUnaryExpression 
-- On ANDEQUAL reduce production unaryExpression -> logicalUnaryExpression 
-- On AND reduce production unaryExpression -> logicalUnaryExpression 

State 86:
complexPrimaryNoParenthesis -> fieldAccess . [ XOREQUAL XOR SEMI RSHIFTEQUAL RSHIFT RPAR RCURL RBRAC QM PLUS PEQUAL OREQUAL OR NEQUAL MULEQUAL MUL MODEQUAL MOD MINUSEQUAL MINUS LTHAN LSHIFTEQUAL LSHIFT LPAR LOGSHIFTEQUAL LOGSHIFT LETHAN LBRAC INSTANCEOF INCREMENT GTHAN GETHAN EQUAL DOT DIVEQUAL DIV DECREMENT COMM COL BOR BAND ASSIGN ANDEQUAL AND ]
-- On XOREQUAL reduce production complexPrimaryNoParenthesis -> fieldAccess 
-- On XOR reduce production complexPrimaryNoParenthesis -> fieldAccess 
-- On SEMI reduce production complexPrimaryNoParenthesis -> fieldAccess 
-- On RSHIFTEQUAL reduce production complexPrimaryNoParenthesis -> fieldAccess 
-- On RSHIFT reduce production complexPrimaryNoParenthesis -> fieldAccess 
-- On RPAR reduce production complexPrimaryNoParenthesis -> fieldAccess 
-- On RCURL reduce production complexPrimaryNoParenthesis -> fieldAccess 
-- On RBRAC reduce production complexPrimaryNoParenthesis -> fieldAccess 
-- On QM reduce production complexPrimaryNoParenthesis -> fieldAccess 
-- On PLUS reduce production complexPrimaryNoParenthesis -> fieldAccess 
-- On PEQUAL reduce production complexPrimaryNoParenthesis -> fieldAccess 
-- On OREQUAL reduce production complexPrimaryNoParenthesis -> fieldAccess 
-- On OR reduce production complexPrimaryNoParenthesis -> fieldAccess 
-- On NEQUAL reduce production complexPrimaryNoParenthesis -> fieldAccess 
-- On MULEQUAL reduce production complexPrimaryNoParenthesis -> fieldAccess 
-- On MUL reduce production complexPrimaryNoParenthesis -> fieldAccess 
-- On MODEQUAL reduce production complexPrimaryNoParenthesis -> fieldAccess 
-- On MOD reduce production complexPrimaryNoParenthesis -> fieldAccess 
-- On MINUSEQUAL reduce production complexPrimaryNoParenthesis -> fieldAccess 
-- On MINUS reduce production complexPrimaryNoParenthesis -> fieldAccess 
-- On LTHAN reduce production complexPrimaryNoParenthesis -> fieldAccess 
-- On LSHIFTEQUAL reduce production complexPrimaryNoParenthesis -> fieldAccess 
-- On LSHIFT reduce production complexPrimaryNoParenthesis -> fieldAccess 
-- On LPAR reduce production complexPrimaryNoParenthesis -> fieldAccess 
-- On LOGSHIFTEQUAL reduce production complexPrimaryNoParenthesis -> fieldAccess 
-- On LOGSHIFT reduce production complexPrimaryNoParenthesis -> fieldAccess 
-- On LETHAN reduce production complexPrimaryNoParenthesis -> fieldAccess 
-- On LBRAC reduce production complexPrimaryNoParenthesis -> fieldAccess 
-- On INSTANCEOF reduce production complexPrimaryNoParenthesis -> fieldAccess 
-- On INCREMENT reduce production complexPrimaryNoParenthesis -> fieldAccess 
-- On GTHAN reduce production complexPrimaryNoParenthesis -> fieldAccess 
-- On GETHAN reduce production complexPrimaryNoParenthesis -> fieldAccess 
-- On EQUAL reduce production complexPrimaryNoParenthesis -> fieldAccess 
-- On DOT reduce production complexPrimaryNoParenthesis -> fieldAccess 
-- On DIVEQUAL reduce production complexPrimaryNoParenthesis -> fieldAccess 
-- On DIV reduce production complexPrimaryNoParenthesis -> fieldAccess 
-- On DECREMENT reduce production complexPrimaryNoParenthesis -> fieldAccess 
-- On COMM reduce production complexPrimaryNoParenthesis -> fieldAccess 
-- On COL reduce production complexPrimaryNoParenthesis -> fieldAccess 
-- On BOR reduce production complexPrimaryNoParenthesis -> fieldAccess 
-- On BAND reduce production complexPrimaryNoParenthesis -> fieldAccess 
-- On ASSIGN reduce production complexPrimaryNoParenthesis -> fieldAccess 
-- On ANDEQUAL reduce production complexPrimaryNoParenthesis -> fieldAccess 
-- On AND reduce production complexPrimaryNoParenthesis -> fieldAccess 

State 87:
complexPrimary -> complexPrimaryNoParenthesis . [ XOREQUAL XOR SEMI RSHIFTEQUAL RSHIFT RPAR RCURL RBRAC QM PLUS PEQUAL OREQUAL OR NEQUAL MULEQUAL MUL MODEQUAL MOD MINUSEQUAL MINUS LTHAN LSHIFTEQUAL LSHIFT LOGSHIFTEQUAL LOGSHIFT LETHAN LBRAC INSTANCEOF INCREMENT GTHAN GETHAN EQUAL DOT DIVEQUAL DIV DECREMENT COMM COL BOR BAND ASSIGN ANDEQUAL AND ]
methodAccess -> complexPrimaryNoParenthesis . [ LPAR ]
-- On XOREQUAL reduce production complexPrimary -> complexPrimaryNoParenthesis 
-- On XOR reduce production complexPrimary -> complexPrimaryNoParenthesis 
-- On SEMI reduce production complexPrimary -> complexPrimaryNoParenthesis 
-- On RSHIFTEQUAL reduce production complexPrimary -> complexPrimaryNoParenthesis 
-- On RSHIFT reduce production complexPrimary -> complexPrimaryNoParenthesis 
-- On RPAR reduce production complexPrimary -> complexPrimaryNoParenthesis 
-- On RCURL reduce production complexPrimary -> complexPrimaryNoParenthesis 
-- On RBRAC reduce production complexPrimary -> complexPrimaryNoParenthesis 
-- On QM reduce production complexPrimary -> complexPrimaryNoParenthesis 
-- On PLUS reduce production complexPrimary -> complexPrimaryNoParenthesis 
-- On PEQUAL reduce production complexPrimary -> complexPrimaryNoParenthesis 
-- On OREQUAL reduce production complexPrimary -> complexPrimaryNoParenthesis 
-- On OR reduce production complexPrimary -> complexPrimaryNoParenthesis 
-- On NEQUAL reduce production complexPrimary -> complexPrimaryNoParenthesis 
-- On MULEQUAL reduce production complexPrimary -> complexPrimaryNoParenthesis 
-- On MUL reduce production complexPrimary -> complexPrimaryNoParenthesis 
-- On MODEQUAL reduce production complexPrimary -> complexPrimaryNoParenthesis 
-- On MOD reduce production complexPrimary -> complexPrimaryNoParenthesis 
-- On MINUSEQUAL reduce production complexPrimary -> complexPrimaryNoParenthesis 
-- On MINUS reduce production complexPrimary -> complexPrimaryNoParenthesis 
-- On LTHAN reduce production complexPrimary -> complexPrimaryNoParenthesis 
-- On LSHIFTEQUAL reduce production complexPrimary -> complexPrimaryNoParenthesis 
-- On LSHIFT reduce production complexPrimary -> complexPrimaryNoParenthesis 
-- On LPAR reduce production methodAccess -> complexPrimaryNoParenthesis 
-- On LOGSHIFTEQUAL reduce production complexPrimary -> complexPrimaryNoParenthesis 
-- On LOGSHIFT reduce production complexPrimary -> complexPrimaryNoParenthesis 
-- On LETHAN reduce production complexPrimary -> complexPrimaryNoParenthesis 
-- On LBRAC reduce production complexPrimary -> complexPrimaryNoParenthesis 
-- On INSTANCEOF reduce production complexPrimary -> complexPrimaryNoParenthesis 
-- On INCREMENT reduce production complexPrimary -> complexPrimaryNoParenthesis 
-- On GTHAN reduce production complexPrimary -> complexPrimaryNoParenthesis 
-- On GETHAN reduce production complexPrimary -> complexPrimaryNoParenthesis 
-- On EQUAL reduce production complexPrimary -> complexPrimaryNoParenthesis 
-- On DOT reduce production complexPrimary -> complexPrimaryNoParenthesis 
-- On DIVEQUAL reduce production complexPrimary -> complexPrimaryNoParenthesis 
-- On DIV reduce production complexPrimary -> complexPrimaryNoParenthesis 
-- On DECREMENT reduce production complexPrimary -> complexPrimaryNoParenthesis 
-- On COMM reduce production complexPrimary -> complexPrimaryNoParenthesis 
-- On COL reduce production complexPrimary -> complexPrimaryNoParenthesis 
-- On BOR reduce production complexPrimary -> complexPrimaryNoParenthesis 
-- On BAND reduce production complexPrimary -> complexPrimaryNoParenthesis 
-- On ASSIGN reduce production complexPrimary -> complexPrimaryNoParenthesis 
-- On ANDEQUAL reduce production complexPrimary -> complexPrimaryNoParenthesis 
-- On AND reduce production complexPrimary -> complexPrimaryNoParenthesis 

State 88:
arrayAccess -> complexPrimary . LBRAC expression RBRAC [ XOREQUAL XOR SEMI RSHIFTEQUAL RSHIFT RPAR RCURL RBRAC QM PLUS PEQUAL OREQUAL OR NEQUAL MULEQUAL MUL MODEQUAL MOD MINUSEQUAL MINUS LTHAN LSHIFTEQUAL LSHIFT LPAR LOGSHIFTEQUAL LOGSHIFT LETHAN LBRAC INSTANCEOF INCREMENT GTHAN GETHAN EQUAL DOT DIVEQUAL DIV DECREMENT COMM COL BOR BAND ASSIGN ANDEQUAL AND ]
notJustName -> complexPrimary . [ XOREQUAL XOR SEMI RSHIFTEQUAL RSHIFT RPAR RCURL RBRAC QM PLUS PEQUAL OREQUAL OR NEQUAL MULEQUAL MUL MODEQUAL MOD MINUSEQUAL MINUS LTHAN LSHIFTEQUAL LSHIFT LOGSHIFTEQUAL LOGSHIFT LETHAN INSTANCEOF INCREMENT GTHAN GETHAN EQUAL DOT DIVEQUAL DIV DECREMENT COMM COL BOR BAND ASSIGN ANDEQUAL AND ]
-- On LBRAC shift to state 89
-- On XOREQUAL reduce production notJustName -> complexPrimary 
-- On XOR reduce production notJustName -> complexPrimary 
-- On SEMI reduce production notJustName -> complexPrimary 
-- On RSHIFTEQUAL reduce production notJustName -> complexPrimary 
-- On RSHIFT reduce production notJustName -> complexPrimary 
-- On RPAR reduce production notJustName -> complexPrimary 
-- On RCURL reduce production notJustName -> complexPrimary 
-- On RBRAC reduce production notJustName -> complexPrimary 
-- On QM reduce production notJustName -> complexPrimary 
-- On PLUS reduce production notJustName -> complexPrimary 
-- On PEQUAL reduce production notJustName -> complexPrimary 
-- On OREQUAL reduce production notJustName -> complexPrimary 
-- On OR reduce production notJustName -> complexPrimary 
-- On NEQUAL reduce production notJustName -> complexPrimary 
-- On MULEQUAL reduce production notJustName -> complexPrimary 
-- On MUL reduce production notJustName -> complexPrimary 
-- On MODEQUAL reduce production notJustName -> complexPrimary 
-- On MOD reduce production notJustName -> complexPrimary 
-- On MINUSEQUAL reduce production notJustName -> complexPrimary 
-- On MINUS reduce production notJustName -> complexPrimary 
-- On LTHAN reduce production notJustName -> complexPrimary 
-- On LSHIFTEQUAL reduce production notJustName -> complexPrimary 
-- On LSHIFT reduce production notJustName -> complexPrimary 
-- On LOGSHIFTEQUAL reduce production notJustName -> complexPrimary 
-- On LOGSHIFT reduce production notJustName -> complexPrimary 
-- On LETHAN reduce production notJustName -> complexPrimary 
-- On INSTANCEOF reduce production notJustName -> complexPrimary 
-- On INCREMENT reduce production notJustName -> complexPrimary 
-- On GTHAN reduce production notJustName -> complexPrimary 
-- On GETHAN reduce production notJustName -> complexPrimary 
-- On EQUAL reduce production notJustName -> complexPrimary 
-- On DOT reduce production notJustName -> complexPrimary 
-- On DIVEQUAL reduce production notJustName -> complexPrimary 
-- On DIV reduce production notJustName -> complexPrimary 
-- On DECREMENT reduce production notJustName -> complexPrimary 
-- On COMM reduce production notJustName -> complexPrimary 
-- On COL reduce production notJustName -> complexPrimary 
-- On BOR reduce production notJustName -> complexPrimary 
-- On BAND reduce production notJustName -> complexPrimary 
-- On ASSIGN reduce production notJustName -> complexPrimary 
-- On ANDEQUAL reduce production notJustName -> complexPrimary 
-- On AND reduce production notJustName -> complexPrimary 

State 89:
arrayAccess -> complexPrimary LBRAC . expression RBRAC [ XOREQUAL XOR SEMI RSHIFTEQUAL RSHIFT RPAR RCURL RBRAC QM PLUS PEQUAL OREQUAL OR NEQUAL MULEQUAL MUL MODEQUAL MOD MINUSEQUAL MINUS LTHAN LSHIFTEQUAL LSHIFT LPAR LOGSHIFTEQUAL LOGSHIFT LETHAN LBRAC INSTANCEOF INCREMENT GTHAN GETHAN EQUAL DOT DIVEQUAL DIV DECREMENT COMM COL BOR BAND ASSIGN ANDEQUAL AND ]
-- On error shift to state 3
-- On VOID shift to state 6
-- On THIS shift to state 7
-- On SUPER shift to state 8
-- On STRLIT shift to state 9
-- On SHORT shift to state 10
-- On PLUS shift to state 11
-- On NULLLIT shift to state 12
-- On NOT shift to state 13
-- On NEW shift to state 14
-- On MINUS shift to state 26
-- On LPAR shift to state 27
-- On LONG shift to state 15
-- On INTLIT shift to state 28
-- On INT shift to state 16
-- On INCREMENT shift to state 29
-- On IDENTIFIER shift to state 17
-- On FLOATLIT shift to state 31
-- On FLOAT shift to state 18
-- On DOUBLELIT shift to state 32
-- On DOUBLE shift to state 19
-- On DECREMENT shift to state 33
-- On CHARLIT shift to state 34
-- On CHAR shift to state 20
-- On BYTE shift to state 21
-- On BOOLEANLIT shift to state 35
-- On BOOLEAN shift to state 22
-- On BNOT shift to state 36
-- On unaryExpression shift to state 44
-- On specialName shift to state 38
-- On shiftExpression shift to state 58
-- On relationalExpression shift to state 79
-- On realPostfixExpression shift to state 39
-- On qualifiedName shift to state 42
-- On primitiveType shift to state 61
-- On primaryExpression shift to state 64
-- On postfixExpression shift to state 65
-- On plainNewAllocationExpression shift to state 68
-- On notJustName shift to state 69
-- On newAllocationExpression shift to state 72
-- On multiplicativeExpression shift to state 73
-- On methodCall shift to state 75
-- On methodAccess shift to state 76
-- On logicalUnaryOperator shift to state 83
-- On logicalUnaryExpression shift to state 85
-- On inclusiveOrExpression shift to state 90
-- On fieldAccess shift to state 86
-- On expression shift to state 163
-- On exclusiveOrExpression shift to state 111
-- On equalityExpression shift to state 94
-- On conditionalOrExpression shift to state 112
-- On conditionalExpression shift to state 151
-- On conditionalAndExpression shift to state 117
-- On complexPrimaryNoParenthesis shift to state 87
-- On complexPrimary shift to state 88
-- On classAllocationExpression shift to state 100
-- On castExpression shift to state 103
-- On assignmentExpression shift to state 152
-- On arrayAllocationExpression shift to state 104
-- On arrayAccess shift to state 120
-- On arithmeticUnaryOperator shift to state 121
-- On andExpression shift to state 123
-- On additiveExpression shift to state 140

State 90:
conditionalAndExpression -> inclusiveOrExpression . [ SEMI RPAR RCURL RBRAC QM OR COMM COL AND ]
inclusiveOrExpression -> inclusiveOrExpression . BOR exclusiveOrExpression [ SEMI RPAR RCURL RBRAC QM OR COMM COL BOR AND ]
-- On BOR shift to state 91
-- On SEMI reduce production conditionalAndExpression -> inclusiveOrExpression 
-- On RPAR reduce production conditionalAndExpression -> inclusiveOrExpression 
-- On RCURL reduce production conditionalAndExpression -> inclusiveOrExpression 
-- On RBRAC reduce production conditionalAndExpression -> inclusiveOrExpression 
-- On QM reduce production conditionalAndExpression -> inclusiveOrExpression 
-- On OR reduce production conditionalAndExpression -> inclusiveOrExpression 
-- On COMM reduce production conditionalAndExpression -> inclusiveOrExpression 
-- On COL reduce production conditionalAndExpression -> inclusiveOrExpression 
-- On AND reduce production conditionalAndExpression -> inclusiveOrExpression 

State 91:
inclusiveOrExpression -> inclusiveOrExpression BOR . exclusiveOrExpression [ SEMI RPAR RCURL RBRAC QM OR COMM COL BOR AND ]
-- On VOID shift to state 6
-- On THIS shift to state 7
-- On SUPER shift to state 8
-- On STRLIT shift to state 9
-- On SHORT shift to state 10
-- On PLUS shift to state 11
-- On NULLLIT shift to state 12
-- On NOT shift to state 13
-- On NEW shift to state 14
-- On MINUS shift to state 26
-- On LPAR shift to state 27
-- On LONG shift to state 15
-- On INTLIT shift to state 28
-- On INT shift to state 16
-- On INCREMENT shift to state 29
-- On IDENTIFIER shift to state 17
-- On FLOATLIT shift to state 31
-- On FLOAT shift to state 18
-- On DOUBLELIT shift to state 32
-- On DOUBLE shift to state 19
-- On DECREMENT shift to state 33
-- On CHARLIT shift to state 34
-- On CHAR shift to state 20
-- On BYTE shift to state 21
-- On BOOLEANLIT shift to state 35
-- On BOOLEAN shift to state 22
-- On BNOT shift to state 36
-- On unaryExpression shift to state 60
-- On specialName shift to state 38
-- On shiftExpression shift to state 58
-- On relationalExpression shift to state 79
-- On realPostfixExpression shift to state 39
-- On qualifiedName shift to state 42
-- On primitiveType shift to state 61
-- On primaryExpression shift to state 64
-- On postfixExpression shift to state 65
-- On plainNewAllocationExpression shift to state 68
-- On notJustName shift to state 69
-- On newAllocationExpression shift to state 72
-- On multiplicativeExpression shift to state 73
-- On methodCall shift to state 75
-- On methodAccess shift to state 76
-- On logicalUnaryOperator shift to state 83
-- On logicalUnaryExpression shift to state 85
-- On fieldAccess shift to state 86
-- On exclusiveOrExpression shift to state 92
-- On equalityExpression shift to state 94
-- On complexPrimaryNoParenthesis shift to state 87
-- On complexPrimary shift to state 88
-- On classAllocationExpression shift to state 100
-- On castExpression shift to state 103
-- On arrayAllocationExpression shift to state 104
-- On arrayAccess shift to state 120
-- On arithmeticUnaryOperator shift to state 121
-- On andExpression shift to state 123
-- On additiveExpression shift to state 140

State 92:
exclusiveOrExpression -> exclusiveOrExpression . XOR andExpression [ XOR SEMI RPAR RCURL RBRAC QM OR COMM COL BOR AND ]
inclusiveOrExpression -> inclusiveOrExpression BOR exclusiveOrExpression . [ SEMI RPAR RCURL RBRAC QM OR COMM COL BOR AND ]
-- On XOR shift to state 93
-- On SEMI reduce production inclusiveOrExpression -> inclusiveOrExpression BOR exclusiveOrExpression 
-- On RPAR reduce production inclusiveOrExpression -> inclusiveOrExpression BOR exclusiveOrExpression 
-- On RCURL reduce production inclusiveOrExpression -> inclusiveOrExpression BOR exclusiveOrExpression 
-- On RBRAC reduce production inclusiveOrExpression -> inclusiveOrExpression BOR exclusiveOrExpression 
-- On QM reduce production inclusiveOrExpression -> inclusiveOrExpression BOR exclusiveOrExpression 
-- On OR reduce production inclusiveOrExpression -> inclusiveOrExpression BOR exclusiveOrExpression 
-- On COMM reduce production inclusiveOrExpression -> inclusiveOrExpression BOR exclusiveOrExpression 
-- On COL reduce production inclusiveOrExpression -> inclusiveOrExpression BOR exclusiveOrExpression 
-- On BOR reduce production inclusiveOrExpression -> inclusiveOrExpression BOR exclusiveOrExpression 
-- On AND reduce production inclusiveOrExpression -> inclusiveOrExpression BOR exclusiveOrExpression 

State 93:
exclusiveOrExpression -> exclusiveOrExpression XOR . andExpression [ XOR SEMI RPAR RCURL RBRAC QM OR COMM COL BOR AND ]
-- On VOID shift to state 6
-- On THIS shift to state 7
-- On SUPER shift to state 8
-- On STRLIT shift to state 9
-- On SHORT shift to state 10
-- On PLUS shift to state 11
-- On NULLLIT shift to state 12
-- On NOT shift to state 13
-- On NEW shift to state 14
-- On MINUS shift to state 26
-- On LPAR shift to state 27
-- On LONG shift to state 15
-- On INTLIT shift to state 28
-- On INT shift to state 16
-- On INCREMENT shift to state 29
-- On IDENTIFIER shift to state 17
-- On FLOATLIT shift to state 31
-- On FLOAT shift to state 18
-- On DOUBLELIT shift to state 32
-- On DOUBLE shift to state 19
-- On DECREMENT shift to state 33
-- On CHARLIT shift to state 34
-- On CHAR shift to state 20
-- On BYTE shift to state 21
-- On BOOLEANLIT shift to state 35
-- On BOOLEAN shift to state 22
-- On BNOT shift to state 36
-- On unaryExpression shift to state 60
-- On specialName shift to state 38
-- On shiftExpression shift to state 58
-- On relationalExpression shift to state 79
-- On realPostfixExpression shift to state 39
-- On qualifiedName shift to state 42
-- On primitiveType shift to state 61
-- On primaryExpression shift to state 64
-- On postfixExpression shift to state 65
-- On plainNewAllocationExpression shift to state 68
-- On notJustName shift to state 69
-- On newAllocationExpression shift to state 72
-- On multiplicativeExpression shift to state 73
-- On methodCall shift to state 75
-- On methodAccess shift to state 76
-- On logicalUnaryOperator shift to state 83
-- On logicalUnaryExpression shift to state 85
-- On fieldAccess shift to state 86
-- On equalityExpression shift to state 94
-- On complexPrimaryNoParenthesis shift to state 87
-- On complexPrimary shift to state 88
-- On classAllocationExpression shift to state 100
-- On castExpression shift to state 103
-- On arrayAllocationExpression shift to state 104
-- On arrayAccess shift to state 120
-- On arithmeticUnaryOperator shift to state 121
-- On andExpression shift to state 162
-- On additiveExpression shift to state 140

State 94:
andExpression -> equalityExpression . [ XOR SEMI RPAR RCURL RBRAC QM OR COMM COL BOR BAND AND ]
equalityExpression -> equalityExpression . EQUAL relationalExpression [ XOR SEMI RPAR RCURL RBRAC QM OR NEQUAL EQUAL COMM COL BOR BAND AND ]
equalityExpression -> equalityExpression . NEQUAL relationalExpression [ XOR SEMI RPAR RCURL RBRAC QM OR NEQUAL EQUAL COMM COL BOR BAND AND ]
-- On NEQUAL shift to state 95
-- On EQUAL shift to state 126
-- On XOR reduce production andExpression -> equalityExpression 
-- On SEMI reduce production andExpression -> equalityExpression 
-- On RPAR reduce production andExpression -> equalityExpression 
-- On RCURL reduce production andExpression -> equalityExpression 
-- On RBRAC reduce production andExpression -> equalityExpression 
-- On QM reduce production andExpression -> equalityExpression 
-- On OR reduce production andExpression -> equalityExpression 
-- On COMM reduce production andExpression -> equalityExpression 
-- On COL reduce production andExpression -> equalityExpression 
-- On BOR reduce production andExpression -> equalityExpression 
-- On BAND reduce production andExpression -> equalityExpression 
-- On AND reduce production andExpression -> equalityExpression 

State 95:
equalityExpression -> equalityExpression NEQUAL . relationalExpression [ XOR SEMI RPAR RCURL RBRAC QM OR NEQUAL EQUAL COMM COL BOR BAND AND ]
-- On VOID shift to state 6
-- On THIS shift to state 7
-- On SUPER shift to state 8
-- On STRLIT shift to state 9
-- On SHORT shift to state 10
-- On PLUS shift to state 11
-- On NULLLIT shift to state 12
-- On NOT shift to state 13
-- On NEW shift to state 14
-- On MINUS shift to state 26
-- On LPAR shift to state 27
-- On LONG shift to state 15
-- On INTLIT shift to state 28
-- On INT shift to state 16
-- On INCREMENT shift to state 29
-- On IDENTIFIER shift to state 17
-- On FLOATLIT shift to state 31
-- On FLOAT shift to state 18
-- On DOUBLELIT shift to state 32
-- On DOUBLE shift to state 19
-- On DECREMENT shift to state 33
-- On CHARLIT shift to state 34
-- On CHAR shift to state 20
-- On BYTE shift to state 21
-- On BOOLEANLIT shift to state 35
-- On BOOLEAN shift to state 22
-- On BNOT shift to state 36
-- On unaryExpression shift to state 60
-- On specialName shift to state 38
-- On shiftExpression shift to state 58
-- On relationalExpression shift to state 96
-- On realPostfixExpression shift to state 39
-- On qualifiedName shift to state 42
-- On primitiveType shift to state 61
-- On primaryExpression shift to state 64
-- On postfixExpression shift to state 65
-- On plainNewAllocationExpression shift to state 68
-- On notJustName shift to state 69
-- On newAllocationExpression shift to state 72
-- On multiplicativeExpression shift to state 73
-- On methodCall shift to state 75
-- On methodAccess shift to state 76
-- On logicalUnaryOperator shift to state 83
-- On logicalUnaryExpression shift to state 85
-- On fieldAccess shift to state 86
-- On complexPrimaryNoParenthesis shift to state 87
-- On complexPrimary shift to state 88
-- On classAllocationExpression shift to state 100
-- On castExpression shift to state 103
-- On arrayAllocationExpression shift to state 104
-- On arrayAccess shift to state 120
-- On arithmeticUnaryOperator shift to state 121
-- On additiveExpression shift to state 140

State 96:
equalityExpression -> equalityExpression NEQUAL relationalExpression . [ XOR SEMI RPAR RCURL RBRAC QM OR NEQUAL EQUAL COMM COL BOR BAND AND ]
relationalExpression -> relationalExpression . LTHAN shiftExpression [ XOR SEMI RPAR RCURL RBRAC QM OR NEQUAL LTHAN LETHAN INSTANCEOF GTHAN GETHAN EQUAL COMM COL BOR BAND AND ]
relationalExpression -> relationalExpression . GTHAN shiftExpression [ XOR SEMI RPAR RCURL RBRAC QM OR NEQUAL LTHAN LETHAN INSTANCEOF GTHAN GETHAN EQUAL COMM COL BOR BAND AND ]
relationalExpression -> relationalExpression . LETHAN shiftExpression [ XOR SEMI RPAR RCURL RBRAC QM OR NEQUAL LTHAN LETHAN INSTANCEOF GTHAN GETHAN EQUAL COMM COL BOR BAND AND ]
relationalExpression -> relationalExpression . GETHAN shiftExpression [ XOR SEMI RPAR RCURL RBRAC QM OR NEQUAL LTHAN LETHAN INSTANCEOF GTHAN GETHAN EQUAL COMM COL BOR BAND AND ]
relationalExpression -> relationalExpression . INSTANCEOF typeSpecifier [ XOR SEMI RPAR RCURL RBRAC QM OR NEQUAL LTHAN LETHAN INSTANCEOF GTHAN GETHAN EQUAL COMM COL BOR BAND AND ]
-- On LTHAN shift to state 80
-- On LETHAN shift to state 97
-- On INSTANCEOF shift to state 128
-- On GTHAN shift to state 138
-- On GETHAN shift to state 149
-- On XOR reduce production equalityExpression -> equalityExpression NEQUAL relationalExpression 
-- On SEMI reduce production equalityExpression -> equalityExpression NEQUAL relationalExpression 
-- On RPAR reduce production equalityExpression -> equalityExpression NEQUAL relationalExpression 
-- On RCURL reduce production equalityExpression -> equalityExpression NEQUAL relationalExpression 
-- On RBRAC reduce production equalityExpression -> equalityExpression NEQUAL relationalExpression 
-- On QM reduce production equalityExpression -> equalityExpression NEQUAL relationalExpression 
-- On OR reduce production equalityExpression -> equalityExpression NEQUAL relationalExpression 
-- On NEQUAL reduce production equalityExpression -> equalityExpression NEQUAL relationalExpression 
-- On EQUAL reduce production equalityExpression -> equalityExpression NEQUAL relationalExpression 
-- On COMM reduce production equalityExpression -> equalityExpression NEQUAL relationalExpression 
-- On COL reduce production equalityExpression -> equalityExpression NEQUAL relationalExpression 
-- On BOR reduce production equalityExpression -> equalityExpression NEQUAL relationalExpression 
-- On BAND reduce production equalityExpression -> equalityExpression NEQUAL relationalExpression 
-- On AND reduce production equalityExpression -> equalityExpression NEQUAL relationalExpression 

State 97:
relationalExpression -> relationalExpression LETHAN . shiftExpression [ XOR SEMI RPAR RCURL RBRAC QM OR NEQUAL LTHAN LETHAN INSTANCEOF GTHAN GETHAN EQUAL COMM COL BOR BAND AND ]
-- On VOID shift to state 6
-- On THIS shift to state 7
-- On SUPER shift to state 8
-- On STRLIT shift to state 9
-- On SHORT shift to state 10
-- On PLUS shift to state 11
-- On NULLLIT shift to state 12
-- On NOT shift to state 13
-- On NEW shift to state 14
-- On MINUS shift to state 26
-- On LPAR shift to state 27
-- On LONG shift to state 15
-- On INTLIT shift to state 28
-- On INT shift to state 16
-- On INCREMENT shift to state 29
-- On IDENTIFIER shift to state 17
-- On FLOATLIT shift to state 31
-- On FLOAT shift to state 18
-- On DOUBLELIT shift to state 32
-- On DOUBLE shift to state 19
-- On DECREMENT shift to state 33
-- On CHARLIT shift to state 34
-- On CHAR shift to state 20
-- On BYTE shift to state 21
-- On BOOLEANLIT shift to state 35
-- On BOOLEAN shift to state 22
-- On BNOT shift to state 36
-- On unaryExpression shift to state 60
-- On specialName shift to state 38
-- On shiftExpression shift to state 98
-- On realPostfixExpression shift to state 39
-- On qualifiedName shift to state 42
-- On primitiveType shift to state 61
-- On primaryExpression shift to state 64
-- On postfixExpression shift to state 65
-- On plainNewAllocationExpression shift to state 68
-- On notJustName shift to state 69
-- On newAllocationExpression shift to state 72
-- On multiplicativeExpression shift to state 73
-- On methodCall shift to state 75
-- On methodAccess shift to state 76
-- On logicalUnaryOperator shift to state 83
-- On logicalUnaryExpression shift to state 85
-- On fieldAccess shift to state 86
-- On complexPrimaryNoParenthesis shift to state 87
-- On complexPrimary shift to state 88
-- On classAllocationExpression shift to state 100
-- On castExpression shift to state 103
-- On arrayAllocationExpression shift to state 104
-- On arrayAccess shift to state 120
-- On arithmeticUnaryOperator shift to state 121
-- On additiveExpression shift to state 140

State 98:
relationalExpression -> relationalExpression LETHAN shiftExpression . [ XOR SEMI RPAR RCURL RBRAC QM OR NEQUAL LTHAN LETHAN INSTANCEOF GTHAN GETHAN EQUAL COMM COL BOR BAND AND ]
shiftExpression -> shiftExpression . LSHIFT additiveExpression [ XOR SEMI RSHIFT RPAR RCURL RBRAC QM OR NEQUAL LTHAN LSHIFT LOGSHIFT LETHAN INSTANCEOF GTHAN GETHAN EQUAL COMM COL BOR BAND AND ]
shiftExpression -> shiftExpression . RSHIFT additiveExpression [ XOR SEMI RSHIFT RPAR RCURL RBRAC QM OR NEQUAL LTHAN LSHIFT LOGSHIFT LETHAN INSTANCEOF GTHAN GETHAN EQUAL COMM COL BOR BAND AND ]
shiftExpression -> shiftExpression . LOGSHIFT additiveExpression [ XOR SEMI RSHIFT RPAR RCURL RBRAC QM OR NEQUAL LTHAN LSHIFT LOGSHIFT LETHAN INSTANCEOF GTHAN GETHAN EQUAL COMM COL BOR BAND AND ]
-- On RSHIFT shift to state 59
-- On LSHIFT shift to state 82
-- On LOGSHIFT shift to state 99
-- On XOR reduce production relationalExpression -> relationalExpression LETHAN shiftExpression 
-- On SEMI reduce production relationalExpression -> relationalExpression LETHAN shiftExpression 
-- On RPAR reduce production relationalExpression -> relationalExpression LETHAN shiftExpression 
-- On RCURL reduce production relationalExpression -> relationalExpression LETHAN shiftExpression 
-- On RBRAC reduce production relationalExpression -> relationalExpression LETHAN shiftExpression 
-- On QM reduce production relationalExpression -> relationalExpression LETHAN shiftExpression 
-- On OR reduce production relationalExpression -> relationalExpression LETHAN shiftExpression 
-- On NEQUAL reduce production relationalExpression -> relationalExpression LETHAN shiftExpression 
-- On LTHAN reduce production relationalExpression -> relationalExpression LETHAN shiftExpression 
-- On LETHAN reduce production relationalExpression -> relationalExpression LETHAN shiftExpression 
-- On INSTANCEOF reduce production relationalExpression -> relationalExpression LETHAN shiftExpression 
-- On GTHAN reduce production relationalExpression -> relationalExpression LETHAN shiftExpression 
-- On GETHAN reduce production relationalExpression -> relationalExpression LETHAN shiftExpression 
-- On EQUAL reduce production relationalExpression -> relationalExpression LETHAN shiftExpression 
-- On COMM reduce production relationalExpression -> relationalExpression LETHAN shiftExpression 
-- On COL reduce production relationalExpression -> relationalExpression LETHAN shiftExpression 
-- On BOR reduce production relationalExpression -> relationalExpression LETHAN shiftExpression 
-- On BAND reduce production relationalExpression -> relationalExpression LETHAN shiftExpression 
-- On AND reduce production relationalExpression -> relationalExpression LETHAN shiftExpression 

State 99:
shiftExpression -> shiftExpression LOGSHIFT . additiveExpression [ XOR SEMI RSHIFT RPAR RCURL RBRAC QM OR NEQUAL LTHAN LSHIFT LOGSHIFT LETHAN INSTANCEOF GTHAN GETHAN EQUAL COMM COL BOR BAND AND ]
-- On VOID shift to state 6
-- On THIS shift to state 7
-- On SUPER shift to state 8
-- On STRLIT shift to state 9
-- On SHORT shift to state 10
-- On PLUS shift to state 11
-- On NULLLIT shift to state 12
-- On NOT shift to state 13
-- On NEW shift to state 14
-- On MINUS shift to state 26
-- On LPAR shift to state 27
-- On LONG shift to state 15
-- On INTLIT shift to state 28
-- On INT shift to state 16
-- On INCREMENT shift to state 29
-- On IDENTIFIER shift to state 17
-- On FLOATLIT shift to state 31
-- On FLOAT shift to state 18
-- On DOUBLELIT shift to state 32
-- On DOUBLE shift to state 19
-- On DECREMENT shift to state 33
-- On CHARLIT shift to state 34
-- On CHAR shift to state 20
-- On BYTE shift to state 21
-- On BOOLEANLIT shift to state 35
-- On BOOLEAN shift to state 22
-- On BNOT shift to state 36
-- On unaryExpression shift to state 60
-- On specialName shift to state 38
-- On realPostfixExpression shift to state 39
-- On qualifiedName shift to state 42
-- On primitiveType shift to state 61
-- On primaryExpression shift to state 64
-- On postfixExpression shift to state 65
-- On plainNewAllocationExpression shift to state 68
-- On notJustName shift to state 69
-- On newAllocationExpression shift to state 72
-- On multiplicativeExpression shift to state 73
-- On methodCall shift to state 75
-- On methodAccess shift to state 76
-- On logicalUnaryOperator shift to state 83
-- On logicalUnaryExpression shift to state 85
-- On fieldAccess shift to state 86
-- On complexPrimaryNoParenthesis shift to state 87
-- On complexPrimary shift to state 88
-- On classAllocationExpression shift to state 100
-- On castExpression shift to state 103
-- On arrayAllocationExpression shift to state 104
-- On arrayAccess shift to state 120
-- On arithmeticUnaryOperator shift to state 121
-- On additiveExpression shift to state 161

State 100:
plainNewAllocationExpression -> classAllocationExpression . [ XOREQUAL XOR SEMI RSHIFTEQUAL RSHIFT RPAR RCURL RBRAC QM PLUS PEQUAL OREQUAL OR NEQUAL MULEQUAL MUL MODEQUAL MOD MINUSEQUAL MINUS LTHAN LSHIFTEQUAL LSHIFT LOGSHIFTEQUAL LOGSHIFT LETHAN INSTANCEOF INCREMENT GTHAN GETHAN EQUAL DOT DIVEQUAL DIV DECREMENT COMM COL BOR BAND ASSIGN ANDEQUAL AND ]
plainNewAllocationExpression -> classAllocationExpression . LCURL RCURL [ XOREQUAL XOR SEMI RSHIFTEQUAL RSHIFT RPAR RCURL RBRAC QM PLUS PEQUAL OREQUAL OR NEQUAL MULEQUAL MUL MODEQUAL MOD MINUSEQUAL MINUS LTHAN LSHIFTEQUAL LSHIFT LOGSHIFTEQUAL LOGSHIFT LETHAN INSTANCEOF INCREMENT GTHAN GETHAN EQUAL DOT DIVEQUAL DIV DECREMENT COMM COL BOR BAND ASSIGN ANDEQUAL AND ]
-- On LCURL shift to state 101
-- On XOREQUAL reduce production plainNewAllocationExpression -> classAllocationExpression 
-- On XOR reduce production plainNewAllocationExpression -> classAllocationExpression 
-- On SEMI reduce production plainNewAllocationExpression -> classAllocationExpression 
-- On RSHIFTEQUAL reduce production plainNewAllocationExpression -> classAllocationExpression 
-- On RSHIFT reduce production plainNewAllocationExpression -> classAllocationExpression 
-- On RPAR reduce production plainNewAllocationExpression -> classAllocationExpression 
-- On RCURL reduce production plainNewAllocationExpression -> classAllocationExpression 
-- On RBRAC reduce production plainNewAllocationExpression -> classAllocationExpression 
-- On QM reduce production plainNewAllocationExpression -> classAllocationExpression 
-- On PLUS reduce production plainNewAllocationExpression -> classAllocationExpression 
-- On PEQUAL reduce production plainNewAllocationExpression -> classAllocationExpression 
-- On OREQUAL reduce production plainNewAllocationExpression -> classAllocationExpression 
-- On OR reduce production plainNewAllocationExpression -> classAllocationExpression 
-- On NEQUAL reduce production plainNewAllocationExpression -> classAllocationExpression 
-- On MULEQUAL reduce production plainNewAllocationExpression -> classAllocationExpression 
-- On MUL reduce production plainNewAllocationExpression -> classAllocationExpression 
-- On MODEQUAL reduce production plainNewAllocationExpression -> classAllocationExpression 
-- On MOD reduce production plainNewAllocationExpression -> classAllocationExpression 
-- On MINUSEQUAL reduce production plainNewAllocationExpression -> classAllocationExpression 
-- On MINUS reduce production plainNewAllocationExpression -> classAllocationExpression 
-- On LTHAN reduce production plainNewAllocationExpression -> classAllocationExpression 
-- On LSHIFTEQUAL reduce production plainNewAllocationExpression -> classAllocationExpression 
-- On LSHIFT reduce production plainNewAllocationExpression -> classAllocationExpression 
-- On LOGSHIFTEQUAL reduce production plainNewAllocationExpression -> classAllocationExpression 
-- On LOGSHIFT reduce production plainNewAllocationExpression -> classAllocationExpression 
-- On LETHAN reduce production plainNewAllocationExpression -> classAllocationExpression 
-- On INSTANCEOF reduce production plainNewAllocationExpression -> classAllocationExpression 
-- On INCREMENT reduce production plainNewAllocationExpression -> classAllocationExpression 
-- On GTHAN reduce production plainNewAllocationExpression -> classAllocationExpression 
-- On GETHAN reduce production plainNewAllocationExpression -> classAllocationExpression 
-- On EQUAL reduce production plainNewAllocationExpression -> classAllocationExpression 
-- On DOT reduce production plainNewAllocationExpression -> classAllocationExpression 
-- On DIVEQUAL reduce production plainNewAllocationExpression -> classAllocationExpression 
-- On DIV reduce production plainNewAllocationExpression -> classAllocationExpression 
-- On DECREMENT reduce production plainNewAllocationExpression -> classAllocationExpression 
-- On COMM reduce production plainNewAllocationExpression -> classAllocationExpression 
-- On COL reduce production plainNewAllocationExpression -> classAllocationExpression 
-- On BOR reduce production plainNewAllocationExpression -> classAllocationExpression 
-- On BAND reduce production plainNewAllocationExpression -> classAllocationExpression 
-- On ASSIGN reduce production plainNewAllocationExpression -> classAllocationExpression 
-- On ANDEQUAL reduce production plainNewAllocationExpression -> classAllocationExpression 
-- On AND reduce production plainNewAllocationExpression -> classAllocationExpression 

State 101:
plainNewAllocationExpression -> classAllocationExpression LCURL . RCURL [ XOREQUAL XOR SEMI RSHIFTEQUAL RSHIFT RPAR RCURL RBRAC QM PLUS PEQUAL OREQUAL OR NEQUAL MULEQUAL MUL MODEQUAL MOD MINUSEQUAL MINUS LTHAN LSHIFTEQUAL LSHIFT LOGSHIFTEQUAL LOGSHIFT LETHAN INSTANCEOF INCREMENT GTHAN GETHAN EQUAL DOT DIVEQUAL DIV DECREMENT COMM COL BOR BAND ASSIGN ANDEQUAL AND ]
-- On RCURL shift to state 102

State 102:
plainNewAllocationExpression -> classAllocationExpression LCURL RCURL . [ XOREQUAL XOR SEMI RSHIFTEQUAL RSHIFT RPAR RCURL RBRAC QM PLUS PEQUAL OREQUAL OR NEQUAL MULEQUAL MUL MODEQUAL MOD MINUSEQUAL MINUS LTHAN LSHIFTEQUAL LSHIFT LOGSHIFTEQUAL LOGSHIFT LETHAN INSTANCEOF INCREMENT GTHAN GETHAN EQUAL DOT DIVEQUAL DIV DECREMENT COMM COL BOR BAND ASSIGN ANDEQUAL AND ]
-- On XOREQUAL reduce production plainNewAllocationExpression -> classAllocationExpression LCURL RCURL 
-- On XOR reduce production plainNewAllocationExpression -> classAllocationExpression LCURL RCURL 
-- On SEMI reduce production plainNewAllocationExpression -> classAllocationExpression LCURL RCURL 
-- On RSHIFTEQUAL reduce production plainNewAllocationExpression -> classAllocationExpression LCURL RCURL 
-- On RSHIFT reduce production plainNewAllocationExpression -> classAllocationExpression LCURL RCURL 
-- On RPAR reduce production plainNewAllocationExpression -> classAllocationExpression LCURL RCURL 
-- On RCURL reduce production plainNewAllocationExpression -> classAllocationExpression LCURL RCURL 
-- On RBRAC reduce production plainNewAllocationExpression -> classAllocationExpression LCURL RCURL 
-- On QM reduce production plainNewAllocationExpression -> classAllocationExpression LCURL RCURL 
-- On PLUS reduce production plainNewAllocationExpression -> classAllocationExpression LCURL RCURL 
-- On PEQUAL reduce production plainNewAllocationExpression -> classAllocationExpression LCURL RCURL 
-- On OREQUAL reduce production plainNewAllocationExpression -> classAllocationExpression LCURL RCURL 
-- On OR reduce production plainNewAllocationExpression -> classAllocationExpression LCURL RCURL 
-- On NEQUAL reduce production plainNewAllocationExpression -> classAllocationExpression LCURL RCURL 
-- On MULEQUAL reduce production plainNewAllocationExpression -> classAllocationExpression LCURL RCURL 
-- On MUL reduce production plainNewAllocationExpression -> classAllocationExpression LCURL RCURL 
-- On MODEQUAL reduce production plainNewAllocationExpression -> classAllocationExpression LCURL RCURL 
-- On MOD reduce production plainNewAllocationExpression -> classAllocationExpression LCURL RCURL 
-- On MINUSEQUAL reduce production plainNewAllocationExpression -> classAllocationExpression LCURL RCURL 
-- On MINUS reduce production plainNewAllocationExpression -> classAllocationExpression LCURL RCURL 
-- On LTHAN reduce production plainNewAllocationExpression -> classAllocationExpression LCURL RCURL 
-- On LSHIFTEQUAL reduce production plainNewAllocationExpression -> classAllocationExpression LCURL RCURL 
-- On LSHIFT reduce production plainNewAllocationExpression -> classAllocationExpression LCURL RCURL 
-- On LOGSHIFTEQUAL reduce production plainNewAllocationExpression -> classAllocationExpression LCURL RCURL 
-- On LOGSHIFT reduce production plainNewAllocationExpression -> classAllocationExpression LCURL RCURL 
-- On LETHAN reduce production plainNewAllocationExpression -> classAllocationExpression LCURL RCURL 
-- On INSTANCEOF reduce production plainNewAllocationExpression -> classAllocationExpression LCURL RCURL 
-- On INCREMENT reduce production plainNewAllocationExpression -> classAllocationExpression LCURL RCURL 
-- On GTHAN reduce production plainNewAllocationExpression -> classAllocationExpression LCURL RCURL 
-- On GETHAN reduce production plainNewAllocationExpression -> classAllocationExpression LCURL RCURL 
-- On EQUAL reduce production plainNewAllocationExpression -> classAllocationExpression LCURL RCURL 
-- On DOT reduce production plainNewAllocationExpression -> classAllocationExpression LCURL RCURL 
-- On DIVEQUAL reduce production plainNewAllocationExpression -> classAllocationExpression LCURL RCURL 
-- On DIV reduce production plainNewAllocationExpression -> classAllocationExpression LCURL RCURL 
-- On DECREMENT reduce production plainNewAllocationExpression -> classAllocationExpression LCURL RCURL 
-- On COMM reduce production plainNewAllocationExpression -> classAllocationExpression LCURL RCURL 
-- On COL reduce production plainNewAllocationExpression -> classAllocationExpression LCURL RCURL 
-- On BOR reduce production plainNewAllocationExpression -> classAllocationExpression LCURL RCURL 
-- On BAND reduce production plainNewAllocationExpression -> classAllocationExpression LCURL RCURL 
-- On ASSIGN reduce production plainNewAllocationExpression -> classAllocationExpression LCURL RCURL 
-- On ANDEQUAL reduce production plainNewAllocationExpression -> classAllocationExpression LCURL RCURL 
-- On AND reduce production plainNewAllocationExpression -> classAllocationExpression LCURL RCURL 

State 103:
multiplicativeExpression -> castExpression . [ XOR SEMI RSHIFT RPAR RCURL RBRAC QM PLUS OR NEQUAL MUL MOD MINUS LTHAN LSHIFT LOGSHIFT LETHAN INSTANCEOF GTHAN GETHAN EQUAL DIV COMM COL BOR BAND AND ]
-- On XOR reduce production multiplicativeExpression -> castExpression 
-- On SEMI reduce production multiplicativeExpression -> castExpression 
-- On RSHIFT reduce production multiplicativeExpression -> castExpression 
-- On RPAR reduce production multiplicativeExpression -> castExpression 
-- On RCURL reduce production multiplicativeExpression -> castExpression 
-- On RBRAC reduce production multiplicativeExpression -> castExpression 
-- On QM reduce production multiplicativeExpression -> castExpression 
-- On PLUS reduce production multiplicativeExpression -> castExpression 
-- On OR reduce production multiplicativeExpression -> castExpression 
-- On NEQUAL reduce production multiplicativeExpression -> castExpression 
-- On MUL reduce production multiplicativeExpression -> castExpression 
-- On MOD reduce production multiplicativeExpression -> castExpression 
-- On MINUS reduce production multiplicativeExpression -> castExpression 
-- On LTHAN reduce production multiplicativeExpression -> castExpression 
-- On LSHIFT reduce production multiplicativeExpression -> castExpression 
-- On LOGSHIFT reduce production multiplicativeExpression -> castExpression 
-- On LETHAN reduce production multiplicativeExpression -> castExpression 
-- On INSTANCEOF reduce production multiplicativeExpression -> castExpression 
-- On GTHAN reduce production multiplicativeExpression -> castExpression 
-- On GETHAN reduce production multiplicativeExpression -> castExpression 
-- On EQUAL reduce production multiplicativeExpression -> castExpression 
-- On DIV reduce production multiplicativeExpression -> castExpression 
-- On COMM reduce production multiplicativeExpression -> castExpression 
-- On COL reduce production multiplicativeExpression -> castExpression 
-- On BOR reduce production multiplicativeExpression -> castExpression 
-- On BAND reduce production multiplicativeExpression -> castExpression 
-- On AND reduce production multiplicativeExpression -> castExpression 

State 104:
plainNewAllocationExpression -> arrayAllocationExpression . [ XOREQUAL XOR SEMI RSHIFTEQUAL RSHIFT RPAR RCURL RBRAC QM PLUS PEQUAL OREQUAL OR NEQUAL MULEQUAL MUL MODEQUAL MOD MINUSEQUAL MINUS LTHAN LSHIFTEQUAL LSHIFT LOGSHIFTEQUAL LOGSHIFT LETHAN INSTANCEOF INCREMENT GTHAN GETHAN EQUAL DOT DIVEQUAL DIV DECREMENT COMM COL BOR BAND ASSIGN ANDEQUAL AND ]
plainNewAllocationExpression -> arrayAllocationExpression . LCURL RCURL [ XOREQUAL XOR SEMI RSHIFTEQUAL RSHIFT RPAR RCURL RBRAC QM PLUS PEQUAL OREQUAL OR NEQUAL MULEQUAL MUL MODEQUAL MOD MINUSEQUAL MINUS LTHAN LSHIFTEQUAL LSHIFT LOGSHIFTEQUAL LOGSHIFT LETHAN INSTANCEOF INCREMENT GTHAN GETHAN EQUAL DOT DIVEQUAL DIV DECREMENT COMM COL BOR BAND ASSIGN ANDEQUAL AND ]
plainNewAllocationExpression -> arrayAllocationExpression . LCURL arrayInitializers RCURL [ XOREQUAL XOR SEMI RSHIFTEQUAL RSHIFT RPAR RCURL RBRAC QM PLUS PEQUAL OREQUAL OR NEQUAL MULEQUAL MUL MODEQUAL MOD MINUSEQUAL MINUS LTHAN LSHIFTEQUAL LSHIFT LOGSHIFTEQUAL LOGSHIFT LETHAN INSTANCEOF INCREMENT GTHAN GETHAN EQUAL DOT DIVEQUAL DIV DECREMENT COMM COL BOR BAND ASSIGN ANDEQUAL AND ]
-- On LCURL shift to state 105
-- On XOREQUAL reduce production plainNewAllocationExpression -> arrayAllocationExpression 
-- On XOR reduce production plainNewAllocationExpression -> arrayAllocationExpression 
-- On SEMI reduce production plainNewAllocationExpression -> arrayAllocationExpression 
-- On RSHIFTEQUAL reduce production plainNewAllocationExpression -> arrayAllocationExpression 
-- On RSHIFT reduce production plainNewAllocationExpression -> arrayAllocationExpression 
-- On RPAR reduce production plainNewAllocationExpression -> arrayAllocationExpression 
-- On RCURL reduce production plainNewAllocationExpression -> arrayAllocationExpression 
-- On RBRAC reduce production plainNewAllocationExpression -> arrayAllocationExpression 
-- On QM reduce production plainNewAllocationExpression -> arrayAllocationExpression 
-- On PLUS reduce production plainNewAllocationExpression -> arrayAllocationExpression 
-- On PEQUAL reduce production plainNewAllocationExpression -> arrayAllocationExpression 
-- On OREQUAL reduce production plainNewAllocationExpression -> arrayAllocationExpression 
-- On OR reduce production plainNewAllocationExpression -> arrayAllocationExpression 
-- On NEQUAL reduce production plainNewAllocationExpression -> arrayAllocationExpression 
-- On MULEQUAL reduce production plainNewAllocationExpression -> arrayAllocationExpression 
-- On MUL reduce production plainNewAllocationExpression -> arrayAllocationExpression 
-- On MODEQUAL reduce production plainNewAllocationExpression -> arrayAllocationExpression 
-- On MOD reduce production plainNewAllocationExpression -> arrayAllocationExpression 
-- On MINUSEQUAL reduce production plainNewAllocationExpression -> arrayAllocationExpression 
-- On MINUS reduce production plainNewAllocationExpression -> arrayAllocationExpression 
-- On LTHAN reduce production plainNewAllocationExpression -> arrayAllocationExpression 
-- On LSHIFTEQUAL reduce production plainNewAllocationExpression -> arrayAllocationExpression 
-- On LSHIFT reduce production plainNewAllocationExpression -> arrayAllocationExpression 
-- On LOGSHIFTEQUAL reduce production plainNewAllocationExpression -> arrayAllocationExpression 
-- On LOGSHIFT reduce production plainNewAllocationExpression -> arrayAllocationExpression 
-- On LETHAN reduce production plainNewAllocationExpression -> arrayAllocationExpression 
-- On INSTANCEOF reduce production plainNewAllocationExpression -> arrayAllocationExpression 
-- On INCREMENT reduce production plainNewAllocationExpression -> arrayAllocationExpression 
-- On GTHAN reduce production plainNewAllocationExpression -> arrayAllocationExpression 
-- On GETHAN reduce production plainNewAllocationExpression -> arrayAllocationExpression 
-- On EQUAL reduce production plainNewAllocationExpression -> arrayAllocationExpression 
-- On DOT reduce production plainNewAllocationExpression -> arrayAllocationExpression 
-- On DIVEQUAL reduce production plainNewAllocationExpression -> arrayAllocationExpression 
-- On DIV reduce production plainNewAllocationExpression -> arrayAllocationExpression 
-- On DECREMENT reduce production plainNewAllocationExpression -> arrayAllocationExpression 
-- On COMM reduce production plainNewAllocationExpression -> arrayAllocationExpression 
-- On COL reduce production plainNewAllocationExpression -> arrayAllocationExpression 
-- On BOR reduce production plainNewAllocationExpression -> arrayAllocationExpression 
-- On BAND reduce production plainNewAllocationExpression -> arrayAllocationExpression 
-- On ASSIGN reduce production plainNewAllocationExpression -> arrayAllocationExpression 
-- On ANDEQUAL reduce production plainNewAllocationExpression -> arrayAllocationExpression 
-- On AND reduce production plainNewAllocationExpression -> arrayAllocationExpression 

State 105:
plainNewAllocationExpression -> arrayAllocationExpression LCURL . RCURL [ XOREQUAL XOR SEMI RSHIFTEQUAL RSHIFT RPAR RCURL RBRAC QM PLUS PEQUAL OREQUAL OR NEQUAL MULEQUAL MUL MODEQUAL MOD MINUSEQUAL MINUS LTHAN LSHIFTEQUAL LSHIFT LOGSHIFTEQUAL LOGSHIFT LETHAN INSTANCEOF INCREMENT GTHAN GETHAN EQUAL DOT DIVEQUAL DIV DECREMENT COMM COL BOR BAND ASSIGN ANDEQUAL AND ]
plainNewAllocationExpression -> arrayAllocationExpression LCURL . arrayInitializers RCURL [ XOREQUAL XOR SEMI RSHIFTEQUAL RSHIFT RPAR RCURL RBRAC QM PLUS PEQUAL OREQUAL OR NEQUAL MULEQUAL MUL MODEQUAL MOD MINUSEQUAL MINUS LTHAN LSHIFTEQUAL LSHIFT LOGSHIFTEQUAL LOGSHIFT LETHAN INSTANCEOF INCREMENT GTHAN GETHAN EQUAL DOT DIVEQUAL DIV DECREMENT COMM COL BOR BAND ASSIGN ANDEQUAL AND ]
-- On error shift to state 3
-- On VOID shift to state 6
-- On THIS shift to state 7
-- On SUPER shift to state 8
-- On STRLIT shift to state 9
-- On SHORT shift to state 10
-- On RCURL shift to state 106
-- On PLUS shift to state 11
-- On NULLLIT shift to state 12
-- On NOT shift to state 13
-- On NEW shift to state 14
-- On MINUS shift to state 26
-- On LPAR shift to state 27
-- On LONG shift to state 15
-- On LCURL shift to state 107
-- On INTLIT shift to state 28
-- On INT shift to state 16
-- On INCREMENT shift to state 29
-- On IDENTIFIER shift to state 17
-- On FLOATLIT shift to state 31
-- On FLOAT shift to state 18
-- On DOUBLELIT shift to state 32
-- On DOUBLE shift to state 19
-- On DECREMENT shift to state 33
-- On CHARLIT shift to state 34
-- On CHAR shift to state 20
-- On BYTE shift to state 21
-- On BOOLEANLIT shift to state 35
-- On BOOLEAN shift to state 22
-- On BNOT shift to state 36
-- On variableInitializer shift to state 109
-- On unaryExpression shift to state 44
-- On specialName shift to state 38
-- On shiftExpression shift to state 58
-- On relationalExpression shift to state 79
-- On realPostfixExpression shift to state 39
-- On qualifiedName shift to state 42
-- On primitiveType shift to state 61
-- On primaryExpression shift to state 64
-- On postfixExpression shift to state 65
-- On plainNewAllocationExpression shift to state 68
-- On notJustName shift to state 69
-- On newAllocationExpression shift to state 72
-- On multiplicativeExpression shift to state 73
-- On methodCall shift to state 75
-- On methodAccess shift to state 76
-- On logicalUnaryOperator shift to state 83
-- On logicalUnaryExpression shift to state 85
-- On inclusiveOrExpression shift to state 90
-- On fieldAccess shift to state 86
-- On expression shift to state 110
-- On exclusiveOrExpression shift to state 111
-- On equalityExpression shift to state 94
-- On conditionalOrExpression shift to state 112
-- On conditionalExpression shift to state 151
-- On conditionalAndExpression shift to state 117
-- On complexPrimaryNoParenthesis shift to state 87
-- On complexPrimary shift to state 88
-- On classAllocationExpression shift to state 100
-- On castExpression shift to state 103
-- On assignmentExpression shift to state 152
-- On arrayInitializers shift to state 159
-- On arrayAllocationExpression shift to state 104
-- On arrayAccess shift to state 120
-- On arithmeticUnaryOperator shift to state 121
-- On andExpression shift to state 123
-- On additiveExpression shift to state 140

State 106:
plainNewAllocationExpression -> arrayAllocationExpression LCURL RCURL . [ XOREQUAL XOR SEMI RSHIFTEQUAL RSHIFT RPAR RCURL RBRAC QM PLUS PEQUAL OREQUAL OR NEQUAL MULEQUAL MUL MODEQUAL MOD MINUSEQUAL MINUS LTHAN LSHIFTEQUAL LSHIFT LOGSHIFTEQUAL LOGSHIFT LETHAN INSTANCEOF INCREMENT GTHAN GETHAN EQUAL DOT DIVEQUAL DIV DECREMENT COMM COL BOR BAND ASSIGN ANDEQUAL AND ]
-- On XOREQUAL reduce production plainNewAllocationExpression -> arrayAllocationExpression LCURL RCURL 
-- On XOR reduce production plainNewAllocationExpression -> arrayAllocationExpression LCURL RCURL 
-- On SEMI reduce production plainNewAllocationExpression -> arrayAllocationExpression LCURL RCURL 
-- On RSHIFTEQUAL reduce production plainNewAllocationExpression -> arrayAllocationExpression LCURL RCURL 
-- On RSHIFT reduce production plainNewAllocationExpression -> arrayAllocationExpression LCURL RCURL 
-- On RPAR reduce production plainNewAllocationExpression -> arrayAllocationExpression LCURL RCURL 
-- On RCURL reduce production plainNewAllocationExpression -> arrayAllocationExpression LCURL RCURL 
-- On RBRAC reduce production plainNewAllocationExpression -> arrayAllocationExpression LCURL RCURL 
-- On QM reduce production plainNewAllocationExpression -> arrayAllocationExpression LCURL RCURL 
-- On PLUS reduce production plainNewAllocationExpression -> arrayAllocationExpression LCURL RCURL 
-- On PEQUAL reduce production plainNewAllocationExpression -> arrayAllocationExpression LCURL RCURL 
-- On OREQUAL reduce production plainNewAllocationExpression -> arrayAllocationExpression LCURL RCURL 
-- On OR reduce production plainNewAllocationExpression -> arrayAllocationExpression LCURL RCURL 
-- On NEQUAL reduce production plainNewAllocationExpression -> arrayAllocationExpression LCURL RCURL 
-- On MULEQUAL reduce production plainNewAllocationExpression -> arrayAllocationExpression LCURL RCURL 
-- On MUL reduce production plainNewAllocationExpression -> arrayAllocationExpression LCURL RCURL 
-- On MODEQUAL reduce production plainNewAllocationExpression -> arrayAllocationExpression LCURL RCURL 
-- On MOD reduce production plainNewAllocationExpression -> arrayAllocationExpression LCURL RCURL 
-- On MINUSEQUAL reduce production plainNewAllocationExpression -> arrayAllocationExpression LCURL RCURL 
-- On MINUS reduce production plainNewAllocationExpression -> arrayAllocationExpression LCURL RCURL 
-- On LTHAN reduce production plainNewAllocationExpression -> arrayAllocationExpression LCURL RCURL 
-- On LSHIFTEQUAL reduce production plainNewAllocationExpression -> arrayAllocationExpression LCURL RCURL 
-- On LSHIFT reduce production plainNewAllocationExpression -> arrayAllocationExpression LCURL RCURL 
-- On LOGSHIFTEQUAL reduce production plainNewAllocationExpression -> arrayAllocationExpression LCURL RCURL 
-- On LOGSHIFT reduce production plainNewAllocationExpression -> arrayAllocationExpression LCURL RCURL 
-- On LETHAN reduce production plainNewAllocationExpression -> arrayAllocationExpression LCURL RCURL 
-- On INSTANCEOF reduce production plainNewAllocationExpression -> arrayAllocationExpression LCURL RCURL 
-- On INCREMENT reduce production plainNewAllocationExpression -> arrayAllocationExpression LCURL RCURL 
-- On GTHAN reduce production plainNewAllocationExpression -> arrayAllocationExpression LCURL RCURL 
-- On GETHAN reduce production plainNewAllocationExpression -> arrayAllocationExpression LCURL RCURL 
-- On EQUAL reduce production plainNewAllocationExpression -> arrayAllocationExpression LCURL RCURL 
-- On DOT reduce production plainNewAllocationExpression -> arrayAllocationExpression LCURL RCURL 
-- On DIVEQUAL reduce production plainNewAllocationExpression -> arrayAllocationExpression LCURL RCURL 
-- On DIV reduce production plainNewAllocationExpression -> arrayAllocationExpression LCURL RCURL 
-- On DECREMENT reduce production plainNewAllocationExpression -> arrayAllocationExpression LCURL RCURL 
-- On COMM reduce production plainNewAllocationExpression -> arrayAllocationExpression LCURL RCURL 
-- On COL reduce production plainNewAllocationExpression -> arrayAllocationExpression LCURL RCURL 
-- On BOR reduce production plainNewAllocationExpression -> arrayAllocationExpression LCURL RCURL 
-- On BAND reduce production plainNewAllocationExpression -> arrayAllocationExpression LCURL RCURL 
-- On ASSIGN reduce production plainNewAllocationExpression -> arrayAllocationExpression LCURL RCURL 
-- On ANDEQUAL reduce production plainNewAllocationExpression -> arrayAllocationExpression LCURL RCURL 
-- On AND reduce production plainNewAllocationExpression -> arrayAllocationExpression LCURL RCURL 

State 107:
variableInitializer -> LCURL . RCURL [ SEMI RCURL COMM ]
variableInitializer -> LCURL . arrayInitializers RCURL [ SEMI RCURL COMM ]
-- On error shift to state 3
-- On VOID shift to state 6
-- On THIS shift to state 7
-- On SUPER shift to state 8
-- On STRLIT shift to state 9
-- On SHORT shift to state 10
-- On RCURL shift to state 108
-- On PLUS shift to state 11
-- On NULLLIT shift to state 12
-- On NOT shift to state 13
-- On NEW shift to state 14
-- On MINUS shift to state 26
-- On LPAR shift to state 27
-- On LONG shift to state 15
-- On LCURL shift to state 107
-- On INTLIT shift to state 28
-- On INT shift to state 16
-- On INCREMENT shift to state 29
-- On IDENTIFIER shift to state 17
-- On FLOATLIT shift to state 31
-- On FLOAT shift to state 18
-- On DOUBLELIT shift to state 32
-- On DOUBLE shift to state 19
-- On DECREMENT shift to state 33
-- On CHARLIT shift to state 34
-- On CHAR shift to state 20
-- On BYTE shift to state 21
-- On BOOLEANLIT shift to state 35
-- On BOOLEAN shift to state 22
-- On BNOT shift to state 36
-- On variableInitializer shift to state 109
-- On unaryExpression shift to state 44
-- On specialName shift to state 38
-- On shiftExpression shift to state 58
-- On relationalExpression shift to state 79
-- On realPostfixExpression shift to state 39
-- On qualifiedName shift to state 42
-- On primitiveType shift to state 61
-- On primaryExpression shift to state 64
-- On postfixExpression shift to state 65
-- On plainNewAllocationExpression shift to state 68
-- On notJustName shift to state 69
-- On newAllocationExpression shift to state 72
-- On multiplicativeExpression shift to state 73
-- On methodCall shift to state 75
-- On methodAccess shift to state 76
-- On logicalUnaryOperator shift to state 83
-- On logicalUnaryExpression shift to state 85
-- On inclusiveOrExpression shift to state 90
-- On fieldAccess shift to state 86
-- On expression shift to state 110
-- On exclusiveOrExpression shift to state 111
-- On equalityExpression shift to state 94
-- On conditionalOrExpression shift to state 112
-- On conditionalExpression shift to state 151
-- On conditionalAndExpression shift to state 117
-- On complexPrimaryNoParenthesis shift to state 87
-- On complexPrimary shift to state 88
-- On classAllocationExpression shift to state 100
-- On castExpression shift to state 103
-- On assignmentExpression shift to state 152
-- On arrayInitializers shift to state 155
-- On arrayAllocationExpression shift to state 104
-- On arrayAccess shift to state 120
-- On arithmeticUnaryOperator shift to state 121
-- On andExpression shift to state 123
-- On additiveExpression shift to state 140

State 108:
variableInitializer -> LCURL RCURL . [ SEMI RCURL COMM ]
-- On SEMI reduce production variableInitializer -> LCURL RCURL 
-- On RCURL reduce production variableInitializer -> LCURL RCURL 
-- On COMM reduce production variableInitializer -> LCURL RCURL 

State 109:
arrayInitializers -> variableInitializer . [ RCURL COMM ]
-- On RCURL reduce production arrayInitializers -> variableInitializer 
-- On COMM reduce production arrayInitializers -> variableInitializer 

State 110:
variableInitializer -> expression . [ SEMI RCURL COMM ]
-- On SEMI reduce production variableInitializer -> expression 
-- On RCURL reduce production variableInitializer -> expression 
-- On COMM reduce production variableInitializer -> expression 

State 111:
exclusiveOrExpression -> exclusiveOrExpression . XOR andExpression [ XOR SEMI RPAR RCURL RBRAC QM OR COMM COL BOR AND ]
inclusiveOrExpression -> exclusiveOrExpression . [ SEMI RPAR RCURL RBRAC QM OR COMM COL BOR AND ]
-- On XOR shift to state 93
-- On SEMI reduce production inclusiveOrExpression -> exclusiveOrExpression 
-- On RPAR reduce production inclusiveOrExpression -> exclusiveOrExpression 
-- On RCURL reduce production inclusiveOrExpression -> exclusiveOrExpression 
-- On RBRAC reduce production inclusiveOrExpression -> exclusiveOrExpression 
-- On QM reduce production inclusiveOrExpression -> exclusiveOrExpression 
-- On OR reduce production inclusiveOrExpression -> exclusiveOrExpression 
-- On COMM reduce production inclusiveOrExpression -> exclusiveOrExpression 
-- On COL reduce production inclusiveOrExpression -> exclusiveOrExpression 
-- On BOR reduce production inclusiveOrExpression -> exclusiveOrExpression 
-- On AND reduce production inclusiveOrExpression -> exclusiveOrExpression 

State 112:
conditionalExpression -> conditionalOrExpression . [ SEMI RPAR RCURL RBRAC COMM COL ]
conditionalExpression -> conditionalOrExpression . QM expression COL conditionalExpression [ SEMI RPAR RCURL RBRAC COMM COL ]
conditionalOrExpression -> conditionalOrExpression . OR conditionalAndExpression [ SEMI RPAR RCURL RBRAC QM OR COMM COL ]
-- On QM shift to state 113
-- On OR shift to state 153
-- On SEMI reduce production conditionalExpression -> conditionalOrExpression 
-- On RPAR reduce production conditionalExpression -> conditionalOrExpression 
-- On RCURL reduce production conditionalExpression -> conditionalOrExpression 
-- On RBRAC reduce production conditionalExpression -> conditionalOrExpression 
-- On COMM reduce production conditionalExpression -> conditionalOrExpression 
-- On COL reduce production conditionalExpression -> conditionalOrExpression 

State 113:
conditionalExpression -> conditionalOrExpression QM . expression COL conditionalExpression [ SEMI RPAR RCURL RBRAC COMM COL ]
-- On error shift to state 3
-- On VOID shift to state 6
-- On THIS shift to state 7
-- On SUPER shift to state 8
-- On STRLIT shift to state 9
-- On SHORT shift to state 10
-- On PLUS shift to state 11
-- On NULLLIT shift to state 12
-- On NOT shift to state 13
-- On NEW shift to state 14
-- On MINUS shift to state 26
-- On LPAR shift to state 27
-- On LONG shift to state 15
-- On INTLIT shift to state 28
-- On INT shift to state 16
-- On INCREMENT shift to state 29
-- On IDENTIFIER shift to state 17
-- On FLOATLIT shift to state 31
-- On FLOAT shift to state 18
-- On DOUBLELIT shift to state 32
-- On DOUBLE shift to state 19
-- On DECREMENT shift to state 33
-- On CHARLIT shift to state 34
-- On CHAR shift to state 20
-- On BYTE shift to state 21
-- On BOOLEANLIT shift to state 35
-- On BOOLEAN shift to state 22
-- On BNOT shift to state 36
-- On unaryExpression shift to state 44
-- On specialName shift to state 38
-- On shiftExpression shift to state 58
-- On relationalExpression shift to state 79
-- On realPostfixExpression shift to state 39
-- On qualifiedName shift to state 42
-- On primitiveType shift to state 61
-- On primaryExpression shift to state 64
-- On postfixExpression shift to state 65
-- On plainNewAllocationExpression shift to state 68
-- On notJustName shift to state 69
-- On newAllocationExpression shift to state 72
-- On multiplicativeExpression shift to state 73
-- On methodCall shift to state 75
-- On methodAccess shift to state 76
-- On logicalUnaryOperator shift to state 83
-- On logicalUnaryExpression shift to state 85
-- On inclusiveOrExpression shift to state 90
-- On fieldAccess shift to state 86
-- On expression shift to state 114
-- On exclusiveOrExpression shift to state 111
-- On equalityExpression shift to state 94
-- On conditionalOrExpression shift to state 112
-- On conditionalExpression shift to state 151
-- On conditionalAndExpression shift to state 117
-- On complexPrimaryNoParenthesis shift to state 87
-- On complexPrimary shift to state 88
-- On classAllocationExpression shift to state 100
-- On castExpression shift to state 103
-- On assignmentExpression shift to state 152
-- On arrayAllocationExpression shift to state 104
-- On arrayAccess shift to state 120
-- On arithmeticUnaryOperator shift to state 121
-- On andExpression shift to state 123
-- On additiveExpression shift to state 140

State 114:
conditionalExpression -> conditionalOrExpression QM expression . COL conditionalExpression [ SEMI RPAR RCURL RBRAC COMM COL ]
-- On COL shift to state 115

State 115:
conditionalExpression -> conditionalOrExpression QM expression COL . conditionalExpression [ SEMI RPAR RCURL RBRAC COMM COL ]
-- On VOID shift to state 6
-- On THIS shift to state 7
-- On SUPER shift to state 8
-- On STRLIT shift to state 9
-- On SHORT shift to state 10
-- On PLUS shift to state 11
-- On NULLLIT shift to state 12
-- On NOT shift to state 13
-- On NEW shift to state 14
-- On MINUS shift to state 26
-- On LPAR shift to state 27
-- On LONG shift to state 15
-- On INTLIT shift to state 28
-- On INT shift to state 16
-- On INCREMENT shift to state 29
-- On IDENTIFIER shift to state 17
-- On FLOATLIT shift to state 31
-- On FLOAT shift to state 18
-- On DOUBLELIT shift to state 32
-- On DOUBLE shift to state 19
-- On DECREMENT shift to state 33
-- On CHARLIT shift to state 34
-- On CHAR shift to state 20
-- On BYTE shift to state 21
-- On BOOLEANLIT shift to state 35
-- On BOOLEAN shift to state 22
-- On BNOT shift to state 36
-- On unaryExpression shift to state 60
-- On specialName shift to state 38
-- On shiftExpression shift to state 58
-- On relationalExpression shift to state 79
-- On realPostfixExpression shift to state 39
-- On qualifiedName shift to state 42
-- On primitiveType shift to state 61
-- On primaryExpression shift to state 64
-- On postfixExpression shift to state 65
-- On plainNewAllocationExpression shift to state 68
-- On notJustName shift to state 69
-- On newAllocationExpression shift to state 72
-- On multiplicativeExpression shift to state 73
-- On methodCall shift to state 75
-- On methodAccess shift to state 76
-- On logicalUnaryOperator shift to state 83
-- On logicalUnaryExpression shift to state 85
-- On inclusiveOrExpression shift to state 90
-- On fieldAccess shift to state 86
-- On exclusiveOrExpression shift to state 111
-- On equalityExpression shift to state 94
-- On conditionalOrExpression shift to state 112
-- On conditionalExpression shift to state 116
-- On conditionalAndExpression shift to state 117
-- On complexPrimaryNoParenthesis shift to state 87
-- On complexPrimary shift to state 88
-- On classAllocationExpression shift to state 100
-- On castExpression shift to state 103
-- On arrayAllocationExpression shift to state 104
-- On arrayAccess shift to state 120
-- On arithmeticUnaryOperator shift to state 121
-- On andExpression shift to state 123
-- On additiveExpression shift to state 140

State 116:
conditionalExpression -> conditionalOrExpression QM expression COL conditionalExpression . [ SEMI RPAR RCURL RBRAC COMM COL ]
-- On SEMI reduce production conditionalExpression -> conditionalOrExpression QM expression COL conditionalExpression 
-- On RPAR reduce production conditionalExpression -> conditionalOrExpression QM expression COL conditionalExpression 
-- On RCURL reduce production conditionalExpression -> conditionalOrExpression QM expression COL conditionalExpression 
-- On RBRAC reduce production conditionalExpression -> conditionalOrExpression QM expression COL conditionalExpression 
-- On COMM reduce production conditionalExpression -> conditionalOrExpression QM expression COL conditionalExpression 
-- On COL reduce production conditionalExpression -> conditionalOrExpression QM expression COL conditionalExpression 

State 117:
conditionalAndExpression -> conditionalAndExpression . AND inclusiveOrExpression [ SEMI RPAR RCURL RBRAC QM OR COMM COL AND ]
conditionalOrExpression -> conditionalAndExpression . [ SEMI RPAR RCURL RBRAC QM OR COMM COL ]
-- On AND shift to state 118
-- On SEMI reduce production conditionalOrExpression -> conditionalAndExpression 
-- On RPAR reduce production conditionalOrExpression -> conditionalAndExpression 
-- On RCURL reduce production conditionalOrExpression -> conditionalAndExpression 
-- On RBRAC reduce production conditionalOrExpression -> conditionalAndExpression 
-- On QM reduce production conditionalOrExpression -> conditionalAndExpression 
-- On OR reduce production conditionalOrExpression -> conditionalAndExpression 
-- On COMM reduce production conditionalOrExpression -> conditionalAndExpression 
-- On COL reduce production conditionalOrExpression -> conditionalAndExpression 

State 118:
conditionalAndExpression -> conditionalAndExpression AND . inclusiveOrExpression [ SEMI RPAR RCURL RBRAC QM OR COMM COL AND ]
-- On VOID shift to state 6
-- On THIS shift to state 7
-- On SUPER shift to state 8
-- On STRLIT shift to state 9
-- On SHORT shift to state 10
-- On PLUS shift to state 11
-- On NULLLIT shift to state 12
-- On NOT shift to state 13
-- On NEW shift to state 14
-- On MINUS shift to state 26
-- On LPAR shift to state 27
-- On LONG shift to state 15
-- On INTLIT shift to state 28
-- On INT shift to state 16
-- On INCREMENT shift to state 29
-- On IDENTIFIER shift to state 17
-- On FLOATLIT shift to state 31
-- On FLOAT shift to state 18
-- On DOUBLELIT shift to state 32
-- On DOUBLE shift to state 19
-- On DECREMENT shift to state 33
-- On CHARLIT shift to state 34
-- On CHAR shift to state 20
-- On BYTE shift to state 21
-- On BOOLEANLIT shift to state 35
-- On BOOLEAN shift to state 22
-- On BNOT shift to state 36
-- On unaryExpression shift to state 60
-- On specialName shift to state 38
-- On shiftExpression shift to state 58
-- On relationalExpression shift to state 79
-- On realPostfixExpression shift to state 39
-- On qualifiedName shift to state 42
-- On primitiveType shift to state 61
-- On primaryExpression shift to state 64
-- On postfixExpression shift to state 65
-- On plainNewAllocationExpression shift to state 68
-- On notJustName shift to state 69
-- On newAllocationExpression shift to state 72
-- On multiplicativeExpression shift to state 73
-- On methodCall shift to state 75
-- On methodAccess shift to state 76
-- On logicalUnaryOperator shift to state 83
-- On logicalUnaryExpression shift to state 85
-- On inclusiveOrExpression shift to state 119
-- On fieldAccess shift to state 86
-- On exclusiveOrExpression shift to state 111
-- On equalityExpression shift to state 94
-- On complexPrimaryNoParenthesis shift to state 87
-- On complexPrimary shift to state 88
-- On classAllocationExpression shift to state 100
-- On castExpression shift to state 103
-- On arrayAllocationExpression shift to state 104
-- On arrayAccess shift to state 120
-- On arithmeticUnaryOperator shift to state 121
-- On andExpression shift to state 123
-- On additiveExpression shift to state 140

State 119:
conditionalAndExpression -> conditionalAndExpression AND inclusiveOrExpression . [ SEMI RPAR RCURL RBRAC QM OR COMM COL AND ]
inclusiveOrExpression -> inclusiveOrExpression . BOR exclusiveOrExpression [ SEMI RPAR RCURL RBRAC QM OR COMM COL BOR AND ]
-- On BOR shift to state 91
-- On SEMI reduce production conditionalAndExpression -> conditionalAndExpression AND inclusiveOrExpression 
-- On RPAR reduce production conditionalAndExpression -> conditionalAndExpression AND inclusiveOrExpression 
-- On RCURL reduce production conditionalAndExpression -> conditionalAndExpression AND inclusiveOrExpression 
-- On RBRAC reduce production conditionalAndExpression -> conditionalAndExpression AND inclusiveOrExpression 
-- On QM reduce production conditionalAndExpression -> conditionalAndExpression AND inclusiveOrExpression 
-- On OR reduce production conditionalAndExpression -> conditionalAndExpression AND inclusiveOrExpression 
-- On COMM reduce production conditionalAndExpression -> conditionalAndExpression AND inclusiveOrExpression 
-- On COL reduce production conditionalAndExpression -> conditionalAndExpression AND inclusiveOrExpression 
-- On AND reduce production conditionalAndExpression -> conditionalAndExpression AND inclusiveOrExpression 

State 120:
complexPrimaryNoParenthesis -> arrayAccess . [ XOREQUAL XOR SEMI RSHIFTEQUAL RSHIFT RPAR RCURL RBRAC QM PLUS PEQUAL OREQUAL OR NEQUAL MULEQUAL MUL MODEQUAL MOD MINUSEQUAL MINUS LTHAN LSHIFTEQUAL LSHIFT LPAR LOGSHIFTEQUAL LOGSHIFT LETHAN LBRAC INSTANCEOF INCREMENT GTHAN GETHAN EQUAL DOT DIVEQUAL DIV DECREMENT COMM COL BOR BAND ASSIGN ANDEQUAL AND ]
-- On XOREQUAL reduce production complexPrimaryNoParenthesis -> arrayAccess 
-- On XOR reduce production complexPrimaryNoParenthesis -> arrayAccess 
-- On SEMI reduce production complexPrimaryNoParenthesis -> arrayAccess 
-- On RSHIFTEQUAL reduce production complexPrimaryNoParenthesis -> arrayAccess 
-- On RSHIFT reduce production complexPrimaryNoParenthesis -> arrayAccess 
-- On RPAR reduce production complexPrimaryNoParenthesis -> arrayAccess 
-- On RCURL reduce production complexPrimaryNoParenthesis -> arrayAccess 
-- On RBRAC reduce production complexPrimaryNoParenthesis -> arrayAccess 
-- On QM reduce production complexPrimaryNoParenthesis -> arrayAccess 
-- On PLUS reduce production complexPrimaryNoParenthesis -> arrayAccess 
-- On PEQUAL reduce production complexPrimaryNoParenthesis -> arrayAccess 
-- On OREQUAL reduce production complexPrimaryNoParenthesis -> arrayAccess 
-- On OR reduce production complexPrimaryNoParenthesis -> arrayAccess 
-- On NEQUAL reduce production complexPrimaryNoParenthesis -> arrayAccess 
-- On MULEQUAL reduce production complexPrimaryNoParenthesis -> arrayAccess 
-- On MUL reduce production complexPrimaryNoParenthesis -> arrayAccess 
-- On MODEQUAL reduce production complexPrimaryNoParenthesis -> arrayAccess 
-- On MOD reduce production complexPrimaryNoParenthesis -> arrayAccess 
-- On MINUSEQUAL reduce production complexPrimaryNoParenthesis -> arrayAccess 
-- On MINUS reduce production complexPrimaryNoParenthesis -> arrayAccess 
-- On LTHAN reduce production complexPrimaryNoParenthesis -> arrayAccess 
-- On LSHIFTEQUAL reduce production complexPrimaryNoParenthesis -> arrayAccess 
-- On LSHIFT reduce production complexPrimaryNoParenthesis -> arrayAccess 
-- On LPAR reduce production complexPrimaryNoParenthesis -> arrayAccess 
-- On LOGSHIFTEQUAL reduce production complexPrimaryNoParenthesis -> arrayAccess 
-- On LOGSHIFT reduce production complexPrimaryNoParenthesis -> arrayAccess 
-- On LETHAN reduce production complexPrimaryNoParenthesis -> arrayAccess 
-- On LBRAC reduce production complexPrimaryNoParenthesis -> arrayAccess 
-- On INSTANCEOF reduce production complexPrimaryNoParenthesis -> arrayAccess 
-- On INCREMENT reduce production complexPrimaryNoParenthesis -> arrayAccess 
-- On GTHAN reduce production complexPrimaryNoParenthesis -> arrayAccess 
-- On GETHAN reduce production complexPrimaryNoParenthesis -> arrayAccess 
-- On EQUAL reduce production complexPrimaryNoParenthesis -> arrayAccess 
-- On DOT reduce production complexPrimaryNoParenthesis -> arrayAccess 
-- On DIVEQUAL reduce production complexPrimaryNoParenthesis -> arrayAccess 
-- On DIV reduce production complexPrimaryNoParenthesis -> arrayAccess 
-- On DECREMENT reduce production complexPrimaryNoParenthesis -> arrayAccess 
-- On COMM reduce production complexPrimaryNoParenthesis -> arrayAccess 
-- On COL reduce production complexPrimaryNoParenthesis -> arrayAccess 
-- On BOR reduce production complexPrimaryNoParenthesis -> arrayAccess 
-- On BAND reduce production complexPrimaryNoParenthesis -> arrayAccess 
-- On ASSIGN reduce production complexPrimaryNoParenthesis -> arrayAccess 
-- On ANDEQUAL reduce production complexPrimaryNoParenthesis -> arrayAccess 
-- On AND reduce production complexPrimaryNoParenthesis -> arrayAccess 

State 121:
unaryExpression -> arithmeticUnaryOperator . castExpression [ XOREQUAL XOR SEMI RSHIFTEQUAL RSHIFT RPAR RCURL RBRAC QM PLUS PEQUAL OREQUAL OR NEQUAL MULEQUAL MUL MODEQUAL MOD MINUSEQUAL MINUS LTHAN LSHIFTEQUAL LSHIFT LOGSHIFTEQUAL LOGSHIFT LETHAN INSTANCEOF GTHAN GETHAN EQUAL DIVEQUAL DIV COMM COL BOR BAND ASSIGN ANDEQUAL AND ]
-- On VOID shift to state 6
-- On THIS shift to state 7
-- On SUPER shift to state 8
-- On STRLIT shift to state 9
-- On SHORT shift to state 10
-- On PLUS shift to state 11
-- On NULLLIT shift to state 12
-- On NOT shift to state 13
-- On NEW shift to state 14
-- On MINUS shift to state 26
-- On LPAR shift to state 27
-- On LONG shift to state 15
-- On INTLIT shift to state 28
-- On INT shift to state 16
-- On INCREMENT shift to state 29
-- On IDENTIFIER shift to state 17
-- On FLOATLIT shift to state 31
-- On FLOAT shift to state 18
-- On DOUBLELIT shift to state 32
-- On DOUBLE shift to state 19
-- On DECREMENT shift to state 33
-- On CHARLIT shift to state 34
-- On CHAR shift to state 20
-- On BYTE shift to state 21
-- On BOOLEANLIT shift to state 35
-- On BOOLEAN shift to state 22
-- On BNOT shift to state 36
-- On unaryExpression shift to state 60
-- On specialName shift to state 38
-- On realPostfixExpression shift to state 39
-- On qualifiedName shift to state 42
-- On primitiveType shift to state 61
-- On primaryExpression shift to state 64
-- On postfixExpression shift to state 65
-- On plainNewAllocationExpression shift to state 68
-- On notJustName shift to state 69
-- On newAllocationExpression shift to state 72
-- On methodCall shift to state 75
-- On methodAccess shift to state 76
-- On logicalUnaryOperator shift to state 83
-- On logicalUnaryExpression shift to state 85
-- On fieldAccess shift to state 86
-- On complexPrimaryNoParenthesis shift to state 87
-- On complexPrimary shift to state 88
-- On classAllocationExpression shift to state 100
-- On castExpression shift to state 122
-- On arrayAllocationExpression shift to state 104
-- On arrayAccess shift to state 120
-- On arithmeticUnaryOperator shift to state 121

State 122:
unaryExpression -> arithmeticUnaryOperator castExpression . [ XOREQUAL XOR SEMI RSHIFTEQUAL RSHIFT RPAR RCURL RBRAC QM PLUS PEQUAL OREQUAL OR NEQUAL MULEQUAL MUL MODEQUAL MOD MINUSEQUAL MINUS LTHAN LSHIFTEQUAL LSHIFT LOGSHIFTEQUAL LOGSHIFT LETHAN INSTANCEOF GTHAN GETHAN EQUAL DIVEQUAL DIV COMM COL BOR BAND ASSIGN ANDEQUAL AND ]
-- On XOREQUAL reduce production unaryExpression -> arithmeticUnaryOperator castExpression 
-- On XOR reduce production unaryExpression -> arithmeticUnaryOperator castExpression 
-- On SEMI reduce production unaryExpression -> arithmeticUnaryOperator castExpression 
-- On RSHIFTEQUAL reduce production unaryExpression -> arithmeticUnaryOperator castExpression 
-- On RSHIFT reduce production unaryExpression -> arithmeticUnaryOperator castExpression 
-- On RPAR reduce production unaryExpression -> arithmeticUnaryOperator castExpression 
-- On RCURL reduce production unaryExpression -> arithmeticUnaryOperator castExpression 
-- On RBRAC reduce production unaryExpression -> arithmeticUnaryOperator castExpression 
-- On QM reduce production unaryExpression -> arithmeticUnaryOperator castExpression 
-- On PLUS reduce production unaryExpression -> arithmeticUnaryOperator castExpression 
-- On PEQUAL reduce production unaryExpression -> arithmeticUnaryOperator castExpression 
-- On OREQUAL reduce production unaryExpression -> arithmeticUnaryOperator castExpression 
-- On OR reduce production unaryExpression -> arithmeticUnaryOperator castExpression 
-- On NEQUAL reduce production unaryExpression -> arithmeticUnaryOperator castExpression 
-- On MULEQUAL reduce production unaryExpression -> arithmeticUnaryOperator castExpression 
-- On MUL reduce production unaryExpression -> arithmeticUnaryOperator castExpression 
-- On MODEQUAL reduce production unaryExpression -> arithmeticUnaryOperator castExpression 
-- On MOD reduce production unaryExpression -> arithmeticUnaryOperator castExpression 
-- On MINUSEQUAL reduce production unaryExpression -> arithmeticUnaryOperator castExpression 
-- On MINUS reduce production unaryExpression -> arithmeticUnaryOperator castExpression 
-- On LTHAN reduce production unaryExpression -> arithmeticUnaryOperator castExpression 
-- On LSHIFTEQUAL reduce production unaryExpression -> arithmeticUnaryOperator castExpression 
-- On LSHIFT reduce production unaryExpression -> arithmeticUnaryOperator castExpression 
-- On LOGSHIFTEQUAL reduce production unaryExpression -> arithmeticUnaryOperator castExpression 
-- On LOGSHIFT reduce production unaryExpression -> arithmeticUnaryOperator castExpression 
-- On LETHAN reduce production unaryExpression -> arithmeticUnaryOperator castExpression 
-- On INSTANCEOF reduce production unaryExpression -> arithmeticUnaryOperator castExpression 
-- On GTHAN reduce production unaryExpression -> arithmeticUnaryOperator castExpression 
-- On GETHAN reduce production unaryExpression -> arithmeticUnaryOperator castExpression 
-- On EQUAL reduce production unaryExpression -> arithmeticUnaryOperator castExpression 
-- On DIVEQUAL reduce production unaryExpression -> arithmeticUnaryOperator castExpression 
-- On DIV reduce production unaryExpression -> arithmeticUnaryOperator castExpression 
-- On COMM reduce production unaryExpression -> arithmeticUnaryOperator castExpression 
-- On COL reduce production unaryExpression -> arithmeticUnaryOperator castExpression 
-- On BOR reduce production unaryExpression -> arithmeticUnaryOperator castExpression 
-- On BAND reduce production unaryExpression -> arithmeticUnaryOperator castExpression 
-- On ASSIGN reduce production unaryExpression -> arithmeticUnaryOperator castExpression 
-- On ANDEQUAL reduce production unaryExpression -> arithmeticUnaryOperator castExpression 
-- On AND reduce production unaryExpression -> arithmeticUnaryOperator castExpression 

State 123:
andExpression -> andExpression . BAND equalityExpression [ XOR SEMI RPAR RCURL RBRAC QM OR COMM COL BOR BAND AND ]
exclusiveOrExpression -> andExpression . [ XOR SEMI RPAR RCURL RBRAC QM OR COMM COL BOR AND ]
-- On BAND shift to state 124
-- On XOR reduce production exclusiveOrExpression -> andExpression 
-- On SEMI reduce production exclusiveOrExpression -> andExpression 
-- On RPAR reduce production exclusiveOrExpression -> andExpression 
-- On RCURL reduce production exclusiveOrExpression -> andExpression 
-- On RBRAC reduce production exclusiveOrExpression -> andExpression 
-- On QM reduce production exclusiveOrExpression -> andExpression 
-- On OR reduce production exclusiveOrExpression -> andExpression 
-- On COMM reduce production exclusiveOrExpression -> andExpression 
-- On COL reduce production exclusiveOrExpression -> andExpression 
-- On BOR reduce production exclusiveOrExpression -> andExpression 
-- On AND reduce production exclusiveOrExpression -> andExpression 

State 124:
andExpression -> andExpression BAND . equalityExpression [ XOR SEMI RPAR RCURL RBRAC QM OR COMM COL BOR BAND AND ]
-- On VOID shift to state 6
-- On THIS shift to state 7
-- On SUPER shift to state 8
-- On STRLIT shift to state 9
-- On SHORT shift to state 10
-- On PLUS shift to state 11
-- On NULLLIT shift to state 12
-- On NOT shift to state 13
-- On NEW shift to state 14
-- On MINUS shift to state 26
-- On LPAR shift to state 27
-- On LONG shift to state 15
-- On INTLIT shift to state 28
-- On INT shift to state 16
-- On INCREMENT shift to state 29
-- On IDENTIFIER shift to state 17
-- On FLOATLIT shift to state 31
-- On FLOAT shift to state 18
-- On DOUBLELIT shift to state 32
-- On DOUBLE shift to state 19
-- On DECREMENT shift to state 33
-- On CHARLIT shift to state 34
-- On CHAR shift to state 20
-- On BYTE shift to state 21
-- On BOOLEANLIT shift to state 35
-- On BOOLEAN shift to state 22
-- On BNOT shift to state 36
-- On unaryExpression shift to state 60
-- On specialName shift to state 38
-- On shiftExpression shift to state 58
-- On relationalExpression shift to state 79
-- On realPostfixExpression shift to state 39
-- On qualifiedName shift to state 42
-- On primitiveType shift to state 61
-- On primaryExpression shift to state 64
-- On postfixExpression shift to state 65
-- On plainNewAllocationExpression shift to state 68
-- On notJustName shift to state 69
-- On newAllocationExpression shift to state 72
-- On multiplicativeExpression shift to state 73
-- On methodCall shift to state 75
-- On methodAccess shift to state 76
-- On logicalUnaryOperator shift to state 83
-- On logicalUnaryExpression shift to state 85
-- On fieldAccess shift to state 86
-- On equalityExpression shift to state 125
-- On complexPrimaryNoParenthesis shift to state 87
-- On complexPrimary shift to state 88
-- On classAllocationExpression shift to state 100
-- On castExpression shift to state 103
-- On arrayAllocationExpression shift to state 104
-- On arrayAccess shift to state 120
-- On arithmeticUnaryOperator shift to state 121
-- On additiveExpression shift to state 140

State 125:
andExpression -> andExpression BAND equalityExpression . [ XOR SEMI RPAR RCURL RBRAC QM OR COMM COL BOR BAND AND ]
equalityExpression -> equalityExpression . EQUAL relationalExpression [ XOR SEMI RPAR RCURL RBRAC QM OR NEQUAL EQUAL COMM COL BOR BAND AND ]
equalityExpression -> equalityExpression . NEQUAL relationalExpression [ XOR SEMI RPAR RCURL RBRAC QM OR NEQUAL EQUAL COMM COL BOR BAND AND ]
-- On NEQUAL shift to state 95
-- On EQUAL shift to state 126
-- On XOR reduce production andExpression -> andExpression BAND equalityExpression 
-- On SEMI reduce production andExpression -> andExpression BAND equalityExpression 
-- On RPAR reduce production andExpression -> andExpression BAND equalityExpression 
-- On RCURL reduce production andExpression -> andExpression BAND equalityExpression 
-- On RBRAC reduce production andExpression -> andExpression BAND equalityExpression 
-- On QM reduce production andExpression -> andExpression BAND equalityExpression 
-- On OR reduce production andExpression -> andExpression BAND equalityExpression 
-- On COMM reduce production andExpression -> andExpression BAND equalityExpression 
-- On COL reduce production andExpression -> andExpression BAND equalityExpression 
-- On BOR reduce production andExpression -> andExpression BAND equalityExpression 
-- On BAND reduce production andExpression -> andExpression BAND equalityExpression 
-- On AND reduce production andExpression -> andExpression BAND equalityExpression 

State 126:
equalityExpression -> equalityExpression EQUAL . relationalExpression [ XOR SEMI RPAR RCURL RBRAC QM OR NEQUAL EQUAL COMM COL BOR BAND AND ]
-- On VOID shift to state 6
-- On THIS shift to state 7
-- On SUPER shift to state 8
-- On STRLIT shift to state 9
-- On SHORT shift to state 10
-- On PLUS shift to state 11
-- On NULLLIT shift to state 12
-- On NOT shift to state 13
-- On NEW shift to state 14
-- On MINUS shift to state 26
-- On LPAR shift to state 27
-- On LONG shift to state 15
-- On INTLIT shift to state 28
-- On INT shift to state 16
-- On INCREMENT shift to state 29
-- On IDENTIFIER shift to state 17
-- On FLOATLIT shift to state 31
-- On FLOAT shift to state 18
-- On DOUBLELIT shift to state 32
-- On DOUBLE shift to state 19
-- On DECREMENT shift to state 33
-- On CHARLIT shift to state 34
-- On CHAR shift to state 20
-- On BYTE shift to state 21
-- On BOOLEANLIT shift to state 35
-- On BOOLEAN shift to state 22
-- On BNOT shift to state 36
-- On unaryExpression shift to state 60
-- On specialName shift to state 38
-- On shiftExpression shift to state 58
-- On relationalExpression shift to state 127
-- On realPostfixExpression shift to state 39
-- On qualifiedName shift to state 42
-- On primitiveType shift to state 61
-- On primaryExpression shift to state 64
-- On postfixExpression shift to state 65
-- On plainNewAllocationExpression shift to state 68
-- On notJustName shift to state 69
-- On newAllocationExpression shift to state 72
-- On multiplicativeExpression shift to state 73
-- On methodCall shift to state 75
-- On methodAccess shift to state 76
-- On logicalUnaryOperator shift to state 83
-- On logicalUnaryExpression shift to state 85
-- On fieldAccess shift to state 86
-- On complexPrimaryNoParenthesis shift to state 87
-- On complexPrimary shift to state 88
-- On classAllocationExpression shift to state 100
-- On castExpression shift to state 103
-- On arrayAllocationExpression shift to state 104
-- On arrayAccess shift to state 120
-- On arithmeticUnaryOperator shift to state 121
-- On additiveExpression shift to state 140

State 127:
equalityExpression -> equalityExpression EQUAL relationalExpression . [ XOR SEMI RPAR RCURL RBRAC QM OR NEQUAL EQUAL COMM COL BOR BAND AND ]
relationalExpression -> relationalExpression . LTHAN shiftExpression [ XOR SEMI RPAR RCURL RBRAC QM OR NEQUAL LTHAN LETHAN INSTANCEOF GTHAN GETHAN EQUAL COMM COL BOR BAND AND ]
relationalExpression -> relationalExpression . GTHAN shiftExpression [ XOR SEMI RPAR RCURL RBRAC QM OR NEQUAL LTHAN LETHAN INSTANCEOF GTHAN GETHAN EQUAL COMM COL BOR BAND AND ]
relationalExpression -> relationalExpression . LETHAN shiftExpression [ XOR SEMI RPAR RCURL RBRAC QM OR NEQUAL LTHAN LETHAN INSTANCEOF GTHAN GETHAN EQUAL COMM COL BOR BAND AND ]
relationalExpression -> relationalExpression . GETHAN shiftExpression [ XOR SEMI RPAR RCURL RBRAC QM OR NEQUAL LTHAN LETHAN INSTANCEOF GTHAN GETHAN EQUAL COMM COL BOR BAND AND ]
relationalExpression -> relationalExpression . INSTANCEOF typeSpecifier [ XOR SEMI RPAR RCURL RBRAC QM OR NEQUAL LTHAN LETHAN INSTANCEOF GTHAN GETHAN EQUAL COMM COL BOR BAND AND ]
-- On LTHAN shift to state 80
-- On LETHAN shift to state 97
-- On INSTANCEOF shift to state 128
-- On GTHAN shift to state 138
-- On GETHAN shift to state 149
-- On XOR reduce production equalityExpression -> equalityExpression EQUAL relationalExpression 
-- On SEMI reduce production equalityExpression -> equalityExpression EQUAL relationalExpression 
-- On RPAR reduce production equalityExpression -> equalityExpression EQUAL relationalExpression 
-- On RCURL reduce production equalityExpression -> equalityExpression EQUAL relationalExpression 
-- On RBRAC reduce production equalityExpression -> equalityExpression EQUAL relationalExpression 
-- On QM reduce production equalityExpression -> equalityExpression EQUAL relationalExpression 
-- On OR reduce production equalityExpression -> equalityExpression EQUAL relationalExpression 
-- On NEQUAL reduce production equalityExpression -> equalityExpression EQUAL relationalExpression 
-- On EQUAL reduce production equalityExpression -> equalityExpression EQUAL relationalExpression 
-- On COMM reduce production equalityExpression -> equalityExpression EQUAL relationalExpression 
-- On COL reduce production equalityExpression -> equalityExpression EQUAL relationalExpression 
-- On BOR reduce production equalityExpression -> equalityExpression EQUAL relationalExpression 
-- On BAND reduce production equalityExpression -> equalityExpression EQUAL relationalExpression 
-- On AND reduce production equalityExpression -> equalityExpression EQUAL relationalExpression 

State 128:
relationalExpression -> relationalExpression INSTANCEOF . typeSpecifier [ XOR SEMI RPAR RCURL RBRAC QM OR NEQUAL LTHAN LETHAN INSTANCEOF GTHAN GETHAN EQUAL COMM COL BOR BAND AND ]
-- On VOID shift to state 6
-- On SHORT shift to state 10
-- On LONG shift to state 15
-- On INT shift to state 16
-- On IDENTIFIER shift to state 17
-- On FLOAT shift to state 18
-- On DOUBLE shift to state 19
-- On CHAR shift to state 20
-- On BYTE shift to state 21
-- On BOOLEAN shift to state 22
-- On typeSpecifier shift to state 129
-- On typeName shift to state 130
-- On qualifiedName shift to state 134
-- On primitiveType shift to state 137

State 129:
relationalExpression -> relationalExpression INSTANCEOF typeSpecifier . [ XOR SEMI RPAR RCURL RBRAC QM OR NEQUAL LTHAN LETHAN INSTANCEOF GTHAN GETHAN EQUAL COMM COL BOR BAND AND ]
-- On XOR reduce production relationalExpression -> relationalExpression INSTANCEOF typeSpecifier 
-- On SEMI reduce production relationalExpression -> relationalExpression INSTANCEOF typeSpecifier 
-- On RPAR reduce production relationalExpression -> relationalExpression INSTANCEOF typeSpecifier 
-- On RCURL reduce production relationalExpression -> relationalExpression INSTANCEOF typeSpecifier 
-- On RBRAC reduce production relationalExpression -> relationalExpression INSTANCEOF typeSpecifier 
-- On QM reduce production relationalExpression -> relationalExpression INSTANCEOF typeSpecifier 
-- On OR reduce production relationalExpression -> relationalExpression INSTANCEOF typeSpecifier 
-- On NEQUAL reduce production relationalExpression -> relationalExpression INSTANCEOF typeSpecifier 
-- On LTHAN reduce production relationalExpression -> relationalExpression INSTANCEOF typeSpecifier 
-- On LETHAN reduce production relationalExpression -> relationalExpression INSTANCEOF typeSpecifier 
-- On INSTANCEOF reduce production relationalExpression -> relationalExpression INSTANCEOF typeSpecifier 
-- On GTHAN reduce production relationalExpression -> relationalExpression INSTANCEOF typeSpecifier 
-- On GETHAN reduce production relationalExpression -> relationalExpression INSTANCEOF typeSpecifier 
-- On EQUAL reduce production relationalExpression -> relationalExpression INSTANCEOF typeSpecifier 
-- On COMM reduce production relationalExpression -> relationalExpression INSTANCEOF typeSpecifier 
-- On COL reduce production relationalExpression -> relationalExpression INSTANCEOF typeSpecifier 
-- On BOR reduce production relationalExpression -> relationalExpression INSTANCEOF typeSpecifier 
-- On BAND reduce production relationalExpression -> relationalExpression INSTANCEOF typeSpecifier 
-- On AND reduce production relationalExpression -> relationalExpression INSTANCEOF typeSpecifier 

State 130:
typeSpecifier -> typeName . [ XOR SEMI RPAR RCURL RBRAC QM OR NEQUAL LTHAN LETHAN INSTANCEOF IDENTIFIER GTHAN GETHAN EQUAL COMM COL BOR BAND AND ]
typeSpecifier -> typeName . dims [ XOR SEMI RPAR RCURL RBRAC QM OR NEQUAL LTHAN LETHAN INSTANCEOF IDENTIFIER GTHAN GETHAN EQUAL COMM COL BOR BAND AND ]
-- On DIM shift to state 131
-- On dims shift to state 132
-- On XOR reduce production typeSpecifier -> typeName 
-- On SEMI reduce production typeSpecifier -> typeName 
-- On RPAR reduce production typeSpecifier -> typeName 
-- On RCURL reduce production typeSpecifier -> typeName 
-- On RBRAC reduce production typeSpecifier -> typeName 
-- On QM reduce production typeSpecifier -> typeName 
-- On OR reduce production typeSpecifier -> typeName 
-- On NEQUAL reduce production typeSpecifier -> typeName 
-- On LTHAN reduce production typeSpecifier -> typeName 
-- On LETHAN reduce production typeSpecifier -> typeName 
-- On INSTANCEOF reduce production typeSpecifier -> typeName 
-- On IDENTIFIER reduce production typeSpecifier -> typeName 
-- On GTHAN reduce production typeSpecifier -> typeName 
-- On GETHAN reduce production typeSpecifier -> typeName 
-- On EQUAL reduce production typeSpecifier -> typeName 
-- On COMM reduce production typeSpecifier -> typeName 
-- On COL reduce production typeSpecifier -> typeName 
-- On BOR reduce production typeSpecifier -> typeName 
-- On BAND reduce production typeSpecifier -> typeName 
-- On AND reduce production typeSpecifier -> typeName 

State 131:
dims -> DIM . [ XOREQUAL XOR SEMI RSHIFTEQUAL RSHIFT RPAR RCURL RBRAC QM PLUS PEQUAL OREQUAL OR NEQUAL MULEQUAL MUL MODEQUAL MOD MINUSEQUAL MINUS LTHAN LSHIFTEQUAL LSHIFT LOGSHIFTEQUAL LOGSHIFT LETHAN LCURL INSTANCEOF INCREMENT IDENTIFIER GTHAN GETHAN EQUAL DOT DIVEQUAL DIV DIM DECREMENT COMM COL BOR BAND ASSIGN ANDEQUAL AND ]
-- On XOREQUAL reduce production dims -> DIM 
-- On XOR reduce production dims -> DIM 
-- On SEMI reduce production dims -> DIM 
-- On RSHIFTEQUAL reduce production dims -> DIM 
-- On RSHIFT reduce production dims -> DIM 
-- On RPAR reduce production dims -> DIM 
-- On RCURL reduce production dims -> DIM 
-- On RBRAC reduce production dims -> DIM 
-- On QM reduce production dims -> DIM 
-- On PLUS reduce production dims -> DIM 
-- On PEQUAL reduce production dims -> DIM 
-- On OREQUAL reduce production dims -> DIM 
-- On OR reduce production dims -> DIM 
-- On NEQUAL reduce production dims -> DIM 
-- On MULEQUAL reduce production dims -> DIM 
-- On MUL reduce production dims -> DIM 
-- On MODEQUAL reduce production dims -> DIM 
-- On MOD reduce production dims -> DIM 
-- On MINUSEQUAL reduce production dims -> DIM 
-- On MINUS reduce production dims -> DIM 
-- On LTHAN reduce production dims -> DIM 
-- On LSHIFTEQUAL reduce production dims -> DIM 
-- On LSHIFT reduce production dims -> DIM 
-- On LOGSHIFTEQUAL reduce production dims -> DIM 
-- On LOGSHIFT reduce production dims -> DIM 
-- On LETHAN reduce production dims -> DIM 
-- On LCURL reduce production dims -> DIM 
-- On INSTANCEOF reduce production dims -> DIM 
-- On INCREMENT reduce production dims -> DIM 
-- On IDENTIFIER reduce production dims -> DIM 
-- On GTHAN reduce production dims -> DIM 
-- On GETHAN reduce production dims -> DIM 
-- On EQUAL reduce production dims -> DIM 
-- On DOT reduce production dims -> DIM 
-- On DIVEQUAL reduce production dims -> DIM 
-- On DIV reduce production dims -> DIM 
-- On DIM reduce production dims -> DIM 
-- On DECREMENT reduce production dims -> DIM 
-- On COMM reduce production dims -> DIM 
-- On COL reduce production dims -> DIM 
-- On BOR reduce production dims -> DIM 
-- On BAND reduce production dims -> DIM 
-- On ASSIGN reduce production dims -> DIM 
-- On ANDEQUAL reduce production dims -> DIM 
-- On AND reduce production dims -> DIM 

State 132:
dims -> dims . DIM [ XOR SEMI RPAR RCURL RBRAC QM OR NEQUAL LTHAN LETHAN INSTANCEOF IDENTIFIER GTHAN GETHAN EQUAL DIM COMM COL BOR BAND AND ]
typeSpecifier -> typeName dims . [ XOR SEMI RPAR RCURL RBRAC QM OR NEQUAL LTHAN LETHAN INSTANCEOF IDENTIFIER GTHAN GETHAN EQUAL COMM COL BOR BAND AND ]
-- On DIM shift to state 133
-- On XOR reduce production typeSpecifier -> typeName dims 
-- On SEMI reduce production typeSpecifier -> typeName dims 
-- On RPAR reduce production typeSpecifier -> typeName dims 
-- On RCURL reduce production typeSpecifier -> typeName dims 
-- On RBRAC reduce production typeSpecifier -> typeName dims 
-- On QM reduce production typeSpecifier -> typeName dims 
-- On OR reduce production typeSpecifier -> typeName dims 
-- On NEQUAL reduce production typeSpecifier -> typeName dims 
-- On LTHAN reduce production typeSpecifier -> typeName dims 
-- On LETHAN reduce production typeSpecifier -> typeName dims 
-- On INSTANCEOF reduce production typeSpecifier -> typeName dims 
-- On IDENTIFIER reduce production typeSpecifier -> typeName dims 
-- On GTHAN reduce production typeSpecifier -> typeName dims 
-- On GETHAN reduce production typeSpecifier -> typeName dims 
-- On EQUAL reduce production typeSpecifier -> typeName dims 
-- On COMM reduce production typeSpecifier -> typeName dims 
-- On COL reduce production typeSpecifier -> typeName dims 
-- On BOR reduce production typeSpecifier -> typeName dims 
-- On BAND reduce production typeSpecifier -> typeName dims 
-- On AND reduce production typeSpecifier -> typeName dims 

State 133:
dims -> dims DIM . [ XOREQUAL XOR SEMI RSHIFTEQUAL RSHIFT RPAR RCURL RBRAC QM PLUS PEQUAL OREQUAL OR NEQUAL MULEQUAL MUL MODEQUAL MOD MINUSEQUAL MINUS LTHAN LSHIFTEQUAL LSHIFT LOGSHIFTEQUAL LOGSHIFT LETHAN LCURL INSTANCEOF INCREMENT IDENTIFIER GTHAN GETHAN EQUAL DOT DIVEQUAL DIV DIM DECREMENT COMM COL BOR BAND ASSIGN ANDEQUAL AND ]
-- On XOREQUAL reduce production dims -> dims DIM 
-- On XOR reduce production dims -> dims DIM 
-- On SEMI reduce production dims -> dims DIM 
-- On RSHIFTEQUAL reduce production dims -> dims DIM 
-- On RSHIFT reduce production dims -> dims DIM 
-- On RPAR reduce production dims -> dims DIM 
-- On RCURL reduce production dims -> dims DIM 
-- On RBRAC reduce production dims -> dims DIM 
-- On QM reduce production dims -> dims DIM 
-- On PLUS reduce production dims -> dims DIM 
-- On PEQUAL reduce production dims -> dims DIM 
-- On OREQUAL reduce production dims -> dims DIM 
-- On OR reduce production dims -> dims DIM 
-- On NEQUAL reduce production dims -> dims DIM 
-- On MULEQUAL reduce production dims -> dims DIM 
-- On MUL reduce production dims -> dims DIM 
-- On MODEQUAL reduce production dims -> dims DIM 
-- On MOD reduce production dims -> dims DIM 
-- On MINUSEQUAL reduce production dims -> dims DIM 
-- On MINUS reduce production dims -> dims DIM 
-- On LTHAN reduce production dims -> dims DIM 
-- On LSHIFTEQUAL reduce production dims -> dims DIM 
-- On LSHIFT reduce production dims -> dims DIM 
-- On LOGSHIFTEQUAL reduce production dims -> dims DIM 
-- On LOGSHIFT reduce production dims -> dims DIM 
-- On LETHAN reduce production dims -> dims DIM 
-- On LCURL reduce production dims -> dims DIM 
-- On INSTANCEOF reduce production dims -> dims DIM 
-- On INCREMENT reduce production dims -> dims DIM 
-- On IDENTIFIER reduce production dims -> dims DIM 
-- On GTHAN reduce production dims -> dims DIM 
-- On GETHAN reduce production dims -> dims DIM 
-- On EQUAL reduce production dims -> dims DIM 
-- On DOT reduce production dims -> dims DIM 
-- On DIVEQUAL reduce production dims -> dims DIM 
-- On DIV reduce production dims -> dims DIM 
-- On DIM reduce production dims -> dims DIM 
-- On DECREMENT reduce production dims -> dims DIM 
-- On COMM reduce production dims -> dims DIM 
-- On COL reduce production dims -> dims DIM 
-- On BOR reduce production dims -> dims DIM 
-- On BAND reduce production dims -> dims DIM 
-- On ASSIGN reduce production dims -> dims DIM 
-- On ANDEQUAL reduce production dims -> dims DIM 
-- On AND reduce production dims -> dims DIM 

State 134:
qualifiedName -> qualifiedName . DOT IDENTIFIER [ XOR SEMI RPAR RCURL RBRAC QM OR NEQUAL LTHAN LPAR LETHAN LBRAC INSTANCEOF IDENTIFIER GTHAN GETHAN EQUAL DOT DIM COMM COL BOR BAND AND ]
typeName -> qualifiedName . [ XOR SEMI RPAR RCURL RBRAC QM OR NEQUAL LTHAN LPAR LETHAN LBRAC INSTANCEOF IDENTIFIER GTHAN GETHAN EQUAL DIM COMM COL BOR BAND AND ]
-- On DOT shift to state 135
-- On XOR reduce production typeName -> qualifiedName 
-- On SEMI reduce production typeName -> qualifiedName 
-- On RPAR reduce production typeName -> qualifiedName 
-- On RCURL reduce production typeName -> qualifiedName 
-- On RBRAC reduce production typeName -> qualifiedName 
-- On QM reduce production typeName -> qualifiedName 
-- On OR reduce production typeName -> qualifiedName 
-- On NEQUAL reduce production typeName -> qualifiedName 
-- On LTHAN reduce production typeName -> qualifiedName 
-- On LPAR reduce production typeName -> qualifiedName 
-- On LETHAN reduce production typeName -> qualifiedName 
-- On LBRAC reduce production typeName -> qualifiedName 
-- On INSTANCEOF reduce production typeName -> qualifiedName 
-- On IDENTIFIER reduce production typeName -> qualifiedName 
-- On GTHAN reduce production typeName -> qualifiedName 
-- On GETHAN reduce production typeName -> qualifiedName 
-- On EQUAL reduce production typeName -> qualifiedName 
-- On DIM reduce production typeName -> qualifiedName 
-- On COMM reduce production typeName -> qualifiedName 
-- On COL reduce production typeName -> qualifiedName 
-- On BOR reduce production typeName -> qualifiedName 
-- On BAND reduce production typeName -> qualifiedName 
-- On AND reduce production typeName -> qualifiedName 

State 135:
qualifiedName -> qualifiedName DOT . IDENTIFIER [ XOR SEMI RPAR RCURL RBRAC QM OR NEQUAL LTHAN LPAR LETHAN LBRAC INSTANCEOF IDENTIFIER GTHAN GETHAN EQUAL DOT DIM COMM COL BOR BAND AND ]
-- On IDENTIFIER shift to state 136

State 136:
qualifiedName -> qualifiedName DOT IDENTIFIER . [ XOREQUAL XOR SEMI RSHIFTEQUAL RSHIFT RPAR RCURL RBRAC QM PLUS PEQUAL OREQUAL OR NEQUAL MULEQUAL MUL MODEQUAL MOD MINUSEQUAL MINUS LTHAN LSHIFTEQUAL LSHIFT LPAR LOGSHIFTEQUAL LOGSHIFT LETHAN LBRAC INSTANCEOF INCREMENT IDENTIFIER GTHAN GETHAN EQUAL DOT DIVEQUAL DIV DIM DECREMENT COMM COL BOR BAND ASSIGN ANDEQUAL AND ]
-- On XOREQUAL reduce production qualifiedName -> qualifiedName DOT IDENTIFIER 
-- On XOR reduce production qualifiedName -> qualifiedName DOT IDENTIFIER 
-- On SEMI reduce production qualifiedName -> qualifiedName DOT IDENTIFIER 
-- On RSHIFTEQUAL reduce production qualifiedName -> qualifiedName DOT IDENTIFIER 
-- On RSHIFT reduce production qualifiedName -> qualifiedName DOT IDENTIFIER 
-- On RPAR reduce production qualifiedName -> qualifiedName DOT IDENTIFIER 
-- On RCURL reduce production qualifiedName -> qualifiedName DOT IDENTIFIER 
-- On RBRAC reduce production qualifiedName -> qualifiedName DOT IDENTIFIER 
-- On QM reduce production qualifiedName -> qualifiedName DOT IDENTIFIER 
-- On PLUS reduce production qualifiedName -> qualifiedName DOT IDENTIFIER 
-- On PEQUAL reduce production qualifiedName -> qualifiedName DOT IDENTIFIER 
-- On OREQUAL reduce production qualifiedName -> qualifiedName DOT IDENTIFIER 
-- On OR reduce production qualifiedName -> qualifiedName DOT IDENTIFIER 
-- On NEQUAL reduce production qualifiedName -> qualifiedName DOT IDENTIFIER 
-- On MULEQUAL reduce production qualifiedName -> qualifiedName DOT IDENTIFIER 
-- On MUL reduce production qualifiedName -> qualifiedName DOT IDENTIFIER 
-- On MODEQUAL reduce production qualifiedName -> qualifiedName DOT IDENTIFIER 
-- On MOD reduce production qualifiedName -> qualifiedName DOT IDENTIFIER 
-- On MINUSEQUAL reduce production qualifiedName -> qualifiedName DOT IDENTIFIER 
-- On MINUS reduce production qualifiedName -> qualifiedName DOT IDENTIFIER 
-- On LTHAN reduce production qualifiedName -> qualifiedName DOT IDENTIFIER 
-- On LSHIFTEQUAL reduce production qualifiedName -> qualifiedName DOT IDENTIFIER 
-- On LSHIFT reduce production qualifiedName -> qualifiedName DOT IDENTIFIER 
-- On LPAR reduce production qualifiedName -> qualifiedName DOT IDENTIFIER 
-- On LOGSHIFTEQUAL reduce production qualifiedName -> qualifiedName DOT IDENTIFIER 
-- On LOGSHIFT reduce production qualifiedName -> qualifiedName DOT IDENTIFIER 
-- On LETHAN reduce production qualifiedName -> qualifiedName DOT IDENTIFIER 
-- On LBRAC reduce production qualifiedName -> qualifiedName DOT IDENTIFIER 
-- On INSTANCEOF reduce production qualifiedName -> qualifiedName DOT IDENTIFIER 
-- On INCREMENT reduce production qualifiedName -> qualifiedName DOT IDENTIFIER 
-- On IDENTIFIER reduce production qualifiedName -> qualifiedName DOT IDENTIFIER 
-- On GTHAN reduce production qualifiedName -> qualifiedName DOT IDENTIFIER 
-- On GETHAN reduce production qualifiedName -> qualifiedName DOT IDENTIFIER 
-- On EQUAL reduce production qualifiedName -> qualifiedName DOT IDENTIFIER 
-- On DOT reduce production qualifiedName -> qualifiedName DOT IDENTIFIER 
-- On DIVEQUAL reduce production qualifiedName -> qualifiedName DOT IDENTIFIER 
-- On DIV reduce production qualifiedName -> qualifiedName DOT IDENTIFIER 
-- On DIM reduce production qualifiedName -> qualifiedName DOT IDENTIFIER 
-- On DECREMENT reduce production qualifiedName -> qualifiedName DOT IDENTIFIER 
-- On COMM reduce production qualifiedName -> qualifiedName DOT IDENTIFIER 
-- On COL reduce production qualifiedName -> qualifiedName DOT IDENTIFIER 
-- On BOR reduce production qualifiedName -> qualifiedName DOT IDENTIFIER 
-- On BAND reduce production qualifiedName -> qualifiedName DOT IDENTIFIER 
-- On ASSIGN reduce production qualifiedName -> qualifiedName DOT IDENTIFIER 
-- On ANDEQUAL reduce production qualifiedName -> qualifiedName DOT IDENTIFIER 
-- On AND reduce production qualifiedName -> qualifiedName DOT IDENTIFIER 

State 137:
typeName -> primitiveType . [ XOR SEMI RPAR RCURL RBRAC QM OR NEQUAL LTHAN LPAR LETHAN LBRAC INSTANCEOF IDENTIFIER GTHAN GETHAN EQUAL DIM COMM COL BOR BAND AND ]
-- On XOR reduce production typeName -> primitiveType 
-- On SEMI reduce production typeName -> primitiveType 
-- On RPAR reduce production typeName -> primitiveType 
-- On RCURL reduce production typeName -> primitiveType 
-- On RBRAC reduce production typeName -> primitiveType 
-- On QM reduce production typeName -> primitiveType 
-- On OR reduce production typeName -> primitiveType 
-- On NEQUAL reduce production typeName -> primitiveType 
-- On LTHAN reduce production typeName -> primitiveType 
-- On LPAR reduce production typeName -> primitiveType 
-- On LETHAN reduce production typeName -> primitiveType 
-- On LBRAC reduce production typeName -> primitiveType 
-- On INSTANCEOF reduce production typeName -> primitiveType 
-- On IDENTIFIER reduce production typeName -> primitiveType 
-- On GTHAN reduce production typeName -> primitiveType 
-- On GETHAN reduce production typeName -> primitiveType 
-- On EQUAL reduce production typeName -> primitiveType 
-- On DIM reduce production typeName -> primitiveType 
-- On COMM reduce production typeName -> primitiveType 
-- On COL reduce production typeName -> primitiveType 
-- On BOR reduce production typeName -> primitiveType 
-- On BAND reduce production typeName -> primitiveType 
-- On AND reduce production typeName -> primitiveType 

State 138:
relationalExpression -> relationalExpression GTHAN . shiftExpression [ XOR SEMI RPAR RCURL RBRAC QM OR NEQUAL LTHAN LETHAN INSTANCEOF GTHAN GETHAN EQUAL COMM COL BOR BAND AND ]
-- On VOID shift to state 6
-- On THIS shift to state 7
-- On SUPER shift to state 8
-- On STRLIT shift to state 9
-- On SHORT shift to state 10
-- On PLUS shift to state 11
-- On NULLLIT shift to state 12
-- On NOT shift to state 13
-- On NEW shift to state 14
-- On MINUS shift to state 26
-- On LPAR shift to state 27
-- On LONG shift to state 15
-- On INTLIT shift to state 28
-- On INT shift to state 16
-- On INCREMENT shift to state 29
-- On IDENTIFIER shift to state 17
-- On FLOATLIT shift to state 31
-- On FLOAT shift to state 18
-- On DOUBLELIT shift to state 32
-- On DOUBLE shift to state 19
-- On DECREMENT shift to state 33
-- On CHARLIT shift to state 34
-- On CHAR shift to state 20
-- On BYTE shift to state 21
-- On BOOLEANLIT shift to state 35
-- On BOOLEAN shift to state 22
-- On BNOT shift to state 36
-- On unaryExpression shift to state 60
-- On specialName shift to state 38
-- On shiftExpression shift to state 139
-- On realPostfixExpression shift to state 39
-- On qualifiedName shift to state 42
-- On primitiveType shift to state 61
-- On primaryExpression shift to state 64
-- On postfixExpression shift to state 65
-- On plainNewAllocationExpression shift to state 68
-- On notJustName shift to state 69
-- On newAllocationExpression shift to state 72
-- On multiplicativeExpression shift to state 73
-- On methodCall shift to state 75
-- On methodAccess shift to state 76
-- On logicalUnaryOperator shift to state 83
-- On logicalUnaryExpression shift to state 85
-- On fieldAccess shift to state 86
-- On complexPrimaryNoParenthesis shift to state 87
-- On complexPrimary shift to state 88
-- On classAllocationExpression shift to state 100
-- On castExpression shift to state 103
-- On arrayAllocationExpression shift to state 104
-- On arrayAccess shift to state 120
-- On arithmeticUnaryOperator shift to state 121
-- On additiveExpression shift to state 140

State 139:
relationalExpression -> relationalExpression GTHAN shiftExpression . [ XOR SEMI RPAR RCURL RBRAC QM OR NEQUAL LTHAN LETHAN INSTANCEOF GTHAN GETHAN EQUAL COMM COL BOR BAND AND ]
shiftExpression -> shiftExpression . LSHIFT additiveExpression [ XOR SEMI RSHIFT RPAR RCURL RBRAC QM OR NEQUAL LTHAN LSHIFT LOGSHIFT LETHAN INSTANCEOF GTHAN GETHAN EQUAL COMM COL BOR BAND AND ]
shiftExpression -> shiftExpression . RSHIFT additiveExpression [ XOR SEMI RSHIFT RPAR RCURL RBRAC QM OR NEQUAL LTHAN LSHIFT LOGSHIFT LETHAN INSTANCEOF GTHAN GETHAN EQUAL COMM COL BOR BAND AND ]
shiftExpression -> shiftExpression . LOGSHIFT additiveExpression [ XOR SEMI RSHIFT RPAR RCURL RBRAC QM OR NEQUAL LTHAN LSHIFT LOGSHIFT LETHAN INSTANCEOF GTHAN GETHAN EQUAL COMM COL BOR BAND AND ]
-- On RSHIFT shift to state 59
-- On LSHIFT shift to state 82
-- On LOGSHIFT shift to state 99
-- On XOR reduce production relationalExpression -> relationalExpression GTHAN shiftExpression 
-- On SEMI reduce production relationalExpression -> relationalExpression GTHAN shiftExpression 
-- On RPAR reduce production relationalExpression -> relationalExpression GTHAN shiftExpression 
-- On RCURL reduce production relationalExpression -> relationalExpression GTHAN shiftExpression 
-- On RBRAC reduce production relationalExpression -> relationalExpression GTHAN shiftExpression 
-- On QM reduce production relationalExpression -> relationalExpression GTHAN shiftExpression 
-- On OR reduce production relationalExpression -> relationalExpression GTHAN shiftExpression 
-- On NEQUAL reduce production relationalExpression -> relationalExpression GTHAN shiftExpression 
-- On LTHAN reduce production relationalExpression -> relationalExpression GTHAN shiftExpression 
-- On LETHAN reduce production relationalExpression -> relationalExpression GTHAN shiftExpression 
-- On INSTANCEOF reduce production relationalExpression -> relationalExpression GTHAN shiftExpression 
-- On GTHAN reduce production relationalExpression -> relationalExpression GTHAN shiftExpression 
-- On GETHAN reduce production relationalExpression -> relationalExpression GTHAN shiftExpression 
-- On EQUAL reduce production relationalExpression -> relationalExpression GTHAN shiftExpression 
-- On COMM reduce production relationalExpression -> relationalExpression GTHAN shiftExpression 
-- On COL reduce production relationalExpression -> relationalExpression GTHAN shiftExpression 
-- On BOR reduce production relationalExpression -> relationalExpression GTHAN shiftExpression 
-- On BAND reduce production relationalExpression -> relationalExpression GTHAN shiftExpression 
-- On AND reduce production relationalExpression -> relationalExpression GTHAN shiftExpression 

State 140:
additiveExpression -> additiveExpression . PLUS multiplicativeExpression [ XOR SEMI RSHIFT RPAR RCURL RBRAC QM PLUS OR NEQUAL MINUS LTHAN LSHIFT LOGSHIFT LETHAN INSTANCEOF GTHAN GETHAN EQUAL COMM COL BOR BAND AND ]
additiveExpression -> additiveExpression . MINUS multiplicativeExpression [ XOR SEMI RSHIFT RPAR RCURL RBRAC QM PLUS OR NEQUAL MINUS LTHAN LSHIFT LOGSHIFT LETHAN INSTANCEOF GTHAN GETHAN EQUAL COMM COL BOR BAND AND ]
shiftExpression -> additiveExpression . [ XOR SEMI RSHIFT RPAR RCURL RBRAC QM OR NEQUAL LTHAN LSHIFT LOGSHIFT LETHAN INSTANCEOF GTHAN GETHAN EQUAL COMM COL BOR BAND AND ]
-- On PLUS shift to state 141
-- On MINUS shift to state 147
-- On XOR reduce production shiftExpression -> additiveExpression 
-- On SEMI reduce production shiftExpression -> additiveExpression 
-- On RSHIFT reduce production shiftExpression -> additiveExpression 
-- On RPAR reduce production shiftExpression -> additiveExpression 
-- On RCURL reduce production shiftExpression -> additiveExpression 
-- On RBRAC reduce production shiftExpression -> additiveExpression 
-- On QM reduce production shiftExpression -> additiveExpression 
-- On OR reduce production shiftExpression -> additiveExpression 
-- On NEQUAL reduce production shiftExpression -> additiveExpression 
-- On LTHAN reduce production shiftExpression -> additiveExpression 
-- On LSHIFT reduce production shiftExpression -> additiveExpression 
-- On LOGSHIFT reduce production shiftExpression -> additiveExpression 
-- On LETHAN reduce production shiftExpression -> additiveExpression 
-- On INSTANCEOF reduce production shiftExpression -> additiveExpression 
-- On GTHAN reduce production shiftExpression -> additiveExpression 
-- On GETHAN reduce production shiftExpression -> additiveExpression 
-- On EQUAL reduce production shiftExpression -> additiveExpression 
-- On COMM reduce production shiftExpression -> additiveExpression 
-- On COL reduce production shiftExpression -> additiveExpression 
-- On BOR reduce production shiftExpression -> additiveExpression 
-- On BAND reduce production shiftExpression -> additiveExpression 
-- On AND reduce production shiftExpression -> additiveExpression 

State 141:
additiveExpression -> additiveExpression PLUS . multiplicativeExpression [ XOR SEMI RSHIFT RPAR RCURL RBRAC QM PLUS OR NEQUAL MINUS LTHAN LSHIFT LOGSHIFT LETHAN INSTANCEOF GTHAN GETHAN EQUAL COMM COL BOR BAND AND ]
-- On VOID shift to state 6
-- On THIS shift to state 7
-- On SUPER shift to state 8
-- On STRLIT shift to state 9
-- On SHORT shift to state 10
-- On PLUS shift to state 11
-- On NULLLIT shift to state 12
-- On NOT shift to state 13
-- On NEW shift to state 14
-- On MINUS shift to state 26
-- On LPAR shift to state 27
-- On LONG shift to state 15
-- On INTLIT shift to state 28
-- On INT shift to state 16
-- On INCREMENT shift to state 29
-- On IDENTIFIER shift to state 17
-- On FLOATLIT shift to state 31
-- On FLOAT shift to state 18
-- On DOUBLELIT shift to state 32
-- On DOUBLE shift to state 19
-- On DECREMENT shift to state 33
-- On CHARLIT shift to state 34
-- On CHAR shift to state 20
-- On BYTE shift to state 21
-- On BOOLEANLIT shift to state 35
-- On BOOLEAN shift to state 22
-- On BNOT shift to state 36
-- On unaryExpression shift to state 60
-- On specialName shift to state 38
-- On realPostfixExpression shift to state 39
-- On qualifiedName shift to state 42
-- On primitiveType shift to state 61
-- On primaryExpression shift to state 64
-- On postfixExpression shift to state 65
-- On plainNewAllocationExpression shift to state 68
-- On notJustName shift to state 69
-- On newAllocationExpression shift to state 72
-- On multiplicativeExpression shift to state 142
-- On methodCall shift to state 75
-- On methodAccess shift to state 76
-- On logicalUnaryOperator shift to state 83
-- On logicalUnaryExpression shift to state 85
-- On fieldAccess shift to state 86
-- On complexPrimaryNoParenthesis shift to state 87
-- On complexPrimary shift to state 88
-- On classAllocationExpression shift to state 100
-- On castExpression shift to state 103
-- On arrayAllocationExpression shift to state 104
-- On arrayAccess shift to state 120
-- On arithmeticUnaryOperator shift to state 121

State 142:
additiveExpression -> additiveExpression PLUS multiplicativeExpression . [ XOR SEMI RSHIFT RPAR RCURL RBRAC QM PLUS OR NEQUAL MINUS LTHAN LSHIFT LOGSHIFT LETHAN INSTANCEOF GTHAN GETHAN EQUAL COMM COL BOR BAND AND ]
multiplicativeExpression -> multiplicativeExpression . MUL castExpression [ XOR SEMI RSHIFT RPAR RCURL RBRAC QM PLUS OR NEQUAL MUL MOD MINUS LTHAN LSHIFT LOGSHIFT LETHAN INSTANCEOF GTHAN GETHAN EQUAL DIV COMM COL BOR BAND AND ]
multiplicativeExpression -> multiplicativeExpression . DIV castExpression [ XOR SEMI RSHIFT RPAR RCURL RBRAC QM PLUS OR NEQUAL MUL MOD MINUS LTHAN LSHIFT LOGSHIFT LETHAN INSTANCEOF GTHAN GETHAN EQUAL DIV COMM COL BOR BAND AND ]
multiplicativeExpression -> multiplicativeExpression . MOD castExpression [ XOR SEMI RSHIFT RPAR RCURL RBRAC QM PLUS OR NEQUAL MUL MOD MINUS LTHAN LSHIFT LOGSHIFT LETHAN INSTANCEOF GTHAN GETHAN EQUAL DIV COMM COL BOR BAND AND ]
-- On MUL shift to state 74
-- On MOD shift to state 143
-- On DIV shift to state 145
-- On XOR reduce production additiveExpression -> additiveExpression PLUS multiplicativeExpression 
-- On SEMI reduce production additiveExpression -> additiveExpression PLUS multiplicativeExpression 
-- On RSHIFT reduce production additiveExpression -> additiveExpression PLUS multiplicativeExpression 
-- On RPAR reduce production additiveExpression -> additiveExpression PLUS multiplicativeExpression 
-- On RCURL reduce production additiveExpression -> additiveExpression PLUS multiplicativeExpression 
-- On RBRAC reduce production additiveExpression -> additiveExpression PLUS multiplicativeExpression 
-- On QM reduce production additiveExpression -> additiveExpression PLUS multiplicativeExpression 
-- On PLUS reduce production additiveExpression -> additiveExpression PLUS multiplicativeExpression 
-- On OR reduce production additiveExpression -> additiveExpression PLUS multiplicativeExpression 
-- On NEQUAL reduce production additiveExpression -> additiveExpression PLUS multiplicativeExpression 
-- On MINUS reduce production additiveExpression -> additiveExpression PLUS multiplicativeExpression 
-- On LTHAN reduce production additiveExpression -> additiveExpression PLUS multiplicativeExpression 
-- On LSHIFT reduce production additiveExpression -> additiveExpression PLUS multiplicativeExpression 
-- On LOGSHIFT reduce production additiveExpression -> additiveExpression PLUS multiplicativeExpression 
-- On LETHAN reduce production additiveExpression -> additiveExpression PLUS multiplicativeExpression 
-- On INSTANCEOF reduce production additiveExpression -> additiveExpression PLUS multiplicativeExpression 
-- On GTHAN reduce production additiveExpression -> additiveExpression PLUS multiplicativeExpression 
-- On GETHAN reduce production additiveExpression -> additiveExpression PLUS multiplicativeExpression 
-- On EQUAL reduce production additiveExpression -> additiveExpression PLUS multiplicativeExpression 
-- On COMM reduce production additiveExpression -> additiveExpression PLUS multiplicativeExpression 
-- On COL reduce production additiveExpression -> additiveExpression PLUS multiplicativeExpression 
-- On BOR reduce production additiveExpression -> additiveExpression PLUS multiplicativeExpression 
-- On BAND reduce production additiveExpression -> additiveExpression PLUS multiplicativeExpression 
-- On AND reduce production additiveExpression -> additiveExpression PLUS multiplicativeExpression 

State 143:
multiplicativeExpression -> multiplicativeExpression MOD . castExpression [ XOR SEMI RSHIFT RPAR RCURL RBRAC QM PLUS OR NEQUAL MUL MOD MINUS LTHAN LSHIFT LOGSHIFT LETHAN INSTANCEOF GTHAN GETHAN EQUAL DIV COMM COL BOR BAND AND ]
-- On VOID shift to state 6
-- On THIS shift to state 7
-- On SUPER shift to state 8
-- On STRLIT shift to state 9
-- On SHORT shift to state 10
-- On PLUS shift to state 11
-- On NULLLIT shift to state 12
-- On NOT shift to state 13
-- On NEW shift to state 14
-- On MINUS shift to state 26
-- On LPAR shift to state 27
-- On LONG shift to state 15
-- On INTLIT shift to state 28
-- On INT shift to state 16
-- On INCREMENT shift to state 29
-- On IDENTIFIER shift to state 17
-- On FLOATLIT shift to state 31
-- On FLOAT shift to state 18
-- On DOUBLELIT shift to state 32
-- On DOUBLE shift to state 19
-- On DECREMENT shift to state 33
-- On CHARLIT shift to state 34
-- On CHAR shift to state 20
-- On BYTE shift to state 21
-- On BOOLEANLIT shift to state 35
-- On BOOLEAN shift to state 22
-- On BNOT shift to state 36
-- On unaryExpression shift to state 60
-- On specialName shift to state 38
-- On realPostfixExpression shift to state 39
-- On qualifiedName shift to state 42
-- On primitiveType shift to state 61
-- On primaryExpression shift to state 64
-- On postfixExpression shift to state 65
-- On plainNewAllocationExpression shift to state 68
-- On notJustName shift to state 69
-- On newAllocationExpression shift to state 72
-- On methodCall shift to state 75
-- On methodAccess shift to state 76
-- On logicalUnaryOperator shift to state 83
-- On logicalUnaryExpression shift to state 85
-- On fieldAccess shift to state 86
-- On complexPrimaryNoParenthesis shift to state 87
-- On complexPrimary shift to state 88
-- On classAllocationExpression shift to state 100
-- On castExpression shift to state 144
-- On arrayAllocationExpression shift to state 104
-- On arrayAccess shift to state 120
-- On arithmeticUnaryOperator shift to state 121

State 144:
multiplicativeExpression -> multiplicativeExpression MOD castExpression . [ XOR SEMI RSHIFT RPAR RCURL RBRAC QM PLUS OR NEQUAL MUL MOD MINUS LTHAN LSHIFT LOGSHIFT LETHAN INSTANCEOF GTHAN GETHAN EQUAL DIV COMM COL BOR BAND AND ]
-- On XOR reduce production multiplicativeExpression -> multiplicativeExpression MOD castExpression 
-- On SEMI reduce production multiplicativeExpression -> multiplicativeExpression MOD castExpression 
-- On RSHIFT reduce production multiplicativeExpression -> multiplicativeExpression MOD castExpression 
-- On RPAR reduce production multiplicativeExpression -> multiplicativeExpression MOD castExpression 
-- On RCURL reduce production multiplicativeExpression -> multiplicativeExpression MOD castExpression 
-- On RBRAC reduce production multiplicativeExpression -> multiplicativeExpression MOD castExpression 
-- On QM reduce production multiplicativeExpression -> multiplicativeExpression MOD castExpression 
-- On PLUS reduce production multiplicativeExpression -> multiplicativeExpression MOD castExpression 
-- On OR reduce production multiplicativeExpression -> multiplicativeExpression MOD castExpression 
-- On NEQUAL reduce production multiplicativeExpression -> multiplicativeExpression MOD castExpression 
-- On MUL reduce production multiplicativeExpression -> multiplicativeExpression MOD castExpression 
-- On MOD reduce production multiplicativeExpression -> multiplicativeExpression MOD castExpression 
-- On MINUS reduce production multiplicativeExpression -> multiplicativeExpression MOD castExpression 
-- On LTHAN reduce production multiplicativeExpression -> multiplicativeExpression MOD castExpression 
-- On LSHIFT reduce production multiplicativeExpression -> multiplicativeExpression MOD castExpression 
-- On LOGSHIFT reduce production multiplicativeExpression -> multiplicativeExpression MOD castExpression 
-- On LETHAN reduce production multiplicativeExpression -> multiplicativeExpression MOD castExpression 
-- On INSTANCEOF reduce production multiplicativeExpression -> multiplicativeExpression MOD castExpression 
-- On GTHAN reduce production multiplicativeExpression -> multiplicativeExpression MOD castExpression 
-- On GETHAN reduce production multiplicativeExpression -> multiplicativeExpression MOD castExpression 
-- On EQUAL reduce production multiplicativeExpression -> multiplicativeExpression MOD castExpression 
-- On DIV reduce production multiplicativeExpression -> multiplicativeExpression MOD castExpression 
-- On COMM reduce production multiplicativeExpression -> multiplicativeExpression MOD castExpression 
-- On COL reduce production multiplicativeExpression -> multiplicativeExpression MOD castExpression 
-- On BOR reduce production multiplicativeExpression -> multiplicativeExpression MOD castExpression 
-- On BAND reduce production multiplicativeExpression -> multiplicativeExpression MOD castExpression 
-- On AND reduce production multiplicativeExpression -> multiplicativeExpression MOD castExpression 

State 145:
multiplicativeExpression -> multiplicativeExpression DIV . castExpression [ XOR SEMI RSHIFT RPAR RCURL RBRAC QM PLUS OR NEQUAL MUL MOD MINUS LTHAN LSHIFT LOGSHIFT LETHAN INSTANCEOF GTHAN GETHAN EQUAL DIV COMM COL BOR BAND AND ]
-- On VOID shift to state 6
-- On THIS shift to state 7
-- On SUPER shift to state 8
-- On STRLIT shift to state 9
-- On SHORT shift to state 10
-- On PLUS shift to state 11
-- On NULLLIT shift to state 12
-- On NOT shift to state 13
-- On NEW shift to state 14
-- On MINUS shift to state 26
-- On LPAR shift to state 27
-- On LONG shift to state 15
-- On INTLIT shift to state 28
-- On INT shift to state 16
-- On INCREMENT shift to state 29
-- On IDENTIFIER shift to state 17
-- On FLOATLIT shift to state 31
-- On FLOAT shift to state 18
-- On DOUBLELIT shift to state 32
-- On DOUBLE shift to state 19
-- On DECREMENT shift to state 33
-- On CHARLIT shift to state 34
-- On CHAR shift to state 20
-- On BYTE shift to state 21
-- On BOOLEANLIT shift to state 35
-- On BOOLEAN shift to state 22
-- On BNOT shift to state 36
-- On unaryExpression shift to state 60
-- On specialName shift to state 38
-- On realPostfixExpression shift to state 39
-- On qualifiedName shift to state 42
-- On primitiveType shift to state 61
-- On primaryExpression shift to state 64
-- On postfixExpression shift to state 65
-- On plainNewAllocationExpression shift to state 68
-- On notJustName shift to state 69
-- On newAllocationExpression shift to state 72
-- On methodCall shift to state 75
-- On methodAccess shift to state 76
-- On logicalUnaryOperator shift to state 83
-- On logicalUnaryExpression shift to state 85
-- On fieldAccess shift to state 86
-- On complexPrimaryNoParenthesis shift to state 87
-- On complexPrimary shift to state 88
-- On classAllocationExpression shift to state 100
-- On castExpression shift to state 146
-- On arrayAllocationExpression shift to state 104
-- On arrayAccess shift to state 120
-- On arithmeticUnaryOperator shift to state 121

State 146:
multiplicativeExpression -> multiplicativeExpression DIV castExpression . [ XOR SEMI RSHIFT RPAR RCURL RBRAC QM PLUS OR NEQUAL MUL MOD MINUS LTHAN LSHIFT LOGSHIFT LETHAN INSTANCEOF GTHAN GETHAN EQUAL DIV COMM COL BOR BAND AND ]
-- On XOR reduce production multiplicativeExpression -> multiplicativeExpression DIV castExpression 
-- On SEMI reduce production multiplicativeExpression -> multiplicativeExpression DIV castExpression 
-- On RSHIFT reduce production multiplicativeExpression -> multiplicativeExpression DIV castExpression 
-- On RPAR reduce production multiplicativeExpression -> multiplicativeExpression DIV castExpression 
-- On RCURL reduce production multiplicativeExpression -> multiplicativeExpression DIV castExpression 
-- On RBRAC reduce production multiplicativeExpression -> multiplicativeExpression DIV castExpression 
-- On QM reduce production multiplicativeExpression -> multiplicativeExpression DIV castExpression 
-- On PLUS reduce production multiplicativeExpression -> multiplicativeExpression DIV castExpression 
-- On OR reduce production multiplicativeExpression -> multiplicativeExpression DIV castExpression 
-- On NEQUAL reduce production multiplicativeExpression -> multiplicativeExpression DIV castExpression 
-- On MUL reduce production multiplicativeExpression -> multiplicativeExpression DIV castExpression 
-- On MOD reduce production multiplicativeExpression -> multiplicativeExpression DIV castExpression 
-- On MINUS reduce production multiplicativeExpression -> multiplicativeExpression DIV castExpression 
-- On LTHAN reduce production multiplicativeExpression -> multiplicativeExpression DIV castExpression 
-- On LSHIFT reduce production multiplicativeExpression -> multiplicativeExpression DIV castExpression 
-- On LOGSHIFT reduce production multiplicativeExpression -> multiplicativeExpression DIV castExpression 
-- On LETHAN reduce production multiplicativeExpression -> multiplicativeExpression DIV castExpression 
-- On INSTANCEOF reduce production multiplicativeExpression -> multiplicativeExpression DIV castExpression 
-- On GTHAN reduce production multiplicativeExpression -> multiplicativeExpression DIV castExpression 
-- On GETHAN reduce production multiplicativeExpression -> multiplicativeExpression DIV castExpression 
-- On EQUAL reduce production multiplicativeExpression -> multiplicativeExpression DIV castExpression 
-- On DIV reduce production multiplicativeExpression -> multiplicativeExpression DIV castExpression 
-- On COMM reduce production multiplicativeExpression -> multiplicativeExpression DIV castExpression 
-- On COL reduce production multiplicativeExpression -> multiplicativeExpression DIV castExpression 
-- On BOR reduce production multiplicativeExpression -> multiplicativeExpression DIV castExpression 
-- On BAND reduce production multiplicativeExpression -> multiplicativeExpression DIV castExpression 
-- On AND reduce production multiplicativeExpression -> multiplicativeExpression DIV castExpression 

State 147:
additiveExpression -> additiveExpression MINUS . multiplicativeExpression [ XOR SEMI RSHIFT RPAR RCURL RBRAC QM PLUS OR NEQUAL MINUS LTHAN LSHIFT LOGSHIFT LETHAN INSTANCEOF GTHAN GETHAN EQUAL COMM COL BOR BAND AND ]
-- On VOID shift to state 6
-- On THIS shift to state 7
-- On SUPER shift to state 8
-- On STRLIT shift to state 9
-- On SHORT shift to state 10
-- On PLUS shift to state 11
-- On NULLLIT shift to state 12
-- On NOT shift to state 13
-- On NEW shift to state 14
-- On MINUS shift to state 26
-- On LPAR shift to state 27
-- On LONG shift to state 15
-- On INTLIT shift to state 28
-- On INT shift to state 16
-- On INCREMENT shift to state 29
-- On IDENTIFIER shift to state 17
-- On FLOATLIT shift to state 31
-- On FLOAT shift to state 18
-- On DOUBLELIT shift to state 32
-- On DOUBLE shift to state 19
-- On DECREMENT shift to state 33
-- On CHARLIT shift to state 34
-- On CHAR shift to state 20
-- On BYTE shift to state 21
-- On BOOLEANLIT shift to state 35
-- On BOOLEAN shift to state 22
-- On BNOT shift to state 36
-- On unaryExpression shift to state 60
-- On specialName shift to state 38
-- On realPostfixExpression shift to state 39
-- On qualifiedName shift to state 42
-- On primitiveType shift to state 61
-- On primaryExpression shift to state 64
-- On postfixExpression shift to state 65
-- On plainNewAllocationExpression shift to state 68
-- On notJustName shift to state 69
-- On newAllocationExpression shift to state 72
-- On multiplicativeExpression shift to state 148
-- On methodCall shift to state 75
-- On methodAccess shift to state 76
-- On logicalUnaryOperator shift to state 83
-- On logicalUnaryExpression shift to state 85
-- On fieldAccess shift to state 86
-- On complexPrimaryNoParenthesis shift to state 87
-- On complexPrimary shift to state 88
-- On classAllocationExpression shift to state 100
-- On castExpression shift to state 103
-- On arrayAllocationExpression shift to state 104
-- On arrayAccess shift to state 120
-- On arithmeticUnaryOperator shift to state 121

State 148:
additiveExpression -> additiveExpression MINUS multiplicativeExpression . [ XOR SEMI RSHIFT RPAR RCURL RBRAC QM PLUS OR NEQUAL MINUS LTHAN LSHIFT LOGSHIFT LETHAN INSTANCEOF GTHAN GETHAN EQUAL COMM COL BOR BAND AND ]
multiplicativeExpression -> multiplicativeExpression . MUL castExpression [ XOR SEMI RSHIFT RPAR RCURL RBRAC QM PLUS OR NEQUAL MUL MOD MINUS LTHAN LSHIFT LOGSHIFT LETHAN INSTANCEOF GTHAN GETHAN EQUAL DIV COMM COL BOR BAND AND ]
multiplicativeExpression -> multiplicativeExpression . DIV castExpression [ XOR SEMI RSHIFT RPAR RCURL RBRAC QM PLUS OR NEQUAL MUL MOD MINUS LTHAN LSHIFT LOGSHIFT LETHAN INSTANCEOF GTHAN GETHAN EQUAL DIV COMM COL BOR BAND AND ]
multiplicativeExpression -> multiplicativeExpression . MOD castExpression [ XOR SEMI RSHIFT RPAR RCURL RBRAC QM PLUS OR NEQUAL MUL MOD MINUS LTHAN LSHIFT LOGSHIFT LETHAN INSTANCEOF GTHAN GETHAN EQUAL DIV COMM COL BOR BAND AND ]
-- On MUL shift to state 74
-- On MOD shift to state 143
-- On DIV shift to state 145
-- On XOR reduce production additiveExpression -> additiveExpression MINUS multiplicativeExpression 
-- On SEMI reduce production additiveExpression -> additiveExpression MINUS multiplicativeExpression 
-- On RSHIFT reduce production additiveExpression -> additiveExpression MINUS multiplicativeExpression 
-- On RPAR reduce production additiveExpression -> additiveExpression MINUS multiplicativeExpression 
-- On RCURL reduce production additiveExpression -> additiveExpression MINUS multiplicativeExpression 
-- On RBRAC reduce production additiveExpression -> additiveExpression MINUS multiplicativeExpression 
-- On QM reduce production additiveExpression -> additiveExpression MINUS multiplicativeExpression 
-- On PLUS reduce production additiveExpression -> additiveExpression MINUS multiplicativeExpression 
-- On OR reduce production additiveExpression -> additiveExpression MINUS multiplicativeExpression 
-- On NEQUAL reduce production additiveExpression -> additiveExpression MINUS multiplicativeExpression 
-- On MINUS reduce production additiveExpression -> additiveExpression MINUS multiplicativeExpression 
-- On LTHAN reduce production additiveExpression -> additiveExpression MINUS multiplicativeExpression 
-- On LSHIFT reduce production additiveExpression -> additiveExpression MINUS multiplicativeExpression 
-- On LOGSHIFT reduce production additiveExpression -> additiveExpression MINUS multiplicativeExpression 
-- On LETHAN reduce production additiveExpression -> additiveExpression MINUS multiplicativeExpression 
-- On INSTANCEOF reduce production additiveExpression -> additiveExpression MINUS multiplicativeExpression 
-- On GTHAN reduce production additiveExpression -> additiveExpression MINUS multiplicativeExpression 
-- On GETHAN reduce production additiveExpression -> additiveExpression MINUS multiplicativeExpression 
-- On EQUAL reduce production additiveExpression -> additiveExpression MINUS multiplicativeExpression 
-- On COMM reduce production additiveExpression -> additiveExpression MINUS multiplicativeExpression 
-- On COL reduce production additiveExpression -> additiveExpression MINUS multiplicativeExpression 
-- On BOR reduce production additiveExpression -> additiveExpression MINUS multiplicativeExpression 
-- On BAND reduce production additiveExpression -> additiveExpression MINUS multiplicativeExpression 
-- On AND reduce production additiveExpression -> additiveExpression MINUS multiplicativeExpression 

State 149:
relationalExpression -> relationalExpression GETHAN . shiftExpression [ XOR SEMI RPAR RCURL RBRAC QM OR NEQUAL LTHAN LETHAN INSTANCEOF GTHAN GETHAN EQUAL COMM COL BOR BAND AND ]
-- On VOID shift to state 6
-- On THIS shift to state 7
-- On SUPER shift to state 8
-- On STRLIT shift to state 9
-- On SHORT shift to state 10
-- On PLUS shift to state 11
-- On NULLLIT shift to state 12
-- On NOT shift to state 13
-- On NEW shift to state 14
-- On MINUS shift to state 26
-- On LPAR shift to state 27
-- On LONG shift to state 15
-- On INTLIT shift to state 28
-- On INT shift to state 16
-- On INCREMENT shift to state 29
-- On IDENTIFIER shift to state 17
-- On FLOATLIT shift to state 31
-- On FLOAT shift to state 18
-- On DOUBLELIT shift to state 32
-- On DOUBLE shift to state 19
-- On DECREMENT shift to state 33
-- On CHARLIT shift to state 34
-- On CHAR shift to state 20
-- On BYTE shift to state 21
-- On BOOLEANLIT shift to state 35
-- On BOOLEAN shift to state 22
-- On BNOT shift to state 36
-- On unaryExpression shift to state 60
-- On specialName shift to state 38
-- On shiftExpression shift to state 150
-- On realPostfixExpression shift to state 39
-- On qualifiedName shift to state 42
-- On primitiveType shift to state 61
-- On primaryExpression shift to state 64
-- On postfixExpression shift to state 65
-- On plainNewAllocationExpression shift to state 68
-- On notJustName shift to state 69
-- On newAllocationExpression shift to state 72
-- On multiplicativeExpression shift to state 73
-- On methodCall shift to state 75
-- On methodAccess shift to state 76
-- On logicalUnaryOperator shift to state 83
-- On logicalUnaryExpression shift to state 85
-- On fieldAccess shift to state 86
-- On complexPrimaryNoParenthesis shift to state 87
-- On complexPrimary shift to state 88
-- On classAllocationExpression shift to state 100
-- On castExpression shift to state 103
-- On arrayAllocationExpression shift to state 104
-- On arrayAccess shift to state 120
-- On arithmeticUnaryOperator shift to state 121
-- On additiveExpression shift to state 140

State 150:
relationalExpression -> relationalExpression GETHAN shiftExpression . [ XOR SEMI RPAR RCURL RBRAC QM OR NEQUAL LTHAN LETHAN INSTANCEOF GTHAN GETHAN EQUAL COMM COL BOR BAND AND ]
shiftExpression -> shiftExpression . LSHIFT additiveExpression [ XOR SEMI RSHIFT RPAR RCURL RBRAC QM OR NEQUAL LTHAN LSHIFT LOGSHIFT LETHAN INSTANCEOF GTHAN GETHAN EQUAL COMM COL BOR BAND AND ]
shiftExpression -> shiftExpression . RSHIFT additiveExpression [ XOR SEMI RSHIFT RPAR RCURL RBRAC QM OR NEQUAL LTHAN LSHIFT LOGSHIFT LETHAN INSTANCEOF GTHAN GETHAN EQUAL COMM COL BOR BAND AND ]
shiftExpression -> shiftExpression . LOGSHIFT additiveExpression [ XOR SEMI RSHIFT RPAR RCURL RBRAC QM OR NEQUAL LTHAN LSHIFT LOGSHIFT LETHAN INSTANCEOF GTHAN GETHAN EQUAL COMM COL BOR BAND AND ]
-- On RSHIFT shift to state 59
-- On LSHIFT shift to state 82
-- On LOGSHIFT shift to state 99
-- On XOR reduce production relationalExpression -> relationalExpression GETHAN shiftExpression 
-- On SEMI reduce production relationalExpression -> relationalExpression GETHAN shiftExpression 
-- On RPAR reduce production relationalExpression -> relationalExpression GETHAN shiftExpression 
-- On RCURL reduce production relationalExpression -> relationalExpression GETHAN shiftExpression 
-- On RBRAC reduce production relationalExpression -> relationalExpression GETHAN shiftExpression 
-- On QM reduce production relationalExpression -> relationalExpression GETHAN shiftExpression 
-- On OR reduce production relationalExpression -> relationalExpression GETHAN shiftExpression 
-- On NEQUAL reduce production relationalExpression -> relationalExpression GETHAN shiftExpression 
-- On LTHAN reduce production relationalExpression -> relationalExpression GETHAN shiftExpression 
-- On LETHAN reduce production relationalExpression -> relationalExpression GETHAN shiftExpression 
-- On INSTANCEOF reduce production relationalExpression -> relationalExpression GETHAN shiftExpression 
-- On GTHAN reduce production relationalExpression -> relationalExpression GETHAN shiftExpression 
-- On GETHAN reduce production relationalExpression -> relationalExpression GETHAN shiftExpression 
-- On EQUAL reduce production relationalExpression -> relationalExpression GETHAN shiftExpression 
-- On COMM reduce production relationalExpression -> relationalExpression GETHAN shiftExpression 
-- On COL reduce production relationalExpression -> relationalExpression GETHAN shiftExpression 
-- On BOR reduce production relationalExpression -> relationalExpression GETHAN shiftExpression 
-- On BAND reduce production relationalExpression -> relationalExpression GETHAN shiftExpression 
-- On AND reduce production relationalExpression -> relationalExpression GETHAN shiftExpression 

State 151:
assignmentExpression -> conditionalExpression . [ SEMI RPAR RCURL RBRAC COMM COL ]
-- On SEMI reduce production assignmentExpression -> conditionalExpression 
-- On RPAR reduce production assignmentExpression -> conditionalExpression 
-- On RCURL reduce production assignmentExpression -> conditionalExpression 
-- On RBRAC reduce production assignmentExpression -> conditionalExpression 
-- On COMM reduce production assignmentExpression -> conditionalExpression 
-- On COL reduce production assignmentExpression -> conditionalExpression 

State 152:
expression -> assignmentExpression . [ SEMI RPAR RCURL RBRAC COMM COL ]
-- On SEMI reduce production expression -> assignmentExpression 
-- On RPAR reduce production expression -> assignmentExpression 
-- On RCURL reduce production expression -> assignmentExpression 
-- On RBRAC reduce production expression -> assignmentExpression 
-- On COMM reduce production expression -> assignmentExpression 
-- On COL reduce production expression -> assignmentExpression 

State 153:
conditionalOrExpression -> conditionalOrExpression OR . conditionalAndExpression [ SEMI RPAR RCURL RBRAC QM OR COMM COL ]
-- On VOID shift to state 6
-- On THIS shift to state 7
-- On SUPER shift to state 8
-- On STRLIT shift to state 9
-- On SHORT shift to state 10
-- On PLUS shift to state 11
-- On NULLLIT shift to state 12
-- On NOT shift to state 13
-- On NEW shift to state 14
-- On MINUS shift to state 26
-- On LPAR shift to state 27
-- On LONG shift to state 15
-- On INTLIT shift to state 28
-- On INT shift to state 16
-- On INCREMENT shift to state 29
-- On IDENTIFIER shift to state 17
-- On FLOATLIT shift to state 31
-- On FLOAT shift to state 18
-- On DOUBLELIT shift to state 32
-- On DOUBLE shift to state 19
-- On DECREMENT shift to state 33
-- On CHARLIT shift to state 34
-- On CHAR shift to state 20
-- On BYTE shift to state 21
-- On BOOLEANLIT shift to state 35
-- On BOOLEAN shift to state 22
-- On BNOT shift to state 36
-- On unaryExpression shift to state 60
-- On specialName shift to state 38
-- On shiftExpression shift to state 58
-- On relationalExpression shift to state 79
-- On realPostfixExpression shift to state 39
-- On qualifiedName shift to state 42
-- On primitiveType shift to state 61
-- On primaryExpression shift to state 64
-- On postfixExpression shift to state 65
-- On plainNewAllocationExpression shift to state 68
-- On notJustName shift to state 69
-- On newAllocationExpression shift to state 72
-- On multiplicativeExpression shift to state 73
-- On methodCall shift to state 75
-- On methodAccess shift to state 76
-- On logicalUnaryOperator shift to state 83
-- On logicalUnaryExpression shift to state 85
-- On inclusiveOrExpression shift to state 90
-- On fieldAccess shift to state 86
-- On exclusiveOrExpression shift to state 111
-- On equalityExpression shift to state 94
-- On conditionalAndExpression shift to state 154
-- On complexPrimaryNoParenthesis shift to state 87
-- On complexPrimary shift to state 88
-- On classAllocationExpression shift to state 100
-- On castExpression shift to state 103
-- On arrayAllocationExpression shift to state 104
-- On arrayAccess shift to state 120
-- On arithmeticUnaryOperator shift to state 121
-- On andExpression shift to state 123
-- On additiveExpression shift to state 140

State 154:
conditionalAndExpression -> conditionalAndExpression . AND inclusiveOrExpression [ SEMI RPAR RCURL RBRAC QM OR COMM COL AND ]
conditionalOrExpression -> conditionalOrExpression OR conditionalAndExpression . [ SEMI RPAR RCURL RBRAC QM OR COMM COL ]
-- On AND shift to state 118
-- On SEMI reduce production conditionalOrExpression -> conditionalOrExpression OR conditionalAndExpression 
-- On RPAR reduce production conditionalOrExpression -> conditionalOrExpression OR conditionalAndExpression 
-- On RCURL reduce production conditionalOrExpression -> conditionalOrExpression OR conditionalAndExpression 
-- On RBRAC reduce production conditionalOrExpression -> conditionalOrExpression OR conditionalAndExpression 
-- On QM reduce production conditionalOrExpression -> conditionalOrExpression OR conditionalAndExpression 
-- On OR reduce production conditionalOrExpression -> conditionalOrExpression OR conditionalAndExpression 
-- On COMM reduce production conditionalOrExpression -> conditionalOrExpression OR conditionalAndExpression 
-- On COL reduce production conditionalOrExpression -> conditionalOrExpression OR conditionalAndExpression 

State 155:
arrayInitializers -> arrayInitializers . COMM variableInitializer [ RCURL COMM ]
arrayInitializers -> arrayInitializers . COMM [ RCURL COMM ]
variableInitializer -> LCURL arrayInitializers . RCURL [ SEMI RCURL COMM ]
-- On RCURL shift to state 156
-- On COMM shift to state 157

State 156:
variableInitializer -> LCURL arrayInitializers RCURL . [ SEMI RCURL COMM ]
-- On SEMI reduce production variableInitializer -> LCURL arrayInitializers RCURL 
-- On RCURL reduce production variableInitializer -> LCURL arrayInitializers RCURL 
-- On COMM reduce production variableInitializer -> LCURL arrayInitializers RCURL 

State 157:
arrayInitializers -> arrayInitializers COMM . variableInitializer [ RCURL COMM ]
arrayInitializers -> arrayInitializers COMM . [ RCURL COMM ]
-- On error shift to state 3
-- On VOID shift to state 6
-- On THIS shift to state 7
-- On SUPER shift to state 8
-- On STRLIT shift to state 9
-- On SHORT shift to state 10
-- On PLUS shift to state 11
-- On NULLLIT shift to state 12
-- On NOT shift to state 13
-- On NEW shift to state 14
-- On MINUS shift to state 26
-- On LPAR shift to state 27
-- On LONG shift to state 15
-- On LCURL shift to state 107
-- On INTLIT shift to state 28
-- On INT shift to state 16
-- On INCREMENT shift to state 29
-- On IDENTIFIER shift to state 17
-- On FLOATLIT shift to state 31
-- On FLOAT shift to state 18
-- On DOUBLELIT shift to state 32
-- On DOUBLE shift to state 19
-- On DECREMENT shift to state 33
-- On CHARLIT shift to state 34
-- On CHAR shift to state 20
-- On BYTE shift to state 21
-- On BOOLEANLIT shift to state 35
-- On BOOLEAN shift to state 22
-- On BNOT shift to state 36
-- On variableInitializer shift to state 158
-- On unaryExpression shift to state 44
-- On specialName shift to state 38
-- On shiftExpression shift to state 58
-- On relationalExpression shift to state 79
-- On realPostfixExpression shift to state 39
-- On qualifiedName shift to state 42
-- On primitiveType shift to state 61
-- On primaryExpression shift to state 64
-- On postfixExpression shift to state 65
-- On plainNewAllocationExpression shift to state 68
-- On notJustName shift to state 69
-- On newAllocationExpression shift to state 72
-- On multiplicativeExpression shift to state 73
-- On methodCall shift to state 75
-- On methodAccess shift to state 76
-- On logicalUnaryOperator shift to state 83
-- On logicalUnaryExpression shift to state 85
-- On inclusiveOrExpression shift to state 90
-- On fieldAccess shift to state 86
-- On expression shift to state 110
-- On exclusiveOrExpression shift to state 111
-- On equalityExpression shift to state 94
-- On conditionalOrExpression shift to state 112
-- On conditionalExpression shift to state 151
-- On conditionalAndExpression shift to state 117
-- On complexPrimaryNoParenthesis shift to state 87
-- On complexPrimary shift to state 88
-- On classAllocationExpression shift to state 100
-- On castExpression shift to state 103
-- On assignmentExpression shift to state 152
-- On arrayAllocationExpression shift to state 104
-- On arrayAccess shift to state 120
-- On arithmeticUnaryOperator shift to state 121
-- On andExpression shift to state 123
-- On additiveExpression shift to state 140
-- On RCURL reduce production arrayInitializers -> arrayInitializers COMM 
-- On COMM reduce production arrayInitializers -> arrayInitializers COMM 

State 158:
arrayInitializers -> arrayInitializers COMM variableInitializer . [ RCURL COMM ]
-- On RCURL reduce production arrayInitializers -> arrayInitializers COMM variableInitializer 
-- On COMM reduce production arrayInitializers -> arrayInitializers COMM variableInitializer 

State 159:
arrayInitializers -> arrayInitializers . COMM variableInitializer [ RCURL COMM ]
arrayInitializers -> arrayInitializers . COMM [ RCURL COMM ]
plainNewAllocationExpression -> arrayAllocationExpression LCURL arrayInitializers . RCURL [ XOREQUAL XOR SEMI RSHIFTEQUAL RSHIFT RPAR RCURL RBRAC QM PLUS PEQUAL OREQUAL OR NEQUAL MULEQUAL MUL MODEQUAL MOD MINUSEQUAL MINUS LTHAN LSHIFTEQUAL LSHIFT LOGSHIFTEQUAL LOGSHIFT LETHAN INSTANCEOF INCREMENT GTHAN GETHAN EQUAL DOT DIVEQUAL DIV DECREMENT COMM COL BOR BAND ASSIGN ANDEQUAL AND ]
-- On RCURL shift to state 160
-- On COMM shift to state 157

State 160:
plainNewAllocationExpression -> arrayAllocationExpression LCURL arrayInitializers RCURL . [ XOREQUAL XOR SEMI RSHIFTEQUAL RSHIFT RPAR RCURL RBRAC QM PLUS PEQUAL OREQUAL OR NEQUAL MULEQUAL MUL MODEQUAL MOD MINUSEQUAL MINUS LTHAN LSHIFTEQUAL LSHIFT LOGSHIFTEQUAL LOGSHIFT LETHAN INSTANCEOF INCREMENT GTHAN GETHAN EQUAL DOT DIVEQUAL DIV DECREMENT COMM COL BOR BAND ASSIGN ANDEQUAL AND ]
-- On XOREQUAL reduce production plainNewAllocationExpression -> arrayAllocationExpression LCURL arrayInitializers RCURL 
-- On XOR reduce production plainNewAllocationExpression -> arrayAllocationExpression LCURL arrayInitializers RCURL 
-- On SEMI reduce production plainNewAllocationExpression -> arrayAllocationExpression LCURL arrayInitializers RCURL 
-- On RSHIFTEQUAL reduce production plainNewAllocationExpression -> arrayAllocationExpression LCURL arrayInitializers RCURL 
-- On RSHIFT reduce production plainNewAllocationExpression -> arrayAllocationExpression LCURL arrayInitializers RCURL 
-- On RPAR reduce production plainNewAllocationExpression -> arrayAllocationExpression LCURL arrayInitializers RCURL 
-- On RCURL reduce production plainNewAllocationExpression -> arrayAllocationExpression LCURL arrayInitializers RCURL 
-- On RBRAC reduce production plainNewAllocationExpression -> arrayAllocationExpression LCURL arrayInitializers RCURL 
-- On QM reduce production plainNewAllocationExpression -> arrayAllocationExpression LCURL arrayInitializers RCURL 
-- On PLUS reduce production plainNewAllocationExpression -> arrayAllocationExpression LCURL arrayInitializers RCURL 
-- On PEQUAL reduce production plainNewAllocationExpression -> arrayAllocationExpression LCURL arrayInitializers RCURL 
-- On OREQUAL reduce production plainNewAllocationExpression -> arrayAllocationExpression LCURL arrayInitializers RCURL 
-- On OR reduce production plainNewAllocationExpression -> arrayAllocationExpression LCURL arrayInitializers RCURL 
-- On NEQUAL reduce production plainNewAllocationExpression -> arrayAllocationExpression LCURL arrayInitializers RCURL 
-- On MULEQUAL reduce production plainNewAllocationExpression -> arrayAllocationExpression LCURL arrayInitializers RCURL 
-- On MUL reduce production plainNewAllocationExpression -> arrayAllocationExpression LCURL arrayInitializers RCURL 
-- On MODEQUAL reduce production plainNewAllocationExpression -> arrayAllocationExpression LCURL arrayInitializers RCURL 
-- On MOD reduce production plainNewAllocationExpression -> arrayAllocationExpression LCURL arrayInitializers RCURL 
-- On MINUSEQUAL reduce production plainNewAllocationExpression -> arrayAllocationExpression LCURL arrayInitializers RCURL 
-- On MINUS reduce production plainNewAllocationExpression -> arrayAllocationExpression LCURL arrayInitializers RCURL 
-- On LTHAN reduce production plainNewAllocationExpression -> arrayAllocationExpression LCURL arrayInitializers RCURL 
-- On LSHIFTEQUAL reduce production plainNewAllocationExpression -> arrayAllocationExpression LCURL arrayInitializers RCURL 
-- On LSHIFT reduce production plainNewAllocationExpression -> arrayAllocationExpression LCURL arrayInitializers RCURL 
-- On LOGSHIFTEQUAL reduce production plainNewAllocationExpression -> arrayAllocationExpression LCURL arrayInitializers RCURL 
-- On LOGSHIFT reduce production plainNewAllocationExpression -> arrayAllocationExpression LCURL arrayInitializers RCURL 
-- On LETHAN reduce production plainNewAllocationExpression -> arrayAllocationExpression LCURL arrayInitializers RCURL 
-- On INSTANCEOF reduce production plainNewAllocationExpression -> arrayAllocationExpression LCURL arrayInitializers RCURL 
-- On INCREMENT reduce production plainNewAllocationExpression -> arrayAllocationExpression LCURL arrayInitializers RCURL 
-- On GTHAN reduce production plainNewAllocationExpression -> arrayAllocationExpression LCURL arrayInitializers RCURL 
-- On GETHAN reduce production plainNewAllocationExpression -> arrayAllocationExpression LCURL arrayInitializers RCURL 
-- On EQUAL reduce production plainNewAllocationExpression -> arrayAllocationExpression LCURL arrayInitializers RCURL 
-- On DOT reduce production plainNewAllocationExpression -> arrayAllocationExpression LCURL arrayInitializers RCURL 
-- On DIVEQUAL reduce production plainNewAllocationExpression -> arrayAllocationExpression LCURL arrayInitializers RCURL 
-- On DIV reduce production plainNewAllocationExpression -> arrayAllocationExpression LCURL arrayInitializers RCURL 
-- On DECREMENT reduce production plainNewAllocationExpression -> arrayAllocationExpression LCURL arrayInitializers RCURL 
-- On COMM reduce production plainNewAllocationExpression -> arrayAllocationExpression LCURL arrayInitializers RCURL 
-- On COL reduce production plainNewAllocationExpression -> arrayAllocationExpression LCURL arrayInitializers RCURL 
-- On BOR reduce production plainNewAllocationExpression -> arrayAllocationExpression LCURL arrayInitializers RCURL 
-- On BAND reduce production plainNewAllocationExpression -> arrayAllocationExpression LCURL arrayInitializers RCURL 
-- On ASSIGN reduce production plainNewAllocationExpression -> arrayAllocationExpression LCURL arrayInitializers RCURL 
-- On ANDEQUAL reduce production plainNewAllocationExpression -> arrayAllocationExpression LCURL arrayInitializers RCURL 
-- On AND reduce production plainNewAllocationExpression -> arrayAllocationExpression LCURL arrayInitializers RCURL 

State 161:
additiveExpression -> additiveExpression . PLUS multiplicativeExpression [ XOR SEMI RSHIFT RPAR RCURL RBRAC QM PLUS OR NEQUAL MINUS LTHAN LSHIFT LOGSHIFT LETHAN INSTANCEOF GTHAN GETHAN EQUAL COMM COL BOR BAND AND ]
additiveExpression -> additiveExpression . MINUS multiplicativeExpression [ XOR SEMI RSHIFT RPAR RCURL RBRAC QM PLUS OR NEQUAL MINUS LTHAN LSHIFT LOGSHIFT LETHAN INSTANCEOF GTHAN GETHAN EQUAL COMM COL BOR BAND AND ]
shiftExpression -> shiftExpression LOGSHIFT additiveExpression . [ XOR SEMI RSHIFT RPAR RCURL RBRAC QM OR NEQUAL LTHAN LSHIFT LOGSHIFT LETHAN INSTANCEOF GTHAN GETHAN EQUAL COMM COL BOR BAND AND ]
-- On PLUS shift to state 141
-- On MINUS shift to state 147
-- On XOR reduce production shiftExpression -> shiftExpression LOGSHIFT additiveExpression 
-- On SEMI reduce production shiftExpression -> shiftExpression LOGSHIFT additiveExpression 
-- On RSHIFT reduce production shiftExpression -> shiftExpression LOGSHIFT additiveExpression 
-- On RPAR reduce production shiftExpression -> shiftExpression LOGSHIFT additiveExpression 
-- On RCURL reduce production shiftExpression -> shiftExpression LOGSHIFT additiveExpression 
-- On RBRAC reduce production shiftExpression -> shiftExpression LOGSHIFT additiveExpression 
-- On QM reduce production shiftExpression -> shiftExpression LOGSHIFT additiveExpression 
-- On OR reduce production shiftExpression -> shiftExpression LOGSHIFT additiveExpression 
-- On NEQUAL reduce production shiftExpression -> shiftExpression LOGSHIFT additiveExpression 
-- On LTHAN reduce production shiftExpression -> shiftExpression LOGSHIFT additiveExpression 
-- On LSHIFT reduce production shiftExpression -> shiftExpression LOGSHIFT additiveExpression 
-- On LOGSHIFT reduce production shiftExpression -> shiftExpression LOGSHIFT additiveExpression 
-- On LETHAN reduce production shiftExpression -> shiftExpression LOGSHIFT additiveExpression 
-- On INSTANCEOF reduce production shiftExpression -> shiftExpression LOGSHIFT additiveExpression 
-- On GTHAN reduce production shiftExpression -> shiftExpression LOGSHIFT additiveExpression 
-- On GETHAN reduce production shiftExpression -> shiftExpression LOGSHIFT additiveExpression 
-- On EQUAL reduce production shiftExpression -> shiftExpression LOGSHIFT additiveExpression 
-- On COMM reduce production shiftExpression -> shiftExpression LOGSHIFT additiveExpression 
-- On COL reduce production shiftExpression -> shiftExpression LOGSHIFT additiveExpression 
-- On BOR reduce production shiftExpression -> shiftExpression LOGSHIFT additiveExpression 
-- On BAND reduce production shiftExpression -> shiftExpression LOGSHIFT additiveExpression 
-- On AND reduce production shiftExpression -> shiftExpression LOGSHIFT additiveExpression 

State 162:
andExpression -> andExpression . BAND equalityExpression [ XOR SEMI RPAR RCURL RBRAC QM OR COMM COL BOR BAND AND ]
exclusiveOrExpression -> exclusiveOrExpression XOR andExpression . [ XOR SEMI RPAR RCURL RBRAC QM OR COMM COL BOR AND ]
-- On BAND shift to state 124
-- On XOR reduce production exclusiveOrExpression -> exclusiveOrExpression XOR andExpression 
-- On SEMI reduce production exclusiveOrExpression -> exclusiveOrExpression XOR andExpression 
-- On RPAR reduce production exclusiveOrExpression -> exclusiveOrExpression XOR andExpression 
-- On RCURL reduce production exclusiveOrExpression -> exclusiveOrExpression XOR andExpression 
-- On RBRAC reduce production exclusiveOrExpression -> exclusiveOrExpression XOR andExpression 
-- On QM reduce production exclusiveOrExpression -> exclusiveOrExpression XOR andExpression 
-- On OR reduce production exclusiveOrExpression -> exclusiveOrExpression XOR andExpression 
-- On COMM reduce production exclusiveOrExpression -> exclusiveOrExpression XOR andExpression 
-- On COL reduce production exclusiveOrExpression -> exclusiveOrExpression XOR andExpression 
-- On BOR reduce production exclusiveOrExpression -> exclusiveOrExpression XOR andExpression 
-- On AND reduce production exclusiveOrExpression -> exclusiveOrExpression XOR andExpression 

State 163:
arrayAccess -> complexPrimary LBRAC expression . RBRAC [ XOREQUAL XOR SEMI RSHIFTEQUAL RSHIFT RPAR RCURL RBRAC QM PLUS PEQUAL OREQUAL OR NEQUAL MULEQUAL MUL MODEQUAL MOD MINUSEQUAL MINUS LTHAN LSHIFTEQUAL LSHIFT LPAR LOGSHIFTEQUAL LOGSHIFT LETHAN LBRAC INSTANCEOF INCREMENT GTHAN GETHAN EQUAL DOT DIVEQUAL DIV DECREMENT COMM COL BOR BAND ASSIGN ANDEQUAL AND ]
-- On RBRAC shift to state 164

State 164:
arrayAccess -> complexPrimary LBRAC expression RBRAC . [ XOREQUAL XOR SEMI RSHIFTEQUAL RSHIFT RPAR RCURL RBRAC QM PLUS PEQUAL OREQUAL OR NEQUAL MULEQUAL MUL MODEQUAL MOD MINUSEQUAL MINUS LTHAN LSHIFTEQUAL LSHIFT LPAR LOGSHIFTEQUAL LOGSHIFT LETHAN LBRAC INSTANCEOF INCREMENT GTHAN GETHAN EQUAL DOT DIVEQUAL DIV DECREMENT COMM COL BOR BAND ASSIGN ANDEQUAL AND ]
-- On XOREQUAL reduce production arrayAccess -> complexPrimary LBRAC expression RBRAC 
-- On XOR reduce production arrayAccess -> complexPrimary LBRAC expression RBRAC 
-- On SEMI reduce production arrayAccess -> complexPrimary LBRAC expression RBRAC 
-- On RSHIFTEQUAL reduce production arrayAccess -> complexPrimary LBRAC expression RBRAC 
-- On RSHIFT reduce production arrayAccess -> complexPrimary LBRAC expression RBRAC 
-- On RPAR reduce production arrayAccess -> complexPrimary LBRAC expression RBRAC 
-- On RCURL reduce production arrayAccess -> complexPrimary LBRAC expression RBRAC 
-- On RBRAC reduce production arrayAccess -> complexPrimary LBRAC expression RBRAC 
-- On QM reduce production arrayAccess -> complexPrimary LBRAC expression RBRAC 
-- On PLUS reduce production arrayAccess -> complexPrimary LBRAC expression RBRAC 
-- On PEQUAL reduce production arrayAccess -> complexPrimary LBRAC expression RBRAC 
-- On OREQUAL reduce production arrayAccess -> complexPrimary LBRAC expression RBRAC 
-- On OR reduce production arrayAccess -> complexPrimary LBRAC expression RBRAC 
-- On NEQUAL reduce production arrayAccess -> complexPrimary LBRAC expression RBRAC 
-- On MULEQUAL reduce production arrayAccess -> complexPrimary LBRAC expression RBRAC 
-- On MUL reduce production arrayAccess -> complexPrimary LBRAC expression RBRAC 
-- On MODEQUAL reduce production arrayAccess -> complexPrimary LBRAC expression RBRAC 
-- On MOD reduce production arrayAccess -> complexPrimary LBRAC expression RBRAC 
-- On MINUSEQUAL reduce production arrayAccess -> complexPrimary LBRAC expression RBRAC 
-- On MINUS reduce production arrayAccess -> complexPrimary LBRAC expression RBRAC 
-- On LTHAN reduce production arrayAccess -> complexPrimary LBRAC expression RBRAC 
-- On LSHIFTEQUAL reduce production arrayAccess -> complexPrimary LBRAC expression RBRAC 
-- On LSHIFT reduce production arrayAccess -> complexPrimary LBRAC expression RBRAC 
-- On LPAR reduce production arrayAccess -> complexPrimary LBRAC expression RBRAC 
-- On LOGSHIFTEQUAL reduce production arrayAccess -> complexPrimary LBRAC expression RBRAC 
-- On LOGSHIFT reduce production arrayAccess -> complexPrimary LBRAC expression RBRAC 
-- On LETHAN reduce production arrayAccess -> complexPrimary LBRAC expression RBRAC 
-- On LBRAC reduce production arrayAccess -> complexPrimary LBRAC expression RBRAC 
-- On INSTANCEOF reduce production arrayAccess -> complexPrimary LBRAC expression RBRAC 
-- On INCREMENT reduce production arrayAccess -> complexPrimary LBRAC expression RBRAC 
-- On GTHAN reduce production arrayAccess -> complexPrimary LBRAC expression RBRAC 
-- On GETHAN reduce production arrayAccess -> complexPrimary LBRAC expression RBRAC 
-- On EQUAL reduce production arrayAccess -> complexPrimary LBRAC expression RBRAC 
-- On DOT reduce production arrayAccess -> complexPrimary LBRAC expression RBRAC 
-- On DIVEQUAL reduce production arrayAccess -> complexPrimary LBRAC expression RBRAC 
-- On DIV reduce production arrayAccess -> complexPrimary LBRAC expression RBRAC 
-- On DECREMENT reduce production arrayAccess -> complexPrimary LBRAC expression RBRAC 
-- On COMM reduce production arrayAccess -> complexPrimary LBRAC expression RBRAC 
-- On COL reduce production arrayAccess -> complexPrimary LBRAC expression RBRAC 
-- On BOR reduce production arrayAccess -> complexPrimary LBRAC expression RBRAC 
-- On BAND reduce production arrayAccess -> complexPrimary LBRAC expression RBRAC 
-- On ASSIGN reduce production arrayAccess -> complexPrimary LBRAC expression RBRAC 
-- On ANDEQUAL reduce production arrayAccess -> complexPrimary LBRAC expression RBRAC 
-- On AND reduce production arrayAccess -> complexPrimary LBRAC expression RBRAC 

State 165:
additiveExpression -> additiveExpression . PLUS multiplicativeExpression [ XOR SEMI RSHIFT RPAR RCURL RBRAC QM PLUS OR NEQUAL MINUS LTHAN LSHIFT LOGSHIFT LETHAN INSTANCEOF GTHAN GETHAN EQUAL COMM COL BOR BAND AND ]
additiveExpression -> additiveExpression . MINUS multiplicativeExpression [ XOR SEMI RSHIFT RPAR RCURL RBRAC QM PLUS OR NEQUAL MINUS LTHAN LSHIFT LOGSHIFT LETHAN INSTANCEOF GTHAN GETHAN EQUAL COMM COL BOR BAND AND ]
shiftExpression -> shiftExpression LSHIFT additiveExpression . [ XOR SEMI RSHIFT RPAR RCURL RBRAC QM OR NEQUAL LTHAN LSHIFT LOGSHIFT LETHAN INSTANCEOF GTHAN GETHAN EQUAL COMM COL BOR BAND AND ]
-- On PLUS shift to state 141
-- On MINUS shift to state 147
-- On XOR reduce production shiftExpression -> shiftExpression LSHIFT additiveExpression 
-- On SEMI reduce production shiftExpression -> shiftExpression LSHIFT additiveExpression 
-- On RSHIFT reduce production shiftExpression -> shiftExpression LSHIFT additiveExpression 
-- On RPAR reduce production shiftExpression -> shiftExpression LSHIFT additiveExpression 
-- On RCURL reduce production shiftExpression -> shiftExpression LSHIFT additiveExpression 
-- On RBRAC reduce production shiftExpression -> shiftExpression LSHIFT additiveExpression 
-- On QM reduce production shiftExpression -> shiftExpression LSHIFT additiveExpression 
-- On OR reduce production shiftExpression -> shiftExpression LSHIFT additiveExpression 
-- On NEQUAL reduce production shiftExpression -> shiftExpression LSHIFT additiveExpression 
-- On LTHAN reduce production shiftExpression -> shiftExpression LSHIFT additiveExpression 
-- On LSHIFT reduce production shiftExpression -> shiftExpression LSHIFT additiveExpression 
-- On LOGSHIFT reduce production shiftExpression -> shiftExpression LSHIFT additiveExpression 
-- On LETHAN reduce production shiftExpression -> shiftExpression LSHIFT additiveExpression 
-- On INSTANCEOF reduce production shiftExpression -> shiftExpression LSHIFT additiveExpression 
-- On GTHAN reduce production shiftExpression -> shiftExpression LSHIFT additiveExpression 
-- On GETHAN reduce production shiftExpression -> shiftExpression LSHIFT additiveExpression 
-- On EQUAL reduce production shiftExpression -> shiftExpression LSHIFT additiveExpression 
-- On COMM reduce production shiftExpression -> shiftExpression LSHIFT additiveExpression 
-- On COL reduce production shiftExpression -> shiftExpression LSHIFT additiveExpression 
-- On BOR reduce production shiftExpression -> shiftExpression LSHIFT additiveExpression 
-- On BAND reduce production shiftExpression -> shiftExpression LSHIFT additiveExpression 
-- On AND reduce production shiftExpression -> shiftExpression LSHIFT additiveExpression 

State 166:
argumentList -> expression . [ RPAR COMM ]
-- On RPAR reduce production argumentList -> expression 
-- On COMM reduce production argumentList -> expression 

State 167:
argumentList -> argumentList . COMM expression [ RPAR COMM ]
methodCall -> methodAccess LPAR argumentList . RPAR [ XOREQUAL XOR SEMI RSHIFTEQUAL RSHIFT RPAR RCURL RBRAC QM PLUS PEQUAL OREQUAL OR NEQUAL MULEQUAL MUL MODEQUAL MOD MINUSEQUAL MINUS LTHAN LSHIFTEQUAL LSHIFT LPAR LOGSHIFTEQUAL LOGSHIFT LETHAN LBRAC INSTANCEOF INCREMENT GTHAN GETHAN EQUAL DOT DIVEQUAL DIV DECREMENT COMM COL BOR BAND ASSIGN ANDEQUAL AND ]
-- On RPAR shift to state 168
-- On COMM shift to state 169

State 168:
methodCall -> methodAccess LPAR argumentList RPAR . [ XOREQUAL XOR SEMI RSHIFTEQUAL RSHIFT RPAR RCURL RBRAC QM PLUS PEQUAL OREQUAL OR NEQUAL MULEQUAL MUL MODEQUAL MOD MINUSEQUAL MINUS LTHAN LSHIFTEQUAL LSHIFT LPAR LOGSHIFTEQUAL LOGSHIFT LETHAN LBRAC INSTANCEOF INCREMENT GTHAN GETHAN EQUAL DOT DIVEQUAL DIV DECREMENT COMM COL BOR BAND ASSIGN ANDEQUAL AND ]
-- On XOREQUAL reduce production methodCall -> methodAccess LPAR argumentList RPAR 
-- On XOR reduce production methodCall -> methodAccess LPAR argumentList RPAR 
-- On SEMI reduce production methodCall -> methodAccess LPAR argumentList RPAR 
-- On RSHIFTEQUAL reduce production methodCall -> methodAccess LPAR argumentList RPAR 
-- On RSHIFT reduce production methodCall -> methodAccess LPAR argumentList RPAR 
-- On RPAR reduce production methodCall -> methodAccess LPAR argumentList RPAR 
-- On RCURL reduce production methodCall -> methodAccess LPAR argumentList RPAR 
-- On RBRAC reduce production methodCall -> methodAccess LPAR argumentList RPAR 
-- On QM reduce production methodCall -> methodAccess LPAR argumentList RPAR 
-- On PLUS reduce production methodCall -> methodAccess LPAR argumentList RPAR 
-- On PEQUAL reduce production methodCall -> methodAccess LPAR argumentList RPAR 
-- On OREQUAL reduce production methodCall -> methodAccess LPAR argumentList RPAR 
-- On OR reduce production methodCall -> methodAccess LPAR argumentList RPAR 
-- On NEQUAL reduce production methodCall -> methodAccess LPAR argumentList RPAR 
-- On MULEQUAL reduce production methodCall -> methodAccess LPAR argumentList RPAR 
-- On MUL reduce production methodCall -> methodAccess LPAR argumentList RPAR 
-- On MODEQUAL reduce production methodCall -> methodAccess LPAR argumentList RPAR 
-- On MOD reduce production methodCall -> methodAccess LPAR argumentList RPAR 
-- On MINUSEQUAL reduce production methodCall -> methodAccess LPAR argumentList RPAR 
-- On MINUS reduce production methodCall -> methodAccess LPAR argumentList RPAR 
-- On LTHAN reduce production methodCall -> methodAccess LPAR argumentList RPAR 
-- On LSHIFTEQUAL reduce production methodCall -> methodAccess LPAR argumentList RPAR 
-- On LSHIFT reduce production methodCall -> methodAccess LPAR argumentList RPAR 
-- On LPAR reduce production methodCall -> methodAccess LPAR argumentList RPAR 
-- On LOGSHIFTEQUAL reduce production methodCall -> methodAccess LPAR argumentList RPAR 
-- On LOGSHIFT reduce production methodCall -> methodAccess LPAR argumentList RPAR 
-- On LETHAN reduce production methodCall -> methodAccess LPAR argumentList RPAR 
-- On LBRAC reduce production methodCall -> methodAccess LPAR argumentList RPAR 
-- On INSTANCEOF reduce production methodCall -> methodAccess LPAR argumentList RPAR 
-- On INCREMENT reduce production methodCall -> methodAccess LPAR argumentList RPAR 
-- On GTHAN reduce production methodCall -> methodAccess LPAR argumentList RPAR 
-- On GETHAN reduce production methodCall -> methodAccess LPAR argumentList RPAR 
-- On EQUAL reduce production methodCall -> methodAccess LPAR argumentList RPAR 
-- On DOT reduce production methodCall -> methodAccess LPAR argumentList RPAR 
-- On DIVEQUAL reduce production methodCall -> methodAccess LPAR argumentList RPAR 
-- On DIV reduce production methodCall -> methodAccess LPAR argumentList RPAR 
-- On DECREMENT reduce production methodCall -> methodAccess LPAR argumentList RPAR 
-- On COMM reduce production methodCall -> methodAccess LPAR argumentList RPAR 
-- On COL reduce production methodCall -> methodAccess LPAR argumentList RPAR 
-- On BOR reduce production methodCall -> methodAccess LPAR argumentList RPAR 
-- On BAND reduce production methodCall -> methodAccess LPAR argumentList RPAR 
-- On ASSIGN reduce production methodCall -> methodAccess LPAR argumentList RPAR 
-- On ANDEQUAL reduce production methodCall -> methodAccess LPAR argumentList RPAR 
-- On AND reduce production methodCall -> methodAccess LPAR argumentList RPAR 

State 169:
argumentList -> argumentList COMM . expression [ RPAR COMM ]
-- On error shift to state 3
-- On VOID shift to state 6
-- On THIS shift to state 7
-- On SUPER shift to state 8
-- On STRLIT shift to state 9
-- On SHORT shift to state 10
-- On PLUS shift to state 11
-- On NULLLIT shift to state 12
-- On NOT shift to state 13
-- On NEW shift to state 14
-- On MINUS shift to state 26
-- On LPAR shift to state 27
-- On LONG shift to state 15
-- On INTLIT shift to state 28
-- On INT shift to state 16
-- On INCREMENT shift to state 29
-- On IDENTIFIER shift to state 17
-- On FLOATLIT shift to state 31
-- On FLOAT shift to state 18
-- On DOUBLELIT shift to state 32
-- On DOUBLE shift to state 19
-- On DECREMENT shift to state 33
-- On CHARLIT shift to state 34
-- On CHAR shift to state 20
-- On BYTE shift to state 21
-- On BOOLEANLIT shift to state 35
-- On BOOLEAN shift to state 22
-- On BNOT shift to state 36
-- On unaryExpression shift to state 44
-- On specialName shift to state 38
-- On shiftExpression shift to state 58
-- On relationalExpression shift to state 79
-- On realPostfixExpression shift to state 39
-- On qualifiedName shift to state 42
-- On primitiveType shift to state 61
-- On primaryExpression shift to state 64
-- On postfixExpression shift to state 65
-- On plainNewAllocationExpression shift to state 68
-- On notJustName shift to state 69
-- On newAllocationExpression shift to state 72
-- On multiplicativeExpression shift to state 73
-- On methodCall shift to state 75
-- On methodAccess shift to state 76
-- On logicalUnaryOperator shift to state 83
-- On logicalUnaryExpression shift to state 85
-- On inclusiveOrExpression shift to state 90
-- On fieldAccess shift to state 86
-- On expression shift to state 170
-- On exclusiveOrExpression shift to state 111
-- On equalityExpression shift to state 94
-- On conditionalOrExpression shift to state 112
-- On conditionalExpression shift to state 151
-- On conditionalAndExpression shift to state 117
-- On complexPrimaryNoParenthesis shift to state 87
-- On complexPrimary shift to state 88
-- On classAllocationExpression shift to state 100
-- On castExpression shift to state 103
-- On assignmentExpression shift to state 152
-- On arrayAllocationExpression shift to state 104
-- On arrayAccess shift to state 120
-- On arithmeticUnaryOperator shift to state 121
-- On andExpression shift to state 123
-- On additiveExpression shift to state 140

State 170:
argumentList -> argumentList COMM expression . [ RPAR COMM ]
-- On RPAR reduce production argumentList -> argumentList COMM expression 
-- On COMM reduce production argumentList -> argumentList COMM expression 

State 171:
multiplicativeExpression -> multiplicativeExpression MUL castExpression . [ XOR SEMI RSHIFT RPAR RCURL RBRAC QM PLUS OR NEQUAL MUL MOD MINUS LTHAN LSHIFT LOGSHIFT LETHAN INSTANCEOF GTHAN GETHAN EQUAL DIV COMM COL BOR BAND AND ]
-- On XOR reduce production multiplicativeExpression -> multiplicativeExpression MUL castExpression 
-- On SEMI reduce production multiplicativeExpression -> multiplicativeExpression MUL castExpression 
-- On RSHIFT reduce production multiplicativeExpression -> multiplicativeExpression MUL castExpression 
-- On RPAR reduce production multiplicativeExpression -> multiplicativeExpression MUL castExpression 
-- On RCURL reduce production multiplicativeExpression -> multiplicativeExpression MUL castExpression 
-- On RBRAC reduce production multiplicativeExpression -> multiplicativeExpression MUL castExpression 
-- On QM reduce production multiplicativeExpression -> multiplicativeExpression MUL castExpression 
-- On PLUS reduce production multiplicativeExpression -> multiplicativeExpression MUL castExpression 
-- On OR reduce production multiplicativeExpression -> multiplicativeExpression MUL castExpression 
-- On NEQUAL reduce production multiplicativeExpression -> multiplicativeExpression MUL castExpression 
-- On MUL reduce production multiplicativeExpression -> multiplicativeExpression MUL castExpression 
-- On MOD reduce production multiplicativeExpression -> multiplicativeExpression MUL castExpression 
-- On MINUS reduce production multiplicativeExpression -> multiplicativeExpression MUL castExpression 
-- On LTHAN reduce production multiplicativeExpression -> multiplicativeExpression MUL castExpression 
-- On LSHIFT reduce production multiplicativeExpression -> multiplicativeExpression MUL castExpression 
-- On LOGSHIFT reduce production multiplicativeExpression -> multiplicativeExpression MUL castExpression 
-- On LETHAN reduce production multiplicativeExpression -> multiplicativeExpression MUL castExpression 
-- On INSTANCEOF reduce production multiplicativeExpression -> multiplicativeExpression MUL castExpression 
-- On GTHAN reduce production multiplicativeExpression -> multiplicativeExpression MUL castExpression 
-- On GETHAN reduce production multiplicativeExpression -> multiplicativeExpression MUL castExpression 
-- On EQUAL reduce production multiplicativeExpression -> multiplicativeExpression MUL castExpression 
-- On DIV reduce production multiplicativeExpression -> multiplicativeExpression MUL castExpression 
-- On COMM reduce production multiplicativeExpression -> multiplicativeExpression MUL castExpression 
-- On COL reduce production multiplicativeExpression -> multiplicativeExpression MUL castExpression 
-- On BOR reduce production multiplicativeExpression -> multiplicativeExpression MUL castExpression 
-- On BAND reduce production multiplicativeExpression -> multiplicativeExpression MUL castExpression 
-- On AND reduce production multiplicativeExpression -> multiplicativeExpression MUL castExpression 

State 172:
additiveExpression -> additiveExpression . PLUS multiplicativeExpression [ XOR SEMI RSHIFT RPAR RCURL RBRAC QM PLUS OR NEQUAL MINUS LTHAN LSHIFT LOGSHIFT LETHAN INSTANCEOF GTHAN GETHAN EQUAL COMM COL BOR BAND AND ]
additiveExpression -> additiveExpression . MINUS multiplicativeExpression [ XOR SEMI RSHIFT RPAR RCURL RBRAC QM PLUS OR NEQUAL MINUS LTHAN LSHIFT LOGSHIFT LETHAN INSTANCEOF GTHAN GETHAN EQUAL COMM COL BOR BAND AND ]
shiftExpression -> shiftExpression RSHIFT additiveExpression . [ XOR SEMI RSHIFT RPAR RCURL RBRAC QM OR NEQUAL LTHAN LSHIFT LOGSHIFT LETHAN INSTANCEOF GTHAN GETHAN EQUAL COMM COL BOR BAND AND ]
-- On PLUS shift to state 141
-- On MINUS shift to state 147
-- On XOR reduce production shiftExpression -> shiftExpression RSHIFT additiveExpression 
-- On SEMI reduce production shiftExpression -> shiftExpression RSHIFT additiveExpression 
-- On RSHIFT reduce production shiftExpression -> shiftExpression RSHIFT additiveExpression 
-- On RPAR reduce production shiftExpression -> shiftExpression RSHIFT additiveExpression 
-- On RCURL reduce production shiftExpression -> shiftExpression RSHIFT additiveExpression 
-- On RBRAC reduce production shiftExpression -> shiftExpression RSHIFT additiveExpression 
-- On QM reduce production shiftExpression -> shiftExpression RSHIFT additiveExpression 
-- On OR reduce production shiftExpression -> shiftExpression RSHIFT additiveExpression 
-- On NEQUAL reduce production shiftExpression -> shiftExpression RSHIFT additiveExpression 
-- On LTHAN reduce production shiftExpression -> shiftExpression RSHIFT additiveExpression 
-- On LSHIFT reduce production shiftExpression -> shiftExpression RSHIFT additiveExpression 
-- On LOGSHIFT reduce production shiftExpression -> shiftExpression RSHIFT additiveExpression 
-- On LETHAN reduce production shiftExpression -> shiftExpression RSHIFT additiveExpression 
-- On INSTANCEOF reduce production shiftExpression -> shiftExpression RSHIFT additiveExpression 
-- On GTHAN reduce production shiftExpression -> shiftExpression RSHIFT additiveExpression 
-- On GETHAN reduce production shiftExpression -> shiftExpression RSHIFT additiveExpression 
-- On EQUAL reduce production shiftExpression -> shiftExpression RSHIFT additiveExpression 
-- On COMM reduce production shiftExpression -> shiftExpression RSHIFT additiveExpression 
-- On COL reduce production shiftExpression -> shiftExpression RSHIFT additiveExpression 
-- On BOR reduce production shiftExpression -> shiftExpression RSHIFT additiveExpression 
-- On BAND reduce production shiftExpression -> shiftExpression RSHIFT additiveExpression 
-- On AND reduce production shiftExpression -> shiftExpression RSHIFT additiveExpression 

State 173:
assignmentExpression -> unaryExpression assignmentOperator assignmentExpression . [ SEMI RPAR RCURL RBRAC COMM COL ]
-- On SEMI reduce production assignmentExpression -> unaryExpression assignmentOperator assignmentExpression 
-- On RPAR reduce production assignmentExpression -> unaryExpression assignmentOperator assignmentExpression 
-- On RCURL reduce production assignmentExpression -> unaryExpression assignmentOperator assignmentExpression 
-- On RBRAC reduce production assignmentExpression -> unaryExpression assignmentOperator assignmentExpression 
-- On COMM reduce production assignmentExpression -> unaryExpression assignmentOperator assignmentExpression 
-- On COL reduce production assignmentExpression -> unaryExpression assignmentOperator assignmentExpression 

State 174:
arrayAccess -> qualifiedName LBRAC expression . RBRAC [ XOREQUAL XOR SEMI RSHIFTEQUAL RSHIFT RPAR RCURL RBRAC QM PLUS PEQUAL OREQUAL OR NEQUAL MULEQUAL MUL MODEQUAL MOD MINUSEQUAL MINUS LTHAN LSHIFTEQUAL LSHIFT LPAR LOGSHIFTEQUAL LOGSHIFT LETHAN LBRAC INSTANCEOF INCREMENT GTHAN GETHAN EQUAL DOT DIVEQUAL DIV DECREMENT COMM COL BOR BAND ASSIGN ANDEQUAL AND ]
-- On RBRAC shift to state 175

State 175:
arrayAccess -> qualifiedName LBRAC expression RBRAC . [ XOREQUAL XOR SEMI RSHIFTEQUAL RSHIFT RPAR RCURL RBRAC QM PLUS PEQUAL OREQUAL OR NEQUAL MULEQUAL MUL MODEQUAL MOD MINUSEQUAL MINUS LTHAN LSHIFTEQUAL LSHIFT LPAR LOGSHIFTEQUAL LOGSHIFT LETHAN LBRAC INSTANCEOF INCREMENT GTHAN GETHAN EQUAL DOT DIVEQUAL DIV DECREMENT COMM COL BOR BAND ASSIGN ANDEQUAL AND ]
-- On XOREQUAL reduce production arrayAccess -> qualifiedName LBRAC expression RBRAC 
-- On XOR reduce production arrayAccess -> qualifiedName LBRAC expression RBRAC 
-- On SEMI reduce production arrayAccess -> qualifiedName LBRAC expression RBRAC 
-- On RSHIFTEQUAL reduce production arrayAccess -> qualifiedName LBRAC expression RBRAC 
-- On RSHIFT reduce production arrayAccess -> qualifiedName LBRAC expression RBRAC 
-- On RPAR reduce production arrayAccess -> qualifiedName LBRAC expression RBRAC 
-- On RCURL reduce production arrayAccess -> qualifiedName LBRAC expression RBRAC 
-- On RBRAC reduce production arrayAccess -> qualifiedName LBRAC expression RBRAC 
-- On QM reduce production arrayAccess -> qualifiedName LBRAC expression RBRAC 
-- On PLUS reduce production arrayAccess -> qualifiedName LBRAC expression RBRAC 
-- On PEQUAL reduce production arrayAccess -> qualifiedName LBRAC expression RBRAC 
-- On OREQUAL reduce production arrayAccess -> qualifiedName LBRAC expression RBRAC 
-- On OR reduce production arrayAccess -> qualifiedName LBRAC expression RBRAC 
-- On NEQUAL reduce production arrayAccess -> qualifiedName LBRAC expression RBRAC 
-- On MULEQUAL reduce production arrayAccess -> qualifiedName LBRAC expression RBRAC 
-- On MUL reduce production arrayAccess -> qualifiedName LBRAC expression RBRAC 
-- On MODEQUAL reduce production arrayAccess -> qualifiedName LBRAC expression RBRAC 
-- On MOD reduce production arrayAccess -> qualifiedName LBRAC expression RBRAC 
-- On MINUSEQUAL reduce production arrayAccess -> qualifiedName LBRAC expression RBRAC 
-- On MINUS reduce production arrayAccess -> qualifiedName LBRAC expression RBRAC 
-- On LTHAN reduce production arrayAccess -> qualifiedName LBRAC expression RBRAC 
-- On LSHIFTEQUAL reduce production arrayAccess -> qualifiedName LBRAC expression RBRAC 
-- On LSHIFT reduce production arrayAccess -> qualifiedName LBRAC expression RBRAC 
-- On LPAR reduce production arrayAccess -> qualifiedName LBRAC expression RBRAC 
-- On LOGSHIFTEQUAL reduce production arrayAccess -> qualifiedName LBRAC expression RBRAC 
-- On LOGSHIFT reduce production arrayAccess -> qualifiedName LBRAC expression RBRAC 
-- On LETHAN reduce production arrayAccess -> qualifiedName LBRAC expression RBRAC 
-- On LBRAC reduce production arrayAccess -> qualifiedName LBRAC expression RBRAC 
-- On INSTANCEOF reduce production arrayAccess -> qualifiedName LBRAC expression RBRAC 
-- On INCREMENT reduce production arrayAccess -> qualifiedName LBRAC expression RBRAC 
-- On GTHAN reduce production arrayAccess -> qualifiedName LBRAC expression RBRAC 
-- On GETHAN reduce production arrayAccess -> qualifiedName LBRAC expression RBRAC 
-- On EQUAL reduce production arrayAccess -> qualifiedName LBRAC expression RBRAC 
-- On DOT reduce production arrayAccess -> qualifiedName LBRAC expression RBRAC 
-- On DIVEQUAL reduce production arrayAccess -> qualifiedName LBRAC expression RBRAC 
-- On DIV reduce production arrayAccess -> qualifiedName LBRAC expression RBRAC 
-- On DECREMENT reduce production arrayAccess -> qualifiedName LBRAC expression RBRAC 
-- On COMM reduce production arrayAccess -> qualifiedName LBRAC expression RBRAC 
-- On COL reduce production arrayAccess -> qualifiedName LBRAC expression RBRAC 
-- On BOR reduce production arrayAccess -> qualifiedName LBRAC expression RBRAC 
-- On BAND reduce production arrayAccess -> qualifiedName LBRAC expression RBRAC 
-- On ASSIGN reduce production arrayAccess -> qualifiedName LBRAC expression RBRAC 
-- On ANDEQUAL reduce production arrayAccess -> qualifiedName LBRAC expression RBRAC 
-- On AND reduce production arrayAccess -> qualifiedName LBRAC expression RBRAC 

State 176:
fieldAccess -> qualifiedName DOT . THIS [ XOREQUAL XOR SEMI RSHIFTEQUAL RSHIFT RPAR RCURL RBRAC QM PLUS PEQUAL OREQUAL OR NEQUAL MULEQUAL MUL MODEQUAL MOD MINUSEQUAL MINUS LTHAN LSHIFTEQUAL LSHIFT LPAR LOGSHIFTEQUAL LOGSHIFT LETHAN LBRAC INSTANCEOF INCREMENT GTHAN GETHAN EQUAL DOT DIVEQUAL DIV DECREMENT COMM COL BOR BAND ASSIGN ANDEQUAL AND ]
fieldAccess -> qualifiedName DOT . CLASS [ XOREQUAL XOR SEMI RSHIFTEQUAL RSHIFT RPAR RCURL RBRAC QM PLUS PEQUAL OREQUAL OR NEQUAL MULEQUAL MUL MODEQUAL MOD MINUSEQUAL MINUS LTHAN LSHIFTEQUAL LSHIFT LPAR LOGSHIFTEQUAL LOGSHIFT LETHAN LBRAC INSTANCEOF INCREMENT GTHAN GETHAN EQUAL DOT DIVEQUAL DIV DECREMENT COMM COL BOR BAND ASSIGN ANDEQUAL AND ]
newAllocationExpression -> qualifiedName DOT . plainNewAllocationExpression [ XOREQUAL XOR SEMI RSHIFTEQUAL RSHIFT RPAR RCURL RBRAC QM PLUS PEQUAL OREQUAL OR NEQUAL MULEQUAL MUL MODEQUAL MOD MINUSEQUAL MINUS LTHAN LSHIFTEQUAL LSHIFT LOGSHIFTEQUAL LOGSHIFT LETHAN INSTANCEOF INCREMENT GTHAN GETHAN EQUAL DOT DIVEQUAL DIV DECREMENT COMM COL BOR BAND ASSIGN ANDEQUAL AND ]
qualifiedName -> qualifiedName DOT . IDENTIFIER [ XOREQUAL XOR SEMI RSHIFTEQUAL RSHIFT RPAR RCURL RBRAC QM PLUS PEQUAL OREQUAL OR NEQUAL MULEQUAL MUL MODEQUAL MOD MINUSEQUAL MINUS LTHAN LSHIFTEQUAL LSHIFT LPAR LOGSHIFTEQUAL LOGSHIFT LETHAN LBRAC INSTANCEOF INCREMENT IDENTIFIER GTHAN GETHAN EQUAL DOT DIVEQUAL DIV DIM DECREMENT COMM COL BOR BAND ASSIGN ANDEQUAL AND ]
-- On THIS shift to state 177
-- On NEW shift to state 14
-- On IDENTIFIER shift to state 136
-- On CLASS shift to state 178
-- On plainNewAllocationExpression shift to state 179
-- On classAllocationExpression shift to state 100
-- On arrayAllocationExpression shift to state 104

State 177:
fieldAccess -> qualifiedName DOT THIS . [ XOREQUAL XOR SEMI RSHIFTEQUAL RSHIFT RPAR RCURL RBRAC QM PLUS PEQUAL OREQUAL OR NEQUAL MULEQUAL MUL MODEQUAL MOD MINUSEQUAL MINUS LTHAN LSHIFTEQUAL LSHIFT LPAR LOGSHIFTEQUAL LOGSHIFT LETHAN LBRAC INSTANCEOF INCREMENT GTHAN GETHAN EQUAL DOT DIVEQUAL DIV DECREMENT COMM COL BOR BAND ASSIGN ANDEQUAL AND ]
-- On XOREQUAL reduce production fieldAccess -> qualifiedName DOT THIS 
-- On XOR reduce production fieldAccess -> qualifiedName DOT THIS 
-- On SEMI reduce production fieldAccess -> qualifiedName DOT THIS 
-- On RSHIFTEQUAL reduce production fieldAccess -> qualifiedName DOT THIS 
-- On RSHIFT reduce production fieldAccess -> qualifiedName DOT THIS 
-- On RPAR reduce production fieldAccess -> qualifiedName DOT THIS 
-- On RCURL reduce production fieldAccess -> qualifiedName DOT THIS 
-- On RBRAC reduce production fieldAccess -> qualifiedName DOT THIS 
-- On QM reduce production fieldAccess -> qualifiedName DOT THIS 
-- On PLUS reduce production fieldAccess -> qualifiedName DOT THIS 
-- On PEQUAL reduce production fieldAccess -> qualifiedName DOT THIS 
-- On OREQUAL reduce production fieldAccess -> qualifiedName DOT THIS 
-- On OR reduce production fieldAccess -> qualifiedName DOT THIS 
-- On NEQUAL reduce production fieldAccess -> qualifiedName DOT THIS 
-- On MULEQUAL reduce production fieldAccess -> qualifiedName DOT THIS 
-- On MUL reduce production fieldAccess -> qualifiedName DOT THIS 
-- On MODEQUAL reduce production fieldAccess -> qualifiedName DOT THIS 
-- On MOD reduce production fieldAccess -> qualifiedName DOT THIS 
-- On MINUSEQUAL reduce production fieldAccess -> qualifiedName DOT THIS 
-- On MINUS reduce production fieldAccess -> qualifiedName DOT THIS 
-- On LTHAN reduce production fieldAccess -> qualifiedName DOT THIS 
-- On LSHIFTEQUAL reduce production fieldAccess -> qualifiedName DOT THIS 
-- On LSHIFT reduce production fieldAccess -> qualifiedName DOT THIS 
-- On LPAR reduce production fieldAccess -> qualifiedName DOT THIS 
-- On LOGSHIFTEQUAL reduce production fieldAccess -> qualifiedName DOT THIS 
-- On LOGSHIFT reduce production fieldAccess -> qualifiedName DOT THIS 
-- On LETHAN reduce production fieldAccess -> qualifiedName DOT THIS 
-- On LBRAC reduce production fieldAccess -> qualifiedName DOT THIS 
-- On INSTANCEOF reduce production fieldAccess -> qualifiedName DOT THIS 
-- On INCREMENT reduce production fieldAccess -> qualifiedName DOT THIS 
-- On GTHAN reduce production fieldAccess -> qualifiedName DOT THIS 
-- On GETHAN reduce production fieldAccess -> qualifiedName DOT THIS 
-- On EQUAL reduce production fieldAccess -> qualifiedName DOT THIS 
-- On DOT reduce production fieldAccess -> qualifiedName DOT THIS 
-- On DIVEQUAL reduce production fieldAccess -> qualifiedName DOT THIS 
-- On DIV reduce production fieldAccess -> qualifiedName DOT THIS 
-- On DECREMENT reduce production fieldAccess -> qualifiedName DOT THIS 
-- On COMM reduce production fieldAccess -> qualifiedName DOT THIS 
-- On COL reduce production fieldAccess -> qualifiedName DOT THIS 
-- On BOR reduce production fieldAccess -> qualifiedName DOT THIS 
-- On BAND reduce production fieldAccess -> qualifiedName DOT THIS 
-- On ASSIGN reduce production fieldAccess -> qualifiedName DOT THIS 
-- On ANDEQUAL reduce production fieldAccess -> qualifiedName DOT THIS 
-- On AND reduce production fieldAccess -> qualifiedName DOT THIS 

State 178:
fieldAccess -> qualifiedName DOT CLASS . [ XOREQUAL XOR SEMI RSHIFTEQUAL RSHIFT RPAR RCURL RBRAC QM PLUS PEQUAL OREQUAL OR NEQUAL MULEQUAL MUL MODEQUAL MOD MINUSEQUAL MINUS LTHAN LSHIFTEQUAL LSHIFT LPAR LOGSHIFTEQUAL LOGSHIFT LETHAN LBRAC INSTANCEOF INCREMENT GTHAN GETHAN EQUAL DOT DIVEQUAL DIV DECREMENT COMM COL BOR BAND ASSIGN ANDEQUAL AND ]
-- On XOREQUAL reduce production fieldAccess -> qualifiedName DOT CLASS 
-- On XOR reduce production fieldAccess -> qualifiedName DOT CLASS 
-- On SEMI reduce production fieldAccess -> qualifiedName DOT CLASS 
-- On RSHIFTEQUAL reduce production fieldAccess -> qualifiedName DOT CLASS 
-- On RSHIFT reduce production fieldAccess -> qualifiedName DOT CLASS 
-- On RPAR reduce production fieldAccess -> qualifiedName DOT CLASS 
-- On RCURL reduce production fieldAccess -> qualifiedName DOT CLASS 
-- On RBRAC reduce production fieldAccess -> qualifiedName DOT CLASS 
-- On QM reduce production fieldAccess -> qualifiedName DOT CLASS 
-- On PLUS reduce production fieldAccess -> qualifiedName DOT CLASS 
-- On PEQUAL reduce production fieldAccess -> qualifiedName DOT CLASS 
-- On OREQUAL reduce production fieldAccess -> qualifiedName DOT CLASS 
-- On OR reduce production fieldAccess -> qualifiedName DOT CLASS 
-- On NEQUAL reduce production fieldAccess -> qualifiedName DOT CLASS 
-- On MULEQUAL reduce production fieldAccess -> qualifiedName DOT CLASS 
-- On MUL reduce production fieldAccess -> qualifiedName DOT CLASS 
-- On MODEQUAL reduce production fieldAccess -> qualifiedName DOT CLASS 
-- On MOD reduce production fieldAccess -> qualifiedName DOT CLASS 
-- On MINUSEQUAL reduce production fieldAccess -> qualifiedName DOT CLASS 
-- On MINUS reduce production fieldAccess -> qualifiedName DOT CLASS 
-- On LTHAN reduce production fieldAccess -> qualifiedName DOT CLASS 
-- On LSHIFTEQUAL reduce production fieldAccess -> qualifiedName DOT CLASS 
-- On LSHIFT reduce production fieldAccess -> qualifiedName DOT CLASS 
-- On LPAR reduce production fieldAccess -> qualifiedName DOT CLASS 
-- On LOGSHIFTEQUAL reduce production fieldAccess -> qualifiedName DOT CLASS 
-- On LOGSHIFT reduce production fieldAccess -> qualifiedName DOT CLASS 
-- On LETHAN reduce production fieldAccess -> qualifiedName DOT CLASS 
-- On LBRAC reduce production fieldAccess -> qualifiedName DOT CLASS 
-- On INSTANCEOF reduce production fieldAccess -> qualifiedName DOT CLASS 
-- On INCREMENT reduce production fieldAccess -> qualifiedName DOT CLASS 
-- On GTHAN reduce production fieldAccess -> qualifiedName DOT CLASS 
-- On GETHAN reduce production fieldAccess -> qualifiedName DOT CLASS 
-- On EQUAL reduce production fieldAccess -> qualifiedName DOT CLASS 
-- On DOT reduce production fieldAccess -> qualifiedName DOT CLASS 
-- On DIVEQUAL reduce production fieldAccess -> qualifiedName DOT CLASS 
-- On DIV reduce production fieldAccess -> qualifiedName DOT CLASS 
-- On DECREMENT reduce production fieldAccess -> qualifiedName DOT CLASS 
-- On COMM reduce production fieldAccess -> qualifiedName DOT CLASS 
-- On COL reduce production fieldAccess -> qualifiedName DOT CLASS 
-- On BOR reduce production fieldAccess -> qualifiedName DOT CLASS 
-- On BAND reduce production fieldAccess -> qualifiedName DOT CLASS 
-- On ASSIGN reduce production fieldAccess -> qualifiedName DOT CLASS 
-- On ANDEQUAL reduce production fieldAccess -> qualifiedName DOT CLASS 
-- On AND reduce production fieldAccess -> qualifiedName DOT CLASS 

State 179:
newAllocationExpression -> qualifiedName DOT plainNewAllocationExpression . [ XOREQUAL XOR SEMI RSHIFTEQUAL RSHIFT RPAR RCURL RBRAC QM PLUS PEQUAL OREQUAL OR NEQUAL MULEQUAL MUL MODEQUAL MOD MINUSEQUAL MINUS LTHAN LSHIFTEQUAL LSHIFT LOGSHIFTEQUAL LOGSHIFT LETHAN INSTANCEOF INCREMENT GTHAN GETHAN EQUAL DOT DIVEQUAL DIV DECREMENT COMM COL BOR BAND ASSIGN ANDEQUAL AND ]
-- On XOREQUAL reduce production newAllocationExpression -> qualifiedName DOT plainNewAllocationExpression 
-- On XOR reduce production newAllocationExpression -> qualifiedName DOT plainNewAllocationExpression 
-- On SEMI reduce production newAllocationExpression -> qualifiedName DOT plainNewAllocationExpression 
-- On RSHIFTEQUAL reduce production newAllocationExpression -> qualifiedName DOT plainNewAllocationExpression 
-- On RSHIFT reduce production newAllocationExpression -> qualifiedName DOT plainNewAllocationExpression 
-- On RPAR reduce production newAllocationExpression -> qualifiedName DOT plainNewAllocationExpression 
-- On RCURL reduce production newAllocationExpression -> qualifiedName DOT plainNewAllocationExpression 
-- On RBRAC reduce production newAllocationExpression -> qualifiedName DOT plainNewAllocationExpression 
-- On QM reduce production newAllocationExpression -> qualifiedName DOT plainNewAllocationExpression 
-- On PLUS reduce production newAllocationExpression -> qualifiedName DOT plainNewAllocationExpression 
-- On PEQUAL reduce production newAllocationExpression -> qualifiedName DOT plainNewAllocationExpression 
-- On OREQUAL reduce production newAllocationExpression -> qualifiedName DOT plainNewAllocationExpression 
-- On OR reduce production newAllocationExpression -> qualifiedName DOT plainNewAllocationExpression 
-- On NEQUAL reduce production newAllocationExpression -> qualifiedName DOT plainNewAllocationExpression 
-- On MULEQUAL reduce production newAllocationExpression -> qualifiedName DOT plainNewAllocationExpression 
-- On MUL reduce production newAllocationExpression -> qualifiedName DOT plainNewAllocationExpression 
-- On MODEQUAL reduce production newAllocationExpression -> qualifiedName DOT plainNewAllocationExpression 
-- On MOD reduce production newAllocationExpression -> qualifiedName DOT plainNewAllocationExpression 
-- On MINUSEQUAL reduce production newAllocationExpression -> qualifiedName DOT plainNewAllocationExpression 
-- On MINUS reduce production newAllocationExpression -> qualifiedName DOT plainNewAllocationExpression 
-- On LTHAN reduce production newAllocationExpression -> qualifiedName DOT plainNewAllocationExpression 
-- On LSHIFTEQUAL reduce production newAllocationExpression -> qualifiedName DOT plainNewAllocationExpression 
-- On LSHIFT reduce production newAllocationExpression -> qualifiedName DOT plainNewAllocationExpression 
-- On LOGSHIFTEQUAL reduce production newAllocationExpression -> qualifiedName DOT plainNewAllocationExpression 
-- On LOGSHIFT reduce production newAllocationExpression -> qualifiedName DOT plainNewAllocationExpression 
-- On LETHAN reduce production newAllocationExpression -> qualifiedName DOT plainNewAllocationExpression 
-- On INSTANCEOF reduce production newAllocationExpression -> qualifiedName DOT plainNewAllocationExpression 
-- On INCREMENT reduce production newAllocationExpression -> qualifiedName DOT plainNewAllocationExpression 
-- On GTHAN reduce production newAllocationExpression -> qualifiedName DOT plainNewAllocationExpression 
-- On GETHAN reduce production newAllocationExpression -> qualifiedName DOT plainNewAllocationExpression 
-- On EQUAL reduce production newAllocationExpression -> qualifiedName DOT plainNewAllocationExpression 
-- On DOT reduce production newAllocationExpression -> qualifiedName DOT plainNewAllocationExpression 
-- On DIVEQUAL reduce production newAllocationExpression -> qualifiedName DOT plainNewAllocationExpression 
-- On DIV reduce production newAllocationExpression -> qualifiedName DOT plainNewAllocationExpression 
-- On DECREMENT reduce production newAllocationExpression -> qualifiedName DOT plainNewAllocationExpression 
-- On COMM reduce production newAllocationExpression -> qualifiedName DOT plainNewAllocationExpression 
-- On COL reduce production newAllocationExpression -> qualifiedName DOT plainNewAllocationExpression 
-- On BOR reduce production newAllocationExpression -> qualifiedName DOT plainNewAllocationExpression 
-- On BAND reduce production newAllocationExpression -> qualifiedName DOT plainNewAllocationExpression 
-- On ASSIGN reduce production newAllocationExpression -> qualifiedName DOT plainNewAllocationExpression 
-- On ANDEQUAL reduce production newAllocationExpression -> qualifiedName DOT plainNewAllocationExpression 
-- On AND reduce production newAllocationExpression -> qualifiedName DOT plainNewAllocationExpression 

State 180:
complexPrimary -> LPAR expression . RPAR [ XOREQUAL XOR SEMI RSHIFTEQUAL RSHIFT RPAR RCURL RBRAC QM PLUS PEQUAL OREQUAL OR NEQUAL MULEQUAL MUL MODEQUAL MOD MINUSEQUAL MINUS LTHAN LSHIFTEQUAL LSHIFT LOGSHIFTEQUAL LOGSHIFT LETHAN LBRAC INSTANCEOF INCREMENT GTHAN GETHAN EQUAL DOT DIVEQUAL DIV DECREMENT COMM COL BOR BAND ASSIGN ANDEQUAL AND ]
-- On RPAR shift to state 181

State 181:
complexPrimary -> LPAR expression RPAR . [ XOREQUAL XOR SEMI RSHIFTEQUAL RSHIFT RPAR RCURL RBRAC QM PLUS PEQUAL OREQUAL OR NEQUAL MULEQUAL MUL MODEQUAL MOD MINUSEQUAL MINUS LTHAN LSHIFTEQUAL LSHIFT LOGSHIFTEQUAL LOGSHIFT LETHAN LBRAC INSTANCEOF INCREMENT GTHAN GETHAN EQUAL DOT DIVEQUAL DIV DECREMENT COMM COL BOR BAND ASSIGN ANDEQUAL AND ]
-- On XOREQUAL reduce production complexPrimary -> LPAR expression RPAR 
-- On XOR reduce production complexPrimary -> LPAR expression RPAR 
-- On SEMI reduce production complexPrimary -> LPAR expression RPAR 
-- On RSHIFTEQUAL reduce production complexPrimary -> LPAR expression RPAR 
-- On RSHIFT reduce production complexPrimary -> LPAR expression RPAR 
-- On RPAR reduce production complexPrimary -> LPAR expression RPAR 
-- On RCURL reduce production complexPrimary -> LPAR expression RPAR 
-- On RBRAC reduce production complexPrimary -> LPAR expression RPAR 
-- On QM reduce production complexPrimary -> LPAR expression RPAR 
-- On PLUS reduce production complexPrimary -> LPAR expression RPAR 
-- On PEQUAL reduce production complexPrimary -> LPAR expression RPAR 
-- On OREQUAL reduce production complexPrimary -> LPAR expression RPAR 
-- On OR reduce production complexPrimary -> LPAR expression RPAR 
-- On NEQUAL reduce production complexPrimary -> LPAR expression RPAR 
-- On MULEQUAL reduce production complexPrimary -> LPAR expression RPAR 
-- On MUL reduce production complexPrimary -> LPAR expression RPAR 
-- On MODEQUAL reduce production complexPrimary -> LPAR expression RPAR 
-- On MOD reduce production complexPrimary -> LPAR expression RPAR 
-- On MINUSEQUAL reduce production complexPrimary -> LPAR expression RPAR 
-- On MINUS reduce production complexPrimary -> LPAR expression RPAR 
-- On LTHAN reduce production complexPrimary -> LPAR expression RPAR 
-- On LSHIFTEQUAL reduce production complexPrimary -> LPAR expression RPAR 
-- On LSHIFT reduce production complexPrimary -> LPAR expression RPAR 
-- On LOGSHIFTEQUAL reduce production complexPrimary -> LPAR expression RPAR 
-- On LOGSHIFT reduce production complexPrimary -> LPAR expression RPAR 
-- On LETHAN reduce production complexPrimary -> LPAR expression RPAR 
-- On LBRAC reduce production complexPrimary -> LPAR expression RPAR 
-- On INSTANCEOF reduce production complexPrimary -> LPAR expression RPAR 
-- On INCREMENT reduce production complexPrimary -> LPAR expression RPAR 
-- On GTHAN reduce production complexPrimary -> LPAR expression RPAR 
-- On GETHAN reduce production complexPrimary -> LPAR expression RPAR 
-- On EQUAL reduce production complexPrimary -> LPAR expression RPAR 
-- On DOT reduce production complexPrimary -> LPAR expression RPAR 
-- On DIVEQUAL reduce production complexPrimary -> LPAR expression RPAR 
-- On DIV reduce production complexPrimary -> LPAR expression RPAR 
-- On DECREMENT reduce production complexPrimary -> LPAR expression RPAR 
-- On COMM reduce production complexPrimary -> LPAR expression RPAR 
-- On COL reduce production complexPrimary -> LPAR expression RPAR 
-- On BOR reduce production complexPrimary -> LPAR expression RPAR 
-- On BAND reduce production complexPrimary -> LPAR expression RPAR 
-- On ASSIGN reduce production complexPrimary -> LPAR expression RPAR 
-- On ANDEQUAL reduce production complexPrimary -> LPAR expression RPAR 
-- On AND reduce production complexPrimary -> LPAR expression RPAR 

State 182:
unaryExpression -> INCREMENT unaryExpression . [ XOREQUAL XOR SEMI RSHIFTEQUAL RSHIFT RPAR RCURL RBRAC QM PLUS PEQUAL OREQUAL OR NEQUAL MULEQUAL MUL MODEQUAL MOD MINUSEQUAL MINUS LTHAN LSHIFTEQUAL LSHIFT LOGSHIFTEQUAL LOGSHIFT LETHAN INSTANCEOF GTHAN GETHAN EQUAL DIVEQUAL DIV COMM COL BOR BAND ASSIGN ANDEQUAL AND ]
-- On XOREQUAL reduce production unaryExpression -> INCREMENT unaryExpression 
-- On XOR reduce production unaryExpression -> INCREMENT unaryExpression 
-- On SEMI reduce production unaryExpression -> INCREMENT unaryExpression 
-- On RSHIFTEQUAL reduce production unaryExpression -> INCREMENT unaryExpression 
-- On RSHIFT reduce production unaryExpression -> INCREMENT unaryExpression 
-- On RPAR reduce production unaryExpression -> INCREMENT unaryExpression 
-- On RCURL reduce production unaryExpression -> INCREMENT unaryExpression 
-- On RBRAC reduce production unaryExpression -> INCREMENT unaryExpression 
-- On QM reduce production unaryExpression -> INCREMENT unaryExpression 
-- On PLUS reduce production unaryExpression -> INCREMENT unaryExpression 
-- On PEQUAL reduce production unaryExpression -> INCREMENT unaryExpression 
-- On OREQUAL reduce production unaryExpression -> INCREMENT unaryExpression 
-- On OR reduce production unaryExpression -> INCREMENT unaryExpression 
-- On NEQUAL reduce production unaryExpression -> INCREMENT unaryExpression 
-- On MULEQUAL reduce production unaryExpression -> INCREMENT unaryExpression 
-- On MUL reduce production unaryExpression -> INCREMENT unaryExpression 
-- On MODEQUAL reduce production unaryExpression -> INCREMENT unaryExpression 
-- On MOD reduce production unaryExpression -> INCREMENT unaryExpression 
-- On MINUSEQUAL reduce production unaryExpression -> INCREMENT unaryExpression 
-- On MINUS reduce production unaryExpression -> INCREMENT unaryExpression 
-- On LTHAN reduce production unaryExpression -> INCREMENT unaryExpression 
-- On LSHIFTEQUAL reduce production unaryExpression -> INCREMENT unaryExpression 
-- On LSHIFT reduce production unaryExpression -> INCREMENT unaryExpression 
-- On LOGSHIFTEQUAL reduce production unaryExpression -> INCREMENT unaryExpression 
-- On LOGSHIFT reduce production unaryExpression -> INCREMENT unaryExpression 
-- On LETHAN reduce production unaryExpression -> INCREMENT unaryExpression 
-- On INSTANCEOF reduce production unaryExpression -> INCREMENT unaryExpression 
-- On GTHAN reduce production unaryExpression -> INCREMENT unaryExpression 
-- On GETHAN reduce production unaryExpression -> INCREMENT unaryExpression 
-- On EQUAL reduce production unaryExpression -> INCREMENT unaryExpression 
-- On DIVEQUAL reduce production unaryExpression -> INCREMENT unaryExpression 
-- On DIV reduce production unaryExpression -> INCREMENT unaryExpression 
-- On COMM reduce production unaryExpression -> INCREMENT unaryExpression 
-- On COL reduce production unaryExpression -> INCREMENT unaryExpression 
-- On BOR reduce production unaryExpression -> INCREMENT unaryExpression 
-- On BAND reduce production unaryExpression -> INCREMENT unaryExpression 
-- On ASSIGN reduce production unaryExpression -> INCREMENT unaryExpression 
-- On ANDEQUAL reduce production unaryExpression -> INCREMENT unaryExpression 
-- On AND reduce production unaryExpression -> INCREMENT unaryExpression 

State 183:
arrayAccess -> qualifiedName . LBRAC expression RBRAC [ XOREQUAL XOR RSHIFTEQUAL RSHIFT RPAR QM PLUS PEQUAL OREQUAL OR NEQUAL MULEQUAL MUL MODEQUAL MOD MINUSEQUAL MINUS LTHAN LSHIFTEQUAL LSHIFT LPAR LOGSHIFTEQUAL LOGSHIFT LETHAN LBRAC INSTANCEOF INCREMENT GTHAN GETHAN EQUAL DOT DIVEQUAL DIV DECREMENT BOR BAND ASSIGN ANDEQUAL AND ]
classTypeExpression -> qualifiedName . dims [ RPAR ]
fieldAccess -> qualifiedName . DOT THIS [ XOREQUAL XOR RSHIFTEQUAL RSHIFT RPAR QM PLUS PEQUAL OREQUAL OR NEQUAL MULEQUAL MUL MODEQUAL MOD MINUSEQUAL MINUS LTHAN LSHIFTEQUAL LSHIFT LPAR LOGSHIFTEQUAL LOGSHIFT LETHAN LBRAC INSTANCEOF INCREMENT GTHAN GETHAN EQUAL DOT DIVEQUAL DIV DECREMENT BOR BAND ASSIGN ANDEQUAL AND ]
fieldAccess -> qualifiedName . DOT CLASS [ XOREQUAL XOR RSHIFTEQUAL RSHIFT RPAR QM PLUS PEQUAL OREQUAL OR NEQUAL MULEQUAL MUL MODEQUAL MOD MINUSEQUAL MINUS LTHAN LSHIFTEQUAL LSHIFT LPAR LOGSHIFTEQUAL LOGSHIFT LETHAN LBRAC INSTANCEOF INCREMENT GTHAN GETHAN EQUAL DOT DIVEQUAL DIV DECREMENT BOR BAND ASSIGN ANDEQUAL AND ]
methodAccess -> qualifiedName . [ LPAR ]
newAllocationExpression -> qualifiedName . DOT plainNewAllocationExpression [ XOREQUAL XOR RSHIFTEQUAL RSHIFT RPAR QM PLUS PEQUAL OREQUAL OR NEQUAL MULEQUAL MUL MODEQUAL MOD MINUSEQUAL MINUS LTHAN LSHIFTEQUAL LSHIFT LOGSHIFTEQUAL LOGSHIFT LETHAN INSTANCEOF INCREMENT GTHAN GETHAN EQUAL DOT DIVEQUAL DIV DECREMENT BOR BAND ASSIGN ANDEQUAL AND ]
primaryExpression -> qualifiedName . [ XOREQUAL XOR RSHIFTEQUAL RSHIFT RPAR QM PLUS PEQUAL OREQUAL OR NEQUAL MULEQUAL MUL MODEQUAL MOD MINUSEQUAL MINUS LTHAN LSHIFTEQUAL LSHIFT LOGSHIFTEQUAL LOGSHIFT LETHAN INSTANCEOF INCREMENT GTHAN GETHAN EQUAL DIVEQUAL DIV DECREMENT BOR BAND ASSIGN ANDEQUAL AND ]
qualifiedName -> qualifiedName . DOT IDENTIFIER [ XOREQUAL XOR RSHIFTEQUAL RSHIFT RPAR QM PLUS PEQUAL OREQUAL OR NEQUAL MULEQUAL MUL MODEQUAL MOD MINUSEQUAL MINUS LTHAN LSHIFTEQUAL LSHIFT LPAR LOGSHIFTEQUAL LOGSHIFT LETHAN LBRAC INSTANCEOF INCREMENT GTHAN GETHAN EQUAL DOT DIVEQUAL DIV DIM DECREMENT BOR BAND ASSIGN ANDEQUAL AND ]
-- On LBRAC shift to state 43
-- On DOT shift to state 176
-- On DIM shift to state 131
-- On dims shift to state 184
-- On XOREQUAL reduce production primaryExpression -> qualifiedName 
-- On XOR reduce production primaryExpression -> qualifiedName 
-- On RSHIFTEQUAL reduce production primaryExpression -> qualifiedName 
-- On RSHIFT reduce production primaryExpression -> qualifiedName 
-- On RPAR reduce production primaryExpression -> qualifiedName 
-- On QM reduce production primaryExpression -> qualifiedName 
-- On PLUS reduce production primaryExpression -> qualifiedName 
-- On PEQUAL reduce production primaryExpression -> qualifiedName 
-- On OREQUAL reduce production primaryExpression -> qualifiedName 
-- On OR reduce production primaryExpression -> qualifiedName 
-- On NEQUAL reduce production primaryExpression -> qualifiedName 
-- On MULEQUAL reduce production primaryExpression -> qualifiedName 
-- On MUL reduce production primaryExpression -> qualifiedName 
-- On MODEQUAL reduce production primaryExpression -> qualifiedName 
-- On MOD reduce production primaryExpression -> qualifiedName 
-- On MINUSEQUAL reduce production primaryExpression -> qualifiedName 
-- On MINUS reduce production primaryExpression -> qualifiedName 
-- On LTHAN reduce production primaryExpression -> qualifiedName 
-- On LSHIFTEQUAL reduce production primaryExpression -> qualifiedName 
-- On LSHIFT reduce production primaryExpression -> qualifiedName 
-- On LPAR reduce production methodAccess -> qualifiedName 
-- On LOGSHIFTEQUAL reduce production primaryExpression -> qualifiedName 
-- On LOGSHIFT reduce production primaryExpression -> qualifiedName 
-- On LETHAN reduce production primaryExpression -> qualifiedName 
-- On INSTANCEOF reduce production primaryExpression -> qualifiedName 
-- On INCREMENT reduce production primaryExpression -> qualifiedName 
-- On GTHAN reduce production primaryExpression -> qualifiedName 
-- On GETHAN reduce production primaryExpression -> qualifiedName 
-- On EQUAL reduce production primaryExpression -> qualifiedName 
-- On DIVEQUAL reduce production primaryExpression -> qualifiedName 
-- On DIV reduce production primaryExpression -> qualifiedName 
-- On DECREMENT reduce production primaryExpression -> qualifiedName 
-- On BOR reduce production primaryExpression -> qualifiedName 
-- On BAND reduce production primaryExpression -> qualifiedName 
-- On ASSIGN reduce production primaryExpression -> qualifiedName 
-- On ANDEQUAL reduce production primaryExpression -> qualifiedName 
-- On AND reduce production primaryExpression -> qualifiedName 

State 184:
classTypeExpression -> qualifiedName dims . [ RPAR ]
dims -> dims . DIM [ RPAR DIM ]
-- On DIM shift to state 133
-- On RPAR reduce production classTypeExpression -> qualifiedName dims 

State 185:
castExpression -> LPAR primitiveTypeExpression . RPAR castExpression [ XOREQUAL XOR SEMI RSHIFTEQUAL RSHIFT RPAR RCURL RBRAC QM PLUS PEQUAL OREQUAL OR NEQUAL MULEQUAL MUL MODEQUAL MOD MINUSEQUAL MINUS LTHAN LSHIFTEQUAL LSHIFT LOGSHIFTEQUAL LOGSHIFT LETHAN INSTANCEOF GTHAN GETHAN EQUAL DIVEQUAL DIV COMM COL BOR BAND ASSIGN ANDEQUAL AND ]
-- On RPAR shift to state 186

State 186:
castExpression -> LPAR primitiveTypeExpression RPAR . castExpression [ XOREQUAL XOR SEMI RSHIFTEQUAL RSHIFT RPAR RCURL RBRAC QM PLUS PEQUAL OREQUAL OR NEQUAL MULEQUAL MUL MODEQUAL MOD MINUSEQUAL MINUS LTHAN LSHIFTEQUAL LSHIFT LOGSHIFTEQUAL LOGSHIFT LETHAN INSTANCEOF GTHAN GETHAN EQUAL DIVEQUAL DIV COMM COL BOR BAND ASSIGN ANDEQUAL AND ]
-- On VOID shift to state 6
-- On THIS shift to state 7
-- On SUPER shift to state 8
-- On STRLIT shift to state 9
-- On SHORT shift to state 10
-- On PLUS shift to state 11
-- On NULLLIT shift to state 12
-- On NOT shift to state 13
-- On NEW shift to state 14
-- On MINUS shift to state 26
-- On LPAR shift to state 27
-- On LONG shift to state 15
-- On INTLIT shift to state 28
-- On INT shift to state 16
-- On INCREMENT shift to state 29
-- On IDENTIFIER shift to state 17
-- On FLOATLIT shift to state 31
-- On FLOAT shift to state 18
-- On DOUBLELIT shift to state 32
-- On DOUBLE shift to state 19
-- On DECREMENT shift to state 33
-- On CHARLIT shift to state 34
-- On CHAR shift to state 20
-- On BYTE shift to state 21
-- On BOOLEANLIT shift to state 35
-- On BOOLEAN shift to state 22
-- On BNOT shift to state 36
-- On unaryExpression shift to state 60
-- On specialName shift to state 38
-- On realPostfixExpression shift to state 39
-- On qualifiedName shift to state 42
-- On primitiveType shift to state 61
-- On primaryExpression shift to state 64
-- On postfixExpression shift to state 65
-- On plainNewAllocationExpression shift to state 68
-- On notJustName shift to state 69
-- On newAllocationExpression shift to state 72
-- On methodCall shift to state 75
-- On methodAccess shift to state 76
-- On logicalUnaryOperator shift to state 83
-- On logicalUnaryExpression shift to state 85
-- On fieldAccess shift to state 86
-- On complexPrimaryNoParenthesis shift to state 87
-- On complexPrimary shift to state 88
-- On classAllocationExpression shift to state 100
-- On castExpression shift to state 187
-- On arrayAllocationExpression shift to state 104
-- On arrayAccess shift to state 120
-- On arithmeticUnaryOperator shift to state 121

State 187:
castExpression -> LPAR primitiveTypeExpression RPAR castExpression . [ XOREQUAL XOR SEMI RSHIFTEQUAL RSHIFT RPAR RCURL RBRAC QM PLUS PEQUAL OREQUAL OR NEQUAL MULEQUAL MUL MODEQUAL MOD MINUSEQUAL MINUS LTHAN LSHIFTEQUAL LSHIFT LOGSHIFTEQUAL LOGSHIFT LETHAN INSTANCEOF GTHAN GETHAN EQUAL DIVEQUAL DIV COMM COL BOR BAND ASSIGN ANDEQUAL AND ]
-- On XOREQUAL reduce production castExpression -> LPAR primitiveTypeExpression RPAR castExpression 
-- On XOR reduce production castExpression -> LPAR primitiveTypeExpression RPAR castExpression 
-- On SEMI reduce production castExpression -> LPAR primitiveTypeExpression RPAR castExpression 
-- On RSHIFTEQUAL reduce production castExpression -> LPAR primitiveTypeExpression RPAR castExpression 
-- On RSHIFT reduce production castExpression -> LPAR primitiveTypeExpression RPAR castExpression 
-- On RPAR reduce production castExpression -> LPAR primitiveTypeExpression RPAR castExpression 
-- On RCURL reduce production castExpression -> LPAR primitiveTypeExpression RPAR castExpression 
-- On RBRAC reduce production castExpression -> LPAR primitiveTypeExpression RPAR castExpression 
-- On QM reduce production castExpression -> LPAR primitiveTypeExpression RPAR castExpression 
-- On PLUS reduce production castExpression -> LPAR primitiveTypeExpression RPAR castExpression 
-- On PEQUAL reduce production castExpression -> LPAR primitiveTypeExpression RPAR castExpression 
-- On OREQUAL reduce production castExpression -> LPAR primitiveTypeExpression RPAR castExpression 
-- On OR reduce production castExpression -> LPAR primitiveTypeExpression RPAR castExpression 
-- On NEQUAL reduce production castExpression -> LPAR primitiveTypeExpression RPAR castExpression 
-- On MULEQUAL reduce production castExpression -> LPAR primitiveTypeExpression RPAR castExpression 
-- On MUL reduce production castExpression -> LPAR primitiveTypeExpression RPAR castExpression 
-- On MODEQUAL reduce production castExpression -> LPAR primitiveTypeExpression RPAR castExpression 
-- On MOD reduce production castExpression -> LPAR primitiveTypeExpression RPAR castExpression 
-- On MINUSEQUAL reduce production castExpression -> LPAR primitiveTypeExpression RPAR castExpression 
-- On MINUS reduce production castExpression -> LPAR primitiveTypeExpression RPAR castExpression 
-- On LTHAN reduce production castExpression -> LPAR primitiveTypeExpression RPAR castExpression 
-- On LSHIFTEQUAL reduce production castExpression -> LPAR primitiveTypeExpression RPAR castExpression 
-- On LSHIFT reduce production castExpression -> LPAR primitiveTypeExpression RPAR castExpression 
-- On LOGSHIFTEQUAL reduce production castExpression -> LPAR primitiveTypeExpression RPAR castExpression 
-- On LOGSHIFT reduce production castExpression -> LPAR primitiveTypeExpression RPAR castExpression 
-- On LETHAN reduce production castExpression -> LPAR primitiveTypeExpression RPAR castExpression 
-- On INSTANCEOF reduce production castExpression -> LPAR primitiveTypeExpression RPAR castExpression 
-- On GTHAN reduce production castExpression -> LPAR primitiveTypeExpression RPAR castExpression 
-- On GETHAN reduce production castExpression -> LPAR primitiveTypeExpression RPAR castExpression 
-- On EQUAL reduce production castExpression -> LPAR primitiveTypeExpression RPAR castExpression 
-- On DIVEQUAL reduce production castExpression -> LPAR primitiveTypeExpression RPAR castExpression 
-- On DIV reduce production castExpression -> LPAR primitiveTypeExpression RPAR castExpression 
-- On COMM reduce production castExpression -> LPAR primitiveTypeExpression RPAR castExpression 
-- On COL reduce production castExpression -> LPAR primitiveTypeExpression RPAR castExpression 
-- On BOR reduce production castExpression -> LPAR primitiveTypeExpression RPAR castExpression 
-- On BAND reduce production castExpression -> LPAR primitiveTypeExpression RPAR castExpression 
-- On ASSIGN reduce production castExpression -> LPAR primitiveTypeExpression RPAR castExpression 
-- On ANDEQUAL reduce production castExpression -> LPAR primitiveTypeExpression RPAR castExpression 
-- On AND reduce production castExpression -> LPAR primitiveTypeExpression RPAR castExpression 

State 188:
fieldAccess -> primitiveType . DOT CLASS [ XOREQUAL XOR RSHIFTEQUAL RSHIFT RPAR QM PLUS PEQUAL OREQUAL OR NEQUAL MULEQUAL MUL MODEQUAL MOD MINUSEQUAL MINUS LTHAN LSHIFTEQUAL LSHIFT LPAR LOGSHIFTEQUAL LOGSHIFT LETHAN LBRAC INSTANCEOF INCREMENT GTHAN GETHAN EQUAL DOT DIVEQUAL DIV DECREMENT BOR BAND ASSIGN ANDEQUAL AND ]
primitiveTypeExpression -> primitiveType . [ RPAR ]
primitiveTypeExpression -> primitiveType . dims [ RPAR ]
-- On DOT shift to state 62
-- On DIM shift to state 131
-- On dims shift to state 189
-- On RPAR reduce production primitiveTypeExpression -> primitiveType 

State 189:
dims -> dims . DIM [ RPAR DIM ]
primitiveTypeExpression -> primitiveType dims . [ RPAR ]
-- On DIM shift to state 133
-- On RPAR reduce production primitiveTypeExpression -> primitiveType dims 

State 190:
castExpression -> LPAR expression . RPAR logicalUnaryExpression [ XOREQUAL XOR SEMI RSHIFTEQUAL RSHIFT RPAR RCURL RBRAC QM PLUS PEQUAL OREQUAL OR NEQUAL MULEQUAL MUL MODEQUAL MOD MINUSEQUAL MINUS LTHAN LSHIFTEQUAL LSHIFT LOGSHIFTEQUAL LOGSHIFT LETHAN INSTANCEOF GTHAN GETHAN EQUAL DIVEQUAL DIV COMM COL BOR BAND ASSIGN ANDEQUAL AND ]
complexPrimary -> LPAR expression . RPAR [ XOREQUAL XOR SEMI RSHIFTEQUAL RSHIFT RPAR RCURL RBRAC QM PLUS PEQUAL OREQUAL OR NEQUAL MULEQUAL MUL MODEQUAL MOD MINUSEQUAL MINUS LTHAN LSHIFTEQUAL LSHIFT LOGSHIFTEQUAL LOGSHIFT LETHAN LBRAC INSTANCEOF INCREMENT GTHAN GETHAN EQUAL DOT DIVEQUAL DIV DECREMENT COMM COL BOR BAND ASSIGN ANDEQUAL AND ]
-- On RPAR shift to state 191

State 191:
castExpression -> LPAR expression RPAR . logicalUnaryExpression [ XOREQUAL XOR SEMI RSHIFTEQUAL RSHIFT RPAR RCURL RBRAC QM PLUS PEQUAL OREQUAL OR NEQUAL MULEQUAL MUL MODEQUAL MOD MINUSEQUAL MINUS LTHAN LSHIFTEQUAL LSHIFT LOGSHIFTEQUAL LOGSHIFT LETHAN INSTANCEOF GTHAN GETHAN EQUAL DIVEQUAL DIV COMM COL BOR BAND ASSIGN ANDEQUAL AND ]
complexPrimary -> LPAR expression RPAR . [ XOREQUAL XOR SEMI RSHIFTEQUAL RSHIFT RPAR RCURL RBRAC QM PLUS PEQUAL OREQUAL OR NEQUAL MULEQUAL MUL MODEQUAL MOD MINUSEQUAL MINUS LTHAN LSHIFTEQUAL LSHIFT LOGSHIFTEQUAL LOGSHIFT LETHAN LBRAC INSTANCEOF INCREMENT GTHAN GETHAN EQUAL DOT DIVEQUAL DIV DECREMENT COMM COL BOR BAND ASSIGN ANDEQUAL AND ]
-- On VOID shift to state 6
-- On THIS shift to state 7
-- On SUPER shift to state 8
-- On STRLIT shift to state 9
-- On SHORT shift to state 10
-- On NULLLIT shift to state 12
-- On NOT shift to state 13
-- On NEW shift to state 14
-- On LPAR shift to state 30
-- On LONG shift to state 15
-- On INTLIT shift to state 28
-- On INT shift to state 16
-- On IDENTIFIER shift to state 17
-- On FLOATLIT shift to state 31
-- On FLOAT shift to state 18
-- On DOUBLELIT shift to state 32
-- On DOUBLE shift to state 19
-- On CHARLIT shift to state 34
-- On CHAR shift to state 20
-- On BYTE shift to state 21
-- On BOOLEANLIT shift to state 35
-- On BOOLEAN shift to state 22
-- On BNOT shift to state 36
-- On specialName shift to state 38
-- On realPostfixExpression shift to state 39
-- On qualifiedName shift to state 42
-- On primitiveType shift to state 61
-- On primaryExpression shift to state 64
-- On postfixExpression shift to state 65
-- On plainNewAllocationExpression shift to state 68
-- On notJustName shift to state 69
-- On newAllocationExpression shift to state 72
-- On methodCall shift to state 75
-- On methodAccess shift to state 76
-- On logicalUnaryOperator shift to state 83
-- On logicalUnaryExpression shift to state 192
-- On fieldAccess shift to state 86
-- On complexPrimaryNoParenthesis shift to state 87
-- On complexPrimary shift to state 88
-- On classAllocationExpression shift to state 100
-- On arrayAllocationExpression shift to state 104
-- On arrayAccess shift to state 120
-- On XOREQUAL reduce production complexPrimary -> LPAR expression RPAR 
-- On XOR reduce production complexPrimary -> LPAR expression RPAR 
-- On SEMI reduce production complexPrimary -> LPAR expression RPAR 
-- On RSHIFTEQUAL reduce production complexPrimary -> LPAR expression RPAR 
-- On RSHIFT reduce production complexPrimary -> LPAR expression RPAR 
-- On RPAR reduce production complexPrimary -> LPAR expression RPAR 
-- On RCURL reduce production complexPrimary -> LPAR expression RPAR 
-- On RBRAC reduce production complexPrimary -> LPAR expression RPAR 
-- On QM reduce production complexPrimary -> LPAR expression RPAR 
-- On PLUS reduce production complexPrimary -> LPAR expression RPAR 
-- On PEQUAL reduce production complexPrimary -> LPAR expression RPAR 
-- On OREQUAL reduce production complexPrimary -> LPAR expression RPAR 
-- On OR reduce production complexPrimary -> LPAR expression RPAR 
-- On NEQUAL reduce production complexPrimary -> LPAR expression RPAR 
-- On MULEQUAL reduce production complexPrimary -> LPAR expression RPAR 
-- On MUL reduce production complexPrimary -> LPAR expression RPAR 
-- On MODEQUAL reduce production complexPrimary -> LPAR expression RPAR 
-- On MOD reduce production complexPrimary -> LPAR expression RPAR 
-- On MINUSEQUAL reduce production complexPrimary -> LPAR expression RPAR 
-- On MINUS reduce production complexPrimary -> LPAR expression RPAR 
-- On LTHAN reduce production complexPrimary -> LPAR expression RPAR 
-- On LSHIFTEQUAL reduce production complexPrimary -> LPAR expression RPAR 
-- On LSHIFT reduce production complexPrimary -> LPAR expression RPAR 
-- On LOGSHIFTEQUAL reduce production complexPrimary -> LPAR expression RPAR 
-- On LOGSHIFT reduce production complexPrimary -> LPAR expression RPAR 
-- On LETHAN reduce production complexPrimary -> LPAR expression RPAR 
-- On LBRAC reduce production complexPrimary -> LPAR expression RPAR 
-- On INSTANCEOF reduce production complexPrimary -> LPAR expression RPAR 
-- On INCREMENT reduce production complexPrimary -> LPAR expression RPAR 
-- On GTHAN reduce production complexPrimary -> LPAR expression RPAR 
-- On GETHAN reduce production complexPrimary -> LPAR expression RPAR 
-- On EQUAL reduce production complexPrimary -> LPAR expression RPAR 
-- On DOT reduce production complexPrimary -> LPAR expression RPAR 
-- On DIVEQUAL reduce production complexPrimary -> LPAR expression RPAR 
-- On DIV reduce production complexPrimary -> LPAR expression RPAR 
-- On DECREMENT reduce production complexPrimary -> LPAR expression RPAR 
-- On COMM reduce production complexPrimary -> LPAR expression RPAR 
-- On COL reduce production complexPrimary -> LPAR expression RPAR 
-- On BOR reduce production complexPrimary -> LPAR expression RPAR 
-- On BAND reduce production complexPrimary -> LPAR expression RPAR 
-- On ASSIGN reduce production complexPrimary -> LPAR expression RPAR 
-- On ANDEQUAL reduce production complexPrimary -> LPAR expression RPAR 
-- On AND reduce production complexPrimary -> LPAR expression RPAR 

State 192:
castExpression -> LPAR expression RPAR logicalUnaryExpression . [ XOREQUAL XOR SEMI RSHIFTEQUAL RSHIFT RPAR RCURL RBRAC QM PLUS PEQUAL OREQUAL OR NEQUAL MULEQUAL MUL MODEQUAL MOD MINUSEQUAL MINUS LTHAN LSHIFTEQUAL LSHIFT LOGSHIFTEQUAL LOGSHIFT LETHAN INSTANCEOF GTHAN GETHAN EQUAL DIVEQUAL DIV COMM COL BOR BAND ASSIGN ANDEQUAL AND ]
-- On XOREQUAL reduce production castExpression -> LPAR expression RPAR logicalUnaryExpression 
-- On XOR reduce production castExpression -> LPAR expression RPAR logicalUnaryExpression 
-- On SEMI reduce production castExpression -> LPAR expression RPAR logicalUnaryExpression 
-- On RSHIFTEQUAL reduce production castExpression -> LPAR expression RPAR logicalUnaryExpression 
-- On RSHIFT reduce production castExpression -> LPAR expression RPAR logicalUnaryExpression 
-- On RPAR reduce production castExpression -> LPAR expression RPAR logicalUnaryExpression 
-- On RCURL reduce production castExpression -> LPAR expression RPAR logicalUnaryExpression 
-- On RBRAC reduce production castExpression -> LPAR expression RPAR logicalUnaryExpression 
-- On QM reduce production castExpression -> LPAR expression RPAR logicalUnaryExpression 
-- On PLUS reduce production castExpression -> LPAR expression RPAR logicalUnaryExpression 
-- On PEQUAL reduce production castExpression -> LPAR expression RPAR logicalUnaryExpression 
-- On OREQUAL reduce production castExpression -> LPAR expression RPAR logicalUnaryExpression 
-- On OR reduce production castExpression -> LPAR expression RPAR logicalUnaryExpression 
-- On NEQUAL reduce production castExpression -> LPAR expression RPAR logicalUnaryExpression 
-- On MULEQUAL reduce production castExpression -> LPAR expression RPAR logicalUnaryExpression 
-- On MUL reduce production castExpression -> LPAR expression RPAR logicalUnaryExpression 
-- On MODEQUAL reduce production castExpression -> LPAR expression RPAR logicalUnaryExpression 
-- On MOD reduce production castExpression -> LPAR expression RPAR logicalUnaryExpression 
-- On MINUSEQUAL reduce production castExpression -> LPAR expression RPAR logicalUnaryExpression 
-- On MINUS reduce production castExpression -> LPAR expression RPAR logicalUnaryExpression 
-- On LTHAN reduce production castExpression -> LPAR expression RPAR logicalUnaryExpression 
-- On LSHIFTEQUAL reduce production castExpression -> LPAR expression RPAR logicalUnaryExpression 
-- On LSHIFT reduce production castExpression -> LPAR expression RPAR logicalUnaryExpression 
-- On LOGSHIFTEQUAL reduce production castExpression -> LPAR expression RPAR logicalUnaryExpression 
-- On LOGSHIFT reduce production castExpression -> LPAR expression RPAR logicalUnaryExpression 
-- On LETHAN reduce production castExpression -> LPAR expression RPAR logicalUnaryExpression 
-- On INSTANCEOF reduce production castExpression -> LPAR expression RPAR logicalUnaryExpression 
-- On GTHAN reduce production castExpression -> LPAR expression RPAR logicalUnaryExpression 
-- On GETHAN reduce production castExpression -> LPAR expression RPAR logicalUnaryExpression 
-- On EQUAL reduce production castExpression -> LPAR expression RPAR logicalUnaryExpression 
-- On DIVEQUAL reduce production castExpression -> LPAR expression RPAR logicalUnaryExpression 
-- On DIV reduce production castExpression -> LPAR expression RPAR logicalUnaryExpression 
-- On COMM reduce production castExpression -> LPAR expression RPAR logicalUnaryExpression 
-- On COL reduce production castExpression -> LPAR expression RPAR logicalUnaryExpression 
-- On BOR reduce production castExpression -> LPAR expression RPAR logicalUnaryExpression 
-- On BAND reduce production castExpression -> LPAR expression RPAR logicalUnaryExpression 
-- On ASSIGN reduce production castExpression -> LPAR expression RPAR logicalUnaryExpression 
-- On ANDEQUAL reduce production castExpression -> LPAR expression RPAR logicalUnaryExpression 
-- On AND reduce production castExpression -> LPAR expression RPAR logicalUnaryExpression 

State 193:
castExpression -> LPAR classTypeExpression . RPAR castExpression [ XOREQUAL XOR SEMI RSHIFTEQUAL RSHIFT RPAR RCURL RBRAC QM PLUS PEQUAL OREQUAL OR NEQUAL MULEQUAL MUL MODEQUAL MOD MINUSEQUAL MINUS LTHAN LSHIFTEQUAL LSHIFT LOGSHIFTEQUAL LOGSHIFT LETHAN INSTANCEOF GTHAN GETHAN EQUAL DIVEQUAL DIV COMM COL BOR BAND ASSIGN ANDEQUAL AND ]
-- On RPAR shift to state 194

State 194:
castExpression -> LPAR classTypeExpression RPAR . castExpression [ XOREQUAL XOR SEMI RSHIFTEQUAL RSHIFT RPAR RCURL RBRAC QM PLUS PEQUAL OREQUAL OR NEQUAL MULEQUAL MUL MODEQUAL MOD MINUSEQUAL MINUS LTHAN LSHIFTEQUAL LSHIFT LOGSHIFTEQUAL LOGSHIFT LETHAN INSTANCEOF GTHAN GETHAN EQUAL DIVEQUAL DIV COMM COL BOR BAND ASSIGN ANDEQUAL AND ]
-- On VOID shift to state 6
-- On THIS shift to state 7
-- On SUPER shift to state 8
-- On STRLIT shift to state 9
-- On SHORT shift to state 10
-- On PLUS shift to state 11
-- On NULLLIT shift to state 12
-- On NOT shift to state 13
-- On NEW shift to state 14
-- On MINUS shift to state 26
-- On LPAR shift to state 27
-- On LONG shift to state 15
-- On INTLIT shift to state 28
-- On INT shift to state 16
-- On INCREMENT shift to state 29
-- On IDENTIFIER shift to state 17
-- On FLOATLIT shift to state 31
-- On FLOAT shift to state 18
-- On DOUBLELIT shift to state 32
-- On DOUBLE shift to state 19
-- On DECREMENT shift to state 33
-- On CHARLIT shift to state 34
-- On CHAR shift to state 20
-- On BYTE shift to state 21
-- On BOOLEANLIT shift to state 35
-- On BOOLEAN shift to state 22
-- On BNOT shift to state 36
-- On unaryExpression shift to state 60
-- On specialName shift to state 38
-- On realPostfixExpression shift to state 39
-- On qualifiedName shift to state 42
-- On primitiveType shift to state 61
-- On primaryExpression shift to state 64
-- On postfixExpression shift to state 65
-- On plainNewAllocationExpression shift to state 68
-- On notJustName shift to state 69
-- On newAllocationExpression shift to state 72
-- On methodCall shift to state 75
-- On methodAccess shift to state 76
-- On logicalUnaryOperator shift to state 83
-- On logicalUnaryExpression shift to state 85
-- On fieldAccess shift to state 86
-- On complexPrimaryNoParenthesis shift to state 87
-- On complexPrimary shift to state 88
-- On classAllocationExpression shift to state 100
-- On castExpression shift to state 195
-- On arrayAllocationExpression shift to state 104
-- On arrayAccess shift to state 120
-- On arithmeticUnaryOperator shift to state 121

State 195:
castExpression -> LPAR classTypeExpression RPAR castExpression . [ XOREQUAL XOR SEMI RSHIFTEQUAL RSHIFT RPAR RCURL RBRAC QM PLUS PEQUAL OREQUAL OR NEQUAL MULEQUAL MUL MODEQUAL MOD MINUSEQUAL MINUS LTHAN LSHIFTEQUAL LSHIFT LOGSHIFTEQUAL LOGSHIFT LETHAN INSTANCEOF GTHAN GETHAN EQUAL DIVEQUAL DIV COMM COL BOR BAND ASSIGN ANDEQUAL AND ]
-- On XOREQUAL reduce production castExpression -> LPAR classTypeExpression RPAR castExpression 
-- On XOR reduce production castExpression -> LPAR classTypeExpression RPAR castExpression 
-- On SEMI reduce production castExpression -> LPAR classTypeExpression RPAR castExpression 
-- On RSHIFTEQUAL reduce production castExpression -> LPAR classTypeExpression RPAR castExpression 
-- On RSHIFT reduce production castExpression -> LPAR classTypeExpression RPAR castExpression 
-- On RPAR reduce production castExpression -> LPAR classTypeExpression RPAR castExpression 
-- On RCURL reduce production castExpression -> LPAR classTypeExpression RPAR castExpression 
-- On RBRAC reduce production castExpression -> LPAR classTypeExpression RPAR castExpression 
-- On QM reduce production castExpression -> LPAR classTypeExpression RPAR castExpression 
-- On PLUS reduce production castExpression -> LPAR classTypeExpression RPAR castExpression 
-- On PEQUAL reduce production castExpression -> LPAR classTypeExpression RPAR castExpression 
-- On OREQUAL reduce production castExpression -> LPAR classTypeExpression RPAR castExpression 
-- On OR reduce production castExpression -> LPAR classTypeExpression RPAR castExpression 
-- On NEQUAL reduce production castExpression -> LPAR classTypeExpression RPAR castExpression 
-- On MULEQUAL reduce production castExpression -> LPAR classTypeExpression RPAR castExpression 
-- On MUL reduce production castExpression -> LPAR classTypeExpression RPAR castExpression 
-- On MODEQUAL reduce production castExpression -> LPAR classTypeExpression RPAR castExpression 
-- On MOD reduce production castExpression -> LPAR classTypeExpression RPAR castExpression 
-- On MINUSEQUAL reduce production castExpression -> LPAR classTypeExpression RPAR castExpression 
-- On MINUS reduce production castExpression -> LPAR classTypeExpression RPAR castExpression 
-- On LTHAN reduce production castExpression -> LPAR classTypeExpression RPAR castExpression 
-- On LSHIFTEQUAL reduce production castExpression -> LPAR classTypeExpression RPAR castExpression 
-- On LSHIFT reduce production castExpression -> LPAR classTypeExpression RPAR castExpression 
-- On LOGSHIFTEQUAL reduce production castExpression -> LPAR classTypeExpression RPAR castExpression 
-- On LOGSHIFT reduce production castExpression -> LPAR classTypeExpression RPAR castExpression 
-- On LETHAN reduce production castExpression -> LPAR classTypeExpression RPAR castExpression 
-- On INSTANCEOF reduce production castExpression -> LPAR classTypeExpression RPAR castExpression 
-- On GTHAN reduce production castExpression -> LPAR classTypeExpression RPAR castExpression 
-- On GETHAN reduce production castExpression -> LPAR classTypeExpression RPAR castExpression 
-- On EQUAL reduce production castExpression -> LPAR classTypeExpression RPAR castExpression 
-- On DIVEQUAL reduce production castExpression -> LPAR classTypeExpression RPAR castExpression 
-- On DIV reduce production castExpression -> LPAR classTypeExpression RPAR castExpression 
-- On COMM reduce production castExpression -> LPAR classTypeExpression RPAR castExpression 
-- On COL reduce production castExpression -> LPAR classTypeExpression RPAR castExpression 
-- On BOR reduce production castExpression -> LPAR classTypeExpression RPAR castExpression 
-- On BAND reduce production castExpression -> LPAR classTypeExpression RPAR castExpression 
-- On ASSIGN reduce production castExpression -> LPAR classTypeExpression RPAR castExpression 
-- On ANDEQUAL reduce production castExpression -> LPAR classTypeExpression RPAR castExpression 
-- On AND reduce production castExpression -> LPAR classTypeExpression RPAR castExpression 

State 196:
argumentList -> argumentList . COMM expression [ RPAR COMM ]
classAllocationExpression -> NEW typeName LPAR argumentList . RPAR [ XOREQUAL XOR SEMI RSHIFTEQUAL RSHIFT RPAR RCURL RBRAC QM PLUS PEQUAL OREQUAL OR NEQUAL MULEQUAL MUL MODEQUAL MOD MINUSEQUAL MINUS LTHAN LSHIFTEQUAL LSHIFT LOGSHIFTEQUAL LOGSHIFT LETHAN LCURL INSTANCEOF INCREMENT GTHAN GETHAN EQUAL DOT DIVEQUAL DIV DECREMENT COMM COL BOR BAND ASSIGN ANDEQUAL AND ]
-- On RPAR shift to state 197
-- On COMM shift to state 169

State 197:
classAllocationExpression -> NEW typeName LPAR argumentList RPAR . [ XOREQUAL XOR SEMI RSHIFTEQUAL RSHIFT RPAR RCURL RBRAC QM PLUS PEQUAL OREQUAL OR NEQUAL MULEQUAL MUL MODEQUAL MOD MINUSEQUAL MINUS LTHAN LSHIFTEQUAL LSHIFT LOGSHIFTEQUAL LOGSHIFT LETHAN LCURL INSTANCEOF INCREMENT GTHAN GETHAN EQUAL DOT DIVEQUAL DIV DECREMENT COMM COL BOR BAND ASSIGN ANDEQUAL AND ]
-- On XOREQUAL reduce production classAllocationExpression -> NEW typeName LPAR argumentList RPAR 
-- On XOR reduce production classAllocationExpression -> NEW typeName LPAR argumentList RPAR 
-- On SEMI reduce production classAllocationExpression -> NEW typeName LPAR argumentList RPAR 
-- On RSHIFTEQUAL reduce production classAllocationExpression -> NEW typeName LPAR argumentList RPAR 
-- On RSHIFT reduce production classAllocationExpression -> NEW typeName LPAR argumentList RPAR 
-- On RPAR reduce production classAllocationExpression -> NEW typeName LPAR argumentList RPAR 
-- On RCURL reduce production classAllocationExpression -> NEW typeName LPAR argumentList RPAR 
-- On RBRAC reduce production classAllocationExpression -> NEW typeName LPAR argumentList RPAR 
-- On QM reduce production classAllocationExpression -> NEW typeName LPAR argumentList RPAR 
-- On PLUS reduce production classAllocationExpression -> NEW typeName LPAR argumentList RPAR 
-- On PEQUAL reduce production classAllocationExpression -> NEW typeName LPAR argumentList RPAR 
-- On OREQUAL reduce production classAllocationExpression -> NEW typeName LPAR argumentList RPAR 
-- On OR reduce production classAllocationExpression -> NEW typeName LPAR argumentList RPAR 
-- On NEQUAL reduce production classAllocationExpression -> NEW typeName LPAR argumentList RPAR 
-- On MULEQUAL reduce production classAllocationExpression -> NEW typeName LPAR argumentList RPAR 
-- On MUL reduce production classAllocationExpression -> NEW typeName LPAR argumentList RPAR 
-- On MODEQUAL reduce production classAllocationExpression -> NEW typeName LPAR argumentList RPAR 
-- On MOD reduce production classAllocationExpression -> NEW typeName LPAR argumentList RPAR 
-- On MINUSEQUAL reduce production classAllocationExpression -> NEW typeName LPAR argumentList RPAR 
-- On MINUS reduce production classAllocationExpression -> NEW typeName LPAR argumentList RPAR 
-- On LTHAN reduce production classAllocationExpression -> NEW typeName LPAR argumentList RPAR 
-- On LSHIFTEQUAL reduce production classAllocationExpression -> NEW typeName LPAR argumentList RPAR 
-- On LSHIFT reduce production classAllocationExpression -> NEW typeName LPAR argumentList RPAR 
-- On LOGSHIFTEQUAL reduce production classAllocationExpression -> NEW typeName LPAR argumentList RPAR 
-- On LOGSHIFT reduce production classAllocationExpression -> NEW typeName LPAR argumentList RPAR 
-- On LETHAN reduce production classAllocationExpression -> NEW typeName LPAR argumentList RPAR 
-- On LCURL reduce production classAllocationExpression -> NEW typeName LPAR argumentList RPAR 
-- On INSTANCEOF reduce production classAllocationExpression -> NEW typeName LPAR argumentList RPAR 
-- On INCREMENT reduce production classAllocationExpression -> NEW typeName LPAR argumentList RPAR 
-- On GTHAN reduce production classAllocationExpression -> NEW typeName LPAR argumentList RPAR 
-- On GETHAN reduce production classAllocationExpression -> NEW typeName LPAR argumentList RPAR 
-- On EQUAL reduce production classAllocationExpression -> NEW typeName LPAR argumentList RPAR 
-- On DOT reduce production classAllocationExpression -> NEW typeName LPAR argumentList RPAR 
-- On DIVEQUAL reduce production classAllocationExpression -> NEW typeName LPAR argumentList RPAR 
-- On DIV reduce production classAllocationExpression -> NEW typeName LPAR argumentList RPAR 
-- On DECREMENT reduce production classAllocationExpression -> NEW typeName LPAR argumentList RPAR 
-- On COMM reduce production classAllocationExpression -> NEW typeName LPAR argumentList RPAR 
-- On COL reduce production classAllocationExpression -> NEW typeName LPAR argumentList RPAR 
-- On BOR reduce production classAllocationExpression -> NEW typeName LPAR argumentList RPAR 
-- On BAND reduce production classAllocationExpression -> NEW typeName LPAR argumentList RPAR 
-- On ASSIGN reduce production classAllocationExpression -> NEW typeName LPAR argumentList RPAR 
-- On ANDEQUAL reduce production classAllocationExpression -> NEW typeName LPAR argumentList RPAR 
-- On AND reduce production classAllocationExpression -> NEW typeName LPAR argumentList RPAR 

State 198:
dimExpr -> LBRAC . expression RBRAC [ XOREQUAL XOR SEMI RSHIFTEQUAL RSHIFT RPAR RCURL RBRAC QM PLUS PEQUAL OREQUAL OR NEQUAL MULEQUAL MUL MODEQUAL MOD MINUSEQUAL MINUS LTHAN LSHIFTEQUAL LSHIFT LOGSHIFTEQUAL LOGSHIFT LETHAN LCURL LBRAC INSTANCEOF INCREMENT GTHAN GETHAN EQUAL DOT DIVEQUAL DIV DIM DECREMENT COMM COL BOR BAND ASSIGN ANDEQUAL AND ]
-- On error shift to state 3
-- On VOID shift to state 6
-- On THIS shift to state 7
-- On SUPER shift to state 8
-- On STRLIT shift to state 9
-- On SHORT shift to state 10
-- On PLUS shift to state 11
-- On NULLLIT shift to state 12
-- On NOT shift to state 13
-- On NEW shift to state 14
-- On MINUS shift to state 26
-- On LPAR shift to state 27
-- On LONG shift to state 15
-- On INTLIT shift to state 28
-- On INT shift to state 16
-- On INCREMENT shift to state 29
-- On IDENTIFIER shift to state 17
-- On FLOATLIT shift to state 31
-- On FLOAT shift to state 18
-- On DOUBLELIT shift to state 32
-- On DOUBLE shift to state 19
-- On DECREMENT shift to state 33
-- On CHARLIT shift to state 34
-- On CHAR shift to state 20
-- On BYTE shift to state 21
-- On BOOLEANLIT shift to state 35
-- On BOOLEAN shift to state 22
-- On BNOT shift to state 36
-- On unaryExpression shift to state 44
-- On specialName shift to state 38
-- On shiftExpression shift to state 58
-- On relationalExpression shift to state 79
-- On realPostfixExpression shift to state 39
-- On qualifiedName shift to state 42
-- On primitiveType shift to state 61
-- On primaryExpression shift to state 64
-- On postfixExpression shift to state 65
-- On plainNewAllocationExpression shift to state 68
-- On notJustName shift to state 69
-- On newAllocationExpression shift to state 72
-- On multiplicativeExpression shift to state 73
-- On methodCall shift to state 75
-- On methodAccess shift to state 76
-- On logicalUnaryOperator shift to state 83
-- On logicalUnaryExpression shift to state 85
-- On inclusiveOrExpression shift to state 90
-- On fieldAccess shift to state 86
-- On expression shift to state 199
-- On exclusiveOrExpression shift to state 111
-- On equalityExpression shift to state 94
-- On conditionalOrExpression shift to state 112
-- On conditionalExpression shift to state 151
-- On conditionalAndExpression shift to state 117
-- On complexPrimaryNoParenthesis shift to state 87
-- On complexPrimary shift to state 88
-- On classAllocationExpression shift to state 100
-- On castExpression shift to state 103
-- On assignmentExpression shift to state 152
-- On arrayAllocationExpression shift to state 104
-- On arrayAccess shift to state 120
-- On arithmeticUnaryOperator shift to state 121
-- On andExpression shift to state 123
-- On additiveExpression shift to state 140

State 199:
dimExpr -> LBRAC expression . RBRAC [ XOREQUAL XOR SEMI RSHIFTEQUAL RSHIFT RPAR RCURL RBRAC QM PLUS PEQUAL OREQUAL OR NEQUAL MULEQUAL MUL MODEQUAL MOD MINUSEQUAL MINUS LTHAN LSHIFTEQUAL LSHIFT LOGSHIFTEQUAL LOGSHIFT LETHAN LCURL LBRAC INSTANCEOF INCREMENT GTHAN GETHAN EQUAL DOT DIVEQUAL DIV DIM DECREMENT COMM COL BOR BAND ASSIGN ANDEQUAL AND ]
-- On RBRAC shift to state 200

State 200:
dimExpr -> LBRAC expression RBRAC . [ XOREQUAL XOR SEMI RSHIFTEQUAL RSHIFT RPAR RCURL RBRAC QM PLUS PEQUAL OREQUAL OR NEQUAL MULEQUAL MUL MODEQUAL MOD MINUSEQUAL MINUS LTHAN LSHIFTEQUAL LSHIFT LOGSHIFTEQUAL LOGSHIFT LETHAN LCURL LBRAC INSTANCEOF INCREMENT GTHAN GETHAN EQUAL DOT DIVEQUAL DIV DIM DECREMENT COMM COL BOR BAND ASSIGN ANDEQUAL AND ]
-- On XOREQUAL reduce production dimExpr -> LBRAC expression RBRAC 
-- On XOR reduce production dimExpr -> LBRAC expression RBRAC 
-- On SEMI reduce production dimExpr -> LBRAC expression RBRAC 
-- On RSHIFTEQUAL reduce production dimExpr -> LBRAC expression RBRAC 
-- On RSHIFT reduce production dimExpr -> LBRAC expression RBRAC 
-- On RPAR reduce production dimExpr -> LBRAC expression RBRAC 
-- On RCURL reduce production dimExpr -> LBRAC expression RBRAC 
-- On RBRAC reduce production dimExpr -> LBRAC expression RBRAC 
-- On QM reduce production dimExpr -> LBRAC expression RBRAC 
-- On PLUS reduce production dimExpr -> LBRAC expression RBRAC 
-- On PEQUAL reduce production dimExpr -> LBRAC expression RBRAC 
-- On OREQUAL reduce production dimExpr -> LBRAC expression RBRAC 
-- On OR reduce production dimExpr -> LBRAC expression RBRAC 
-- On NEQUAL reduce production dimExpr -> LBRAC expression RBRAC 
-- On MULEQUAL reduce production dimExpr -> LBRAC expression RBRAC 
-- On MUL reduce production dimExpr -> LBRAC expression RBRAC 
-- On MODEQUAL reduce production dimExpr -> LBRAC expression RBRAC 
-- On MOD reduce production dimExpr -> LBRAC expression RBRAC 
-- On MINUSEQUAL reduce production dimExpr -> LBRAC expression RBRAC 
-- On MINUS reduce production dimExpr -> LBRAC expression RBRAC 
-- On LTHAN reduce production dimExpr -> LBRAC expression RBRAC 
-- On LSHIFTEQUAL reduce production dimExpr -> LBRAC expression RBRAC 
-- On LSHIFT reduce production dimExpr -> LBRAC expression RBRAC 
-- On LOGSHIFTEQUAL reduce production dimExpr -> LBRAC expression RBRAC 
-- On LOGSHIFT reduce production dimExpr -> LBRAC expression RBRAC 
-- On LETHAN reduce production dimExpr -> LBRAC expression RBRAC 
-- On LCURL reduce production dimExpr -> LBRAC expression RBRAC 
-- On LBRAC reduce production dimExpr -> LBRAC expression RBRAC 
-- On INSTANCEOF reduce production dimExpr -> LBRAC expression RBRAC 
-- On INCREMENT reduce production dimExpr -> LBRAC expression RBRAC 
-- On GTHAN reduce production dimExpr -> LBRAC expression RBRAC 
-- On GETHAN reduce production dimExpr -> LBRAC expression RBRAC 
-- On EQUAL reduce production dimExpr -> LBRAC expression RBRAC 
-- On DOT reduce production dimExpr -> LBRAC expression RBRAC 
-- On DIVEQUAL reduce production dimExpr -> LBRAC expression RBRAC 
-- On DIV reduce production dimExpr -> LBRAC expression RBRAC 
-- On DIM reduce production dimExpr -> LBRAC expression RBRAC 
-- On DECREMENT reduce production dimExpr -> LBRAC expression RBRAC 
-- On COMM reduce production dimExpr -> LBRAC expression RBRAC 
-- On COL reduce production dimExpr -> LBRAC expression RBRAC 
-- On BOR reduce production dimExpr -> LBRAC expression RBRAC 
-- On BAND reduce production dimExpr -> LBRAC expression RBRAC 
-- On ASSIGN reduce production dimExpr -> LBRAC expression RBRAC 
-- On ANDEQUAL reduce production dimExpr -> LBRAC expression RBRAC 
-- On AND reduce production dimExpr -> LBRAC expression RBRAC 

State 201:
arrayAllocationExpression -> NEW typeName dims . [ XOREQUAL XOR SEMI RSHIFTEQUAL RSHIFT RPAR RCURL RBRAC QM PLUS PEQUAL OREQUAL OR NEQUAL MULEQUAL MUL MODEQUAL MOD MINUSEQUAL MINUS LTHAN LSHIFTEQUAL LSHIFT LOGSHIFTEQUAL LOGSHIFT LETHAN LCURL INSTANCEOF INCREMENT GTHAN GETHAN EQUAL DOT DIVEQUAL DIV DECREMENT COMM COL BOR BAND ASSIGN ANDEQUAL AND ]
dims -> dims . DIM [ XOREQUAL XOR SEMI RSHIFTEQUAL RSHIFT RPAR RCURL RBRAC QM PLUS PEQUAL OREQUAL OR NEQUAL MULEQUAL MUL MODEQUAL MOD MINUSEQUAL MINUS LTHAN LSHIFTEQUAL LSHIFT LOGSHIFTEQUAL LOGSHIFT LETHAN LCURL INSTANCEOF INCREMENT GTHAN GETHAN EQUAL DOT DIVEQUAL DIV DIM DECREMENT COMM COL BOR BAND ASSIGN ANDEQUAL AND ]
-- On DIM shift to state 133
-- On XOREQUAL reduce production arrayAllocationExpression -> NEW typeName dims 
-- On XOR reduce production arrayAllocationExpression -> NEW typeName dims 
-- On SEMI reduce production arrayAllocationExpression -> NEW typeName dims 
-- On RSHIFTEQUAL reduce production arrayAllocationExpression -> NEW typeName dims 
-- On RSHIFT reduce production arrayAllocationExpression -> NEW typeName dims 
-- On RPAR reduce production arrayAllocationExpression -> NEW typeName dims 
-- On RCURL reduce production arrayAllocationExpression -> NEW typeName dims 
-- On RBRAC reduce production arrayAllocationExpression -> NEW typeName dims 
-- On QM reduce production arrayAllocationExpression -> NEW typeName dims 
-- On PLUS reduce production arrayAllocationExpression -> NEW typeName dims 
-- On PEQUAL reduce production arrayAllocationExpression -> NEW typeName dims 
-- On OREQUAL reduce production arrayAllocationExpression -> NEW typeName dims 
-- On OR reduce production arrayAllocationExpression -> NEW typeName dims 
-- On NEQUAL reduce production arrayAllocationExpression -> NEW typeName dims 
-- On MULEQUAL reduce production arrayAllocationExpression -> NEW typeName dims 
-- On MUL reduce production arrayAllocationExpression -> NEW typeName dims 
-- On MODEQUAL reduce production arrayAllocationExpression -> NEW typeName dims 
-- On MOD reduce production arrayAllocationExpression -> NEW typeName dims 
-- On MINUSEQUAL reduce production arrayAllocationExpression -> NEW typeName dims 
-- On MINUS reduce production arrayAllocationExpression -> NEW typeName dims 
-- On LTHAN reduce production arrayAllocationExpression -> NEW typeName dims 
-- On LSHIFTEQUAL reduce production arrayAllocationExpression -> NEW typeName dims 
-- On LSHIFT reduce production arrayAllocationExpression -> NEW typeName dims 
-- On LOGSHIFTEQUAL reduce production arrayAllocationExpression -> NEW typeName dims 
-- On LOGSHIFT reduce production arrayAllocationExpression -> NEW typeName dims 
-- On LETHAN reduce production arrayAllocationExpression -> NEW typeName dims 
-- On LCURL reduce production arrayAllocationExpression -> NEW typeName dims 
-- On INSTANCEOF reduce production arrayAllocationExpression -> NEW typeName dims 
-- On INCREMENT reduce production arrayAllocationExpression -> NEW typeName dims 
-- On GTHAN reduce production arrayAllocationExpression -> NEW typeName dims 
-- On GETHAN reduce production arrayAllocationExpression -> NEW typeName dims 
-- On EQUAL reduce production arrayAllocationExpression -> NEW typeName dims 
-- On DOT reduce production arrayAllocationExpression -> NEW typeName dims 
-- On DIVEQUAL reduce production arrayAllocationExpression -> NEW typeName dims 
-- On DIV reduce production arrayAllocationExpression -> NEW typeName dims 
-- On DECREMENT reduce production arrayAllocationExpression -> NEW typeName dims 
-- On COMM reduce production arrayAllocationExpression -> NEW typeName dims 
-- On COL reduce production arrayAllocationExpression -> NEW typeName dims 
-- On BOR reduce production arrayAllocationExpression -> NEW typeName dims 
-- On BAND reduce production arrayAllocationExpression -> NEW typeName dims 
-- On ASSIGN reduce production arrayAllocationExpression -> NEW typeName dims 
-- On ANDEQUAL reduce production arrayAllocationExpression -> NEW typeName dims 
-- On AND reduce production arrayAllocationExpression -> NEW typeName dims 

State 202:
arrayAllocationExpression -> NEW typeName dimExprs . dims [ XOREQUAL XOR SEMI RSHIFTEQUAL RSHIFT RPAR RCURL RBRAC QM PLUS PEQUAL OREQUAL OR NEQUAL MULEQUAL MUL MODEQUAL MOD MINUSEQUAL MINUS LTHAN LSHIFTEQUAL LSHIFT LOGSHIFTEQUAL LOGSHIFT LETHAN LCURL INSTANCEOF INCREMENT GTHAN GETHAN EQUAL DOT DIVEQUAL DIV DECREMENT COMM COL BOR BAND ASSIGN ANDEQUAL AND ]
arrayAllocationExpression -> NEW typeName dimExprs . [ XOREQUAL XOR SEMI RSHIFTEQUAL RSHIFT RPAR RCURL RBRAC QM PLUS PEQUAL OREQUAL OR NEQUAL MULEQUAL MUL MODEQUAL MOD MINUSEQUAL MINUS LTHAN LSHIFTEQUAL LSHIFT LOGSHIFTEQUAL LOGSHIFT LETHAN LCURL INSTANCEOF INCREMENT GTHAN GETHAN EQUAL DOT DIVEQUAL DIV DECREMENT COMM COL BOR BAND ASSIGN ANDEQUAL AND ]
dimExprs -> dimExprs . dimExpr [ XOREQUAL XOR SEMI RSHIFTEQUAL RSHIFT RPAR RCURL RBRAC QM PLUS PEQUAL OREQUAL OR NEQUAL MULEQUAL MUL MODEQUAL MOD MINUSEQUAL MINUS LTHAN LSHIFTEQUAL LSHIFT LOGSHIFTEQUAL LOGSHIFT LETHAN LCURL LBRAC INSTANCEOF INCREMENT GTHAN GETHAN EQUAL DOT DIVEQUAL DIV DIM DECREMENT COMM COL BOR BAND ASSIGN ANDEQUAL AND ]
-- On LBRAC shift to state 198
-- On DIM shift to state 131
-- On dims shift to state 203
-- On dimExpr shift to state 204
-- On XOREQUAL reduce production arrayAllocationExpression -> NEW typeName dimExprs 
-- On XOR reduce production arrayAllocationExpression -> NEW typeName dimExprs 
-- On SEMI reduce production arrayAllocationExpression -> NEW typeName dimExprs 
-- On RSHIFTEQUAL reduce production arrayAllocationExpression -> NEW typeName dimExprs 
-- On RSHIFT reduce production arrayAllocationExpression -> NEW typeName dimExprs 
-- On RPAR reduce production arrayAllocationExpression -> NEW typeName dimExprs 
-- On RCURL reduce production arrayAllocationExpression -> NEW typeName dimExprs 
-- On RBRAC reduce production arrayAllocationExpression -> NEW typeName dimExprs 
-- On QM reduce production arrayAllocationExpression -> NEW typeName dimExprs 
-- On PLUS reduce production arrayAllocationExpression -> NEW typeName dimExprs 
-- On PEQUAL reduce production arrayAllocationExpression -> NEW typeName dimExprs 
-- On OREQUAL reduce production arrayAllocationExpression -> NEW typeName dimExprs 
-- On OR reduce production arrayAllocationExpression -> NEW typeName dimExprs 
-- On NEQUAL reduce production arrayAllocationExpression -> NEW typeName dimExprs 
-- On MULEQUAL reduce production arrayAllocationExpression -> NEW typeName dimExprs 
-- On MUL reduce production arrayAllocationExpression -> NEW typeName dimExprs 
-- On MODEQUAL reduce production arrayAllocationExpression -> NEW typeName dimExprs 
-- On MOD reduce production arrayAllocationExpression -> NEW typeName dimExprs 
-- On MINUSEQUAL reduce production arrayAllocationExpression -> NEW typeName dimExprs 
-- On MINUS reduce production arrayAllocationExpression -> NEW typeName dimExprs 
-- On LTHAN reduce production arrayAllocationExpression -> NEW typeName dimExprs 
-- On LSHIFTEQUAL reduce production arrayAllocationExpression -> NEW typeName dimExprs 
-- On LSHIFT reduce production arrayAllocationExpression -> NEW typeName dimExprs 
-- On LOGSHIFTEQUAL reduce production arrayAllocationExpression -> NEW typeName dimExprs 
-- On LOGSHIFT reduce production arrayAllocationExpression -> NEW typeName dimExprs 
-- On LETHAN reduce production arrayAllocationExpression -> NEW typeName dimExprs 
-- On LCURL reduce production arrayAllocationExpression -> NEW typeName dimExprs 
-- On INSTANCEOF reduce production arrayAllocationExpression -> NEW typeName dimExprs 
-- On INCREMENT reduce production arrayAllocationExpression -> NEW typeName dimExprs 
-- On GTHAN reduce production arrayAllocationExpression -> NEW typeName dimExprs 
-- On GETHAN reduce production arrayAllocationExpression -> NEW typeName dimExprs 
-- On EQUAL reduce production arrayAllocationExpression -> NEW typeName dimExprs 
-- On DOT reduce production arrayAllocationExpression -> NEW typeName dimExprs 
-- On DIVEQUAL reduce production arrayAllocationExpression -> NEW typeName dimExprs 
-- On DIV reduce production arrayAllocationExpression -> NEW typeName dimExprs 
-- On DECREMENT reduce production arrayAllocationExpression -> NEW typeName dimExprs 
-- On COMM reduce production arrayAllocationExpression -> NEW typeName dimExprs 
-- On COL reduce production arrayAllocationExpression -> NEW typeName dimExprs 
-- On BOR reduce production arrayAllocationExpression -> NEW typeName dimExprs 
-- On BAND reduce production arrayAllocationExpression -> NEW typeName dimExprs 
-- On ASSIGN reduce production arrayAllocationExpression -> NEW typeName dimExprs 
-- On ANDEQUAL reduce production arrayAllocationExpression -> NEW typeName dimExprs 
-- On AND reduce production arrayAllocationExpression -> NEW typeName dimExprs 

State 203:
arrayAllocationExpression -> NEW typeName dimExprs dims . [ XOREQUAL XOR SEMI RSHIFTEQUAL RSHIFT RPAR RCURL RBRAC QM PLUS PEQUAL OREQUAL OR NEQUAL MULEQUAL MUL MODEQUAL MOD MINUSEQUAL MINUS LTHAN LSHIFTEQUAL LSHIFT LOGSHIFTEQUAL LOGSHIFT LETHAN LCURL INSTANCEOF INCREMENT GTHAN GETHAN EQUAL DOT DIVEQUAL DIV DECREMENT COMM COL BOR BAND ASSIGN ANDEQUAL AND ]
dims -> dims . DIM [ XOREQUAL XOR SEMI RSHIFTEQUAL RSHIFT RPAR RCURL RBRAC QM PLUS PEQUAL OREQUAL OR NEQUAL MULEQUAL MUL MODEQUAL MOD MINUSEQUAL MINUS LTHAN LSHIFTEQUAL LSHIFT LOGSHIFTEQUAL LOGSHIFT LETHAN LCURL INSTANCEOF INCREMENT GTHAN GETHAN EQUAL DOT DIVEQUAL DIV DIM DECREMENT COMM COL BOR BAND ASSIGN ANDEQUAL AND ]
-- On DIM shift to state 133
-- On XOREQUAL reduce production arrayAllocationExpression -> NEW typeName dimExprs dims 
-- On XOR reduce production arrayAllocationExpression -> NEW typeName dimExprs dims 
-- On SEMI reduce production arrayAllocationExpression -> NEW typeName dimExprs dims 
-- On RSHIFTEQUAL reduce production arrayAllocationExpression -> NEW typeName dimExprs dims 
-- On RSHIFT reduce production arrayAllocationExpression -> NEW typeName dimExprs dims 
-- On RPAR reduce production arrayAllocationExpression -> NEW typeName dimExprs dims 
-- On RCURL reduce production arrayAllocationExpression -> NEW typeName dimExprs dims 
-- On RBRAC reduce production arrayAllocationExpression -> NEW typeName dimExprs dims 
-- On QM reduce production arrayAllocationExpression -> NEW typeName dimExprs dims 
-- On PLUS reduce production arrayAllocationExpression -> NEW typeName dimExprs dims 
-- On PEQUAL reduce production arrayAllocationExpression -> NEW typeName dimExprs dims 
-- On OREQUAL reduce production arrayAllocationExpression -> NEW typeName dimExprs dims 
-- On OR reduce production arrayAllocationExpression -> NEW typeName dimExprs dims 
-- On NEQUAL reduce production arrayAllocationExpression -> NEW typeName dimExprs dims 
-- On MULEQUAL reduce production arrayAllocationExpression -> NEW typeName dimExprs dims 
-- On MUL reduce production arrayAllocationExpression -> NEW typeName dimExprs dims 
-- On MODEQUAL reduce production arrayAllocationExpression -> NEW typeName dimExprs dims 
-- On MOD reduce production arrayAllocationExpression -> NEW typeName dimExprs dims 
-- On MINUSEQUAL reduce production arrayAllocationExpression -> NEW typeName dimExprs dims 
-- On MINUS reduce production arrayAllocationExpression -> NEW typeName dimExprs dims 
-- On LTHAN reduce production arrayAllocationExpression -> NEW typeName dimExprs dims 
-- On LSHIFTEQUAL reduce production arrayAllocationExpression -> NEW typeName dimExprs dims 
-- On LSHIFT reduce production arrayAllocationExpression -> NEW typeName dimExprs dims 
-- On LOGSHIFTEQUAL reduce production arrayAllocationExpression -> NEW typeName dimExprs dims 
-- On LOGSHIFT reduce production arrayAllocationExpression -> NEW typeName dimExprs dims 
-- On LETHAN reduce production arrayAllocationExpression -> NEW typeName dimExprs dims 
-- On LCURL reduce production arrayAllocationExpression -> NEW typeName dimExprs dims 
-- On INSTANCEOF reduce production arrayAllocationExpression -> NEW typeName dimExprs dims 
-- On INCREMENT reduce production arrayAllocationExpression -> NEW typeName dimExprs dims 
-- On GTHAN reduce production arrayAllocationExpression -> NEW typeName dimExprs dims 
-- On GETHAN reduce production arrayAllocationExpression -> NEW typeName dimExprs dims 
-- On EQUAL reduce production arrayAllocationExpression -> NEW typeName dimExprs dims 
-- On DOT reduce production arrayAllocationExpression -> NEW typeName dimExprs dims 
-- On DIVEQUAL reduce production arrayAllocationExpression -> NEW typeName dimExprs dims 
-- On DIV reduce production arrayAllocationExpression -> NEW typeName dimExprs dims 
-- On DECREMENT reduce production arrayAllocationExpression -> NEW typeName dimExprs dims 
-- On COMM reduce production arrayAllocationExpression -> NEW typeName dimExprs dims 
-- On COL reduce production arrayAllocationExpression -> NEW typeName dimExprs dims 
-- On BOR reduce production arrayAllocationExpression -> NEW typeName dimExprs dims 
-- On BAND reduce production arrayAllocationExpression -> NEW typeName dimExprs dims 
-- On ASSIGN reduce production arrayAllocationExpression -> NEW typeName dimExprs dims 
-- On ANDEQUAL reduce production arrayAllocationExpression -> NEW typeName dimExprs dims 
-- On AND reduce production arrayAllocationExpression -> NEW typeName dimExprs dims 

State 204:
dimExprs -> dimExprs dimExpr . [ XOREQUAL XOR SEMI RSHIFTEQUAL RSHIFT RPAR RCURL RBRAC QM PLUS PEQUAL OREQUAL OR NEQUAL MULEQUAL MUL MODEQUAL MOD MINUSEQUAL MINUS LTHAN LSHIFTEQUAL LSHIFT LOGSHIFTEQUAL LOGSHIFT LETHAN LCURL LBRAC INSTANCEOF INCREMENT GTHAN GETHAN EQUAL DOT DIVEQUAL DIV DIM DECREMENT COMM COL BOR BAND ASSIGN ANDEQUAL AND ]
-- On XOREQUAL reduce production dimExprs -> dimExprs dimExpr 
-- On XOR reduce production dimExprs -> dimExprs dimExpr 
-- On SEMI reduce production dimExprs -> dimExprs dimExpr 
-- On RSHIFTEQUAL reduce production dimExprs -> dimExprs dimExpr 
-- On RSHIFT reduce production dimExprs -> dimExprs dimExpr 
-- On RPAR reduce production dimExprs -> dimExprs dimExpr 
-- On RCURL reduce production dimExprs -> dimExprs dimExpr 
-- On RBRAC reduce production dimExprs -> dimExprs dimExpr 
-- On QM reduce production dimExprs -> dimExprs dimExpr 
-- On PLUS reduce production dimExprs -> dimExprs dimExpr 
-- On PEQUAL reduce production dimExprs -> dimExprs dimExpr 
-- On OREQUAL reduce production dimExprs -> dimExprs dimExpr 
-- On OR reduce production dimExprs -> dimExprs dimExpr 
-- On NEQUAL reduce production dimExprs -> dimExprs dimExpr 
-- On MULEQUAL reduce production dimExprs -> dimExprs dimExpr 
-- On MUL reduce production dimExprs -> dimExprs dimExpr 
-- On MODEQUAL reduce production dimExprs -> dimExprs dimExpr 
-- On MOD reduce production dimExprs -> dimExprs dimExpr 
-- On MINUSEQUAL reduce production dimExprs -> dimExprs dimExpr 
-- On MINUS reduce production dimExprs -> dimExprs dimExpr 
-- On LTHAN reduce production dimExprs -> dimExprs dimExpr 
-- On LSHIFTEQUAL reduce production dimExprs -> dimExprs dimExpr 
-- On LSHIFT reduce production dimExprs -> dimExprs dimExpr 
-- On LOGSHIFTEQUAL reduce production dimExprs -> dimExprs dimExpr 
-- On LOGSHIFT reduce production dimExprs -> dimExprs dimExpr 
-- On LETHAN reduce production dimExprs -> dimExprs dimExpr 
-- On LCURL reduce production dimExprs -> dimExprs dimExpr 
-- On LBRAC reduce production dimExprs -> dimExprs dimExpr 
-- On INSTANCEOF reduce production dimExprs -> dimExprs dimExpr 
-- On INCREMENT reduce production dimExprs -> dimExprs dimExpr 
-- On GTHAN reduce production dimExprs -> dimExprs dimExpr 
-- On GETHAN reduce production dimExprs -> dimExprs dimExpr 
-- On EQUAL reduce production dimExprs -> dimExprs dimExpr 
-- On DOT reduce production dimExprs -> dimExprs dimExpr 
-- On DIVEQUAL reduce production dimExprs -> dimExprs dimExpr 
-- On DIV reduce production dimExprs -> dimExprs dimExpr 
-- On DIM reduce production dimExprs -> dimExprs dimExpr 
-- On DECREMENT reduce production dimExprs -> dimExprs dimExpr 
-- On COMM reduce production dimExprs -> dimExprs dimExpr 
-- On COL reduce production dimExprs -> dimExprs dimExpr 
-- On BOR reduce production dimExprs -> dimExprs dimExpr 
-- On BAND reduce production dimExprs -> dimExprs dimExpr 
-- On ASSIGN reduce production dimExprs -> dimExprs dimExpr 
-- On ANDEQUAL reduce production dimExprs -> dimExprs dimExpr 
-- On AND reduce production dimExprs -> dimExprs dimExpr 

State 205:
dimExprs -> dimExpr . [ XOREQUAL XOR SEMI RSHIFTEQUAL RSHIFT RPAR RCURL RBRAC QM PLUS PEQUAL OREQUAL OR NEQUAL MULEQUAL MUL MODEQUAL MOD MINUSEQUAL MINUS LTHAN LSHIFTEQUAL LSHIFT LOGSHIFTEQUAL LOGSHIFT LETHAN LCURL LBRAC INSTANCEOF INCREMENT GTHAN GETHAN EQUAL DOT DIVEQUAL DIV DIM DECREMENT COMM COL BOR BAND ASSIGN ANDEQUAL AND ]
-- On XOREQUAL reduce production dimExprs -> dimExpr 
-- On XOR reduce production dimExprs -> dimExpr 
-- On SEMI reduce production dimExprs -> dimExpr 
-- On RSHIFTEQUAL reduce production dimExprs -> dimExpr 
-- On RSHIFT reduce production dimExprs -> dimExpr 
-- On RPAR reduce production dimExprs -> dimExpr 
-- On RCURL reduce production dimExprs -> dimExpr 
-- On RBRAC reduce production dimExprs -> dimExpr 
-- On QM reduce production dimExprs -> dimExpr 
-- On PLUS reduce production dimExprs -> dimExpr 
-- On PEQUAL reduce production dimExprs -> dimExpr 
-- On OREQUAL reduce production dimExprs -> dimExpr 
-- On OR reduce production dimExprs -> dimExpr 
-- On NEQUAL reduce production dimExprs -> dimExpr 
-- On MULEQUAL reduce production dimExprs -> dimExpr 
-- On MUL reduce production dimExprs -> dimExpr 
-- On MODEQUAL reduce production dimExprs -> dimExpr 
-- On MOD reduce production dimExprs -> dimExpr 
-- On MINUSEQUAL reduce production dimExprs -> dimExpr 
-- On MINUS reduce production dimExprs -> dimExpr 
-- On LTHAN reduce production dimExprs -> dimExpr 
-- On LSHIFTEQUAL reduce production dimExprs -> dimExpr 
-- On LSHIFT reduce production dimExprs -> dimExpr 
-- On LOGSHIFTEQUAL reduce production dimExprs -> dimExpr 
-- On LOGSHIFT reduce production dimExprs -> dimExpr 
-- On LETHAN reduce production dimExprs -> dimExpr 
-- On LCURL reduce production dimExprs -> dimExpr 
-- On LBRAC reduce production dimExprs -> dimExpr 
-- On INSTANCEOF reduce production dimExprs -> dimExpr 
-- On INCREMENT reduce production dimExprs -> dimExpr 
-- On GTHAN reduce production dimExprs -> dimExpr 
-- On GETHAN reduce production dimExprs -> dimExpr 
-- On EQUAL reduce production dimExprs -> dimExpr 
-- On DOT reduce production dimExprs -> dimExpr 
-- On DIVEQUAL reduce production dimExprs -> dimExpr 
-- On DIV reduce production dimExprs -> dimExpr 
-- On DIM reduce production dimExprs -> dimExpr 
-- On DECREMENT reduce production dimExprs -> dimExpr 
-- On COMM reduce production dimExprs -> dimExpr 
-- On COL reduce production dimExprs -> dimExpr 
-- On BOR reduce production dimExprs -> dimExpr 
-- On BAND reduce production dimExprs -> dimExpr 
-- On ASSIGN reduce production dimExprs -> dimExpr 
-- On ANDEQUAL reduce production dimExprs -> dimExpr 
-- On AND reduce production dimExprs -> dimExpr 

State 206:
iterStmt -> WHILE LPAR expression . RPAR statement [ error WHILE VOID TRY THROW THIS SYNCHRONIZED SWITCH SUPER STRLIT SHORT SEMI RETURN RCURL PLUS NULLLIT NOT NEW MINUS LPAR LONG LCURL INTLIT INT INCREMENT IF IDENTIFIER FOR FLOATLIT FLOAT FINAL ELSE DOUBLELIT DOUBLE DO DECREMENT CONTINUE CHARLIT CHAR BYTE BREAK BOOLEANLIT BOOLEAN BNOT ASSERT ]
-- On RPAR shift to state 207

State 207:
iterStmt -> WHILE LPAR expression RPAR . statement [ error WHILE VOID TRY THROW THIS SYNCHRONIZED SWITCH SUPER STRLIT SHORT SEMI RETURN RCURL PLUS NULLLIT NOT NEW MINUS LPAR LONG LCURL INTLIT INT INCREMENT IF IDENTIFIER FOR FLOATLIT FLOAT FINAL ELSE DOUBLELIT DOUBLE DO DECREMENT CONTINUE CHARLIT CHAR BYTE BREAK BOOLEANLIT BOOLEAN BNOT ASSERT ]
-- On error shift to state 3
-- On WHILE shift to state 4
-- On VOID shift to state 6
-- On TRY shift to state 208
-- On THROW shift to state 210
-- On THIS shift to state 7
-- On SYNCHRONIZED shift to state 213
-- On SWITCH shift to state 217
-- On SUPER shift to state 8
-- On STRLIT shift to state 9
-- On SHORT shift to state 10
-- On SEMI shift to state 238
-- On RETURN shift to state 239
-- On PLUS shift to state 11
-- On NULLLIT shift to state 12
-- On NOT shift to state 13
-- On NEW shift to state 14
-- On MINUS shift to state 26
-- On LPAR shift to state 27
-- On LONG shift to state 15
-- On LCURL shift to state 243
-- On INTLIT shift to state 28
-- On INT shift to state 16
-- On INCREMENT shift to state 29
-- On IF shift to state 245
-- On IDENTIFIER shift to state 249
-- On FOR shift to state 251
-- On FLOATLIT shift to state 31
-- On FLOAT shift to state 18
-- On DOUBLELIT shift to state 32
-- On DOUBLE shift to state 19
-- On DO shift to state 274
-- On DECREMENT shift to state 33
-- On CONTINUE shift to state 387
-- On CHARLIT shift to state 34
-- On CHAR shift to state 20
-- On BYTE shift to state 21
-- On BREAK shift to state 391
-- On BOOLEANLIT shift to state 35
-- On BOOLEAN shift to state 22
-- On BNOT shift to state 36
-- On ASSERT shift to state 395
-- On unaryExpression shift to state 44
-- On statement shift to state 445
-- On specialName shift to state 38
-- On shiftExpression shift to state 58
-- On selectStmt shift to state 402
-- On relationalExpression shift to state 79
-- On realPostfixExpression shift to state 39
-- On qualifiedName shift to state 42
-- On primitiveType shift to state 61
-- On primaryExpression shift to state 64
-- On postfixExpression shift to state 65
-- On plainNewAllocationExpression shift to state 68
-- On notJustName shift to state 69
-- On newAllocationExpression shift to state 72
-- On multiplicativeExpression shift to state 73
-- On methodCall shift to state 75
-- On methodAccess shift to state 76
-- On logicalUnaryOperator shift to state 83
-- On logicalUnaryExpression shift to state 85
-- On labelStmt shift to state 403
-- On jumpStmt shift to state 404
-- On iterStmt shift to state 405
-- On inclusiveOrExpression shift to state 90
-- On guardingStmt shift to state 406
-- On fieldAccess shift to state 86
-- On expressionStmt shift to state 407
-- On expression shift to state 357
-- On exclusiveOrExpression shift to state 111
-- On equalityExpression shift to state 94
-- On emptyStmt shift to state 409
-- On conditionalOrExpression shift to state 112
-- On conditionalExpression shift to state 151
-- On conditionalAndExpression shift to state 117
-- On complexPrimaryNoParenthesis shift to state 87
-- On complexPrimary shift to state 88
-- On classAllocationExpression shift to state 100
-- On castExpression shift to state 103
-- On block shift to state 410
-- On assignmentExpression shift to state 152
-- On assertStmt shift to state 411
-- On arrayAllocationExpression shift to state 104
-- On arrayAccess shift to state 120
-- On arithmeticUnaryOperator shift to state 121
-- On andExpression shift to state 123
-- On additiveExpression shift to state 140

State 208:
guardingStmt -> TRY . block finally [ error WHILE VOID TRY THROW THIS SYNCHRONIZED SWITCH SUPER STRLIT SHORT SEMI RETURN RCURL PLUS NULLLIT NOT NEW MINUS LPAR LONG LCURL INTLIT INT INCREMENT IF IDENTIFIER FOR FLOATLIT FLOAT FINAL ELSE DOUBLELIT DOUBLE DO DECREMENT CONTINUE CHARLIT CHAR BYTE BREAK BOOLEANLIT BOOLEAN BNOT ASSERT ]
guardingStmt -> TRY . block catches [ error WHILE VOID TRY THROW THIS SYNCHRONIZED SWITCH SUPER STRLIT SHORT SEMI RETURN RCURL PLUS NULLLIT NOT NEW MINUS LPAR LONG LCURL INTLIT INT INCREMENT IF IDENTIFIER FOR FLOATLIT FLOAT FINAL ELSE DOUBLELIT DOUBLE DO DECREMENT CONTINUE CHARLIT CHAR BYTE BREAK BOOLEANLIT BOOLEAN BNOT ASSERT ]
guardingStmt -> TRY . block catches finally [ error WHILE VOID TRY THROW THIS SYNCHRONIZED SWITCH SUPER STRLIT SHORT SEMI RETURN RCURL PLUS NULLLIT NOT NEW MINUS LPAR LONG LCURL INTLIT INT INCREMENT IF IDENTIFIER FOR FLOATLIT FLOAT FINAL ELSE DOUBLELIT DOUBLE DO DECREMENT CONTINUE CHARLIT CHAR BYTE BREAK BOOLEANLIT BOOLEAN BNOT ASSERT ]
-- On LCURL shift to state 209
-- On block shift to state 435

State 209:
block -> LCURL . localVariableDeclAndStmts RCURL [ WHILE RCURL FINALLY ELSE DEFAULT CATCH CASE ]
block -> LCURL . RCURL [ WHILE RCURL FINALLY ELSE DEFAULT CATCH CASE ]
-- On error shift to state 3
-- On WHILE shift to state 4
-- On VOID shift to state 6
-- On TRY shift to state 208
-- On THROW shift to state 210
-- On THIS shift to state 7
-- On SYNCHRONIZED shift to state 213
-- On SWITCH shift to state 217
-- On SUPER shift to state 8
-- On STRLIT shift to state 9
-- On SHORT shift to state 10
-- On SEMI shift to state 238
-- On RETURN shift to state 239
-- On RCURL shift to state 432
-- On PLUS shift to state 11
-- On NULLLIT shift to state 12
-- On NOT shift to state 13
-- On NEW shift to state 14
-- On MINUS shift to state 26
-- On LPAR shift to state 27
-- On LONG shift to state 15
-- On LCURL shift to state 243
-- On INTLIT shift to state 28
-- On INT shift to state 16
-- On INCREMENT shift to state 29
-- On IF shift to state 245
-- On IDENTIFIER shift to state 249
-- On FOR shift to state 251
-- On FLOATLIT shift to state 31
-- On FLOAT shift to state 18
-- On FINAL shift to state 254
-- On DOUBLELIT shift to state 32
-- On DOUBLE shift to state 19
-- On DO shift to state 274
-- On DECREMENT shift to state 33
-- On CONTINUE shift to state 387
-- On CHARLIT shift to state 34
-- On CHAR shift to state 20
-- On BYTE shift to state 21
-- On BREAK shift to state 391
-- On BOOLEANLIT shift to state 35
-- On BOOLEAN shift to state 22
-- On BNOT shift to state 36
-- On ASSERT shift to state 395
-- On unaryExpression shift to state 44
-- On typeSpecifier shift to state 422
-- On typeName shift to state 130
-- On statement shift to state 423
-- On specialName shift to state 38
-- On shiftExpression shift to state 58
-- On selectStmt shift to state 402
-- On relationalExpression shift to state 79
-- On realPostfixExpression shift to state 39
-- On qualifiedName shift to state 424
-- On primitiveType shift to state 425
-- On primaryExpression shift to state 64
-- On postfixExpression shift to state 65
-- On plainNewAllocationExpression shift to state 68
-- On notJustName shift to state 69
-- On newAllocationExpression shift to state 72
-- On multiplicativeExpression shift to state 73
-- On methodCall shift to state 75
-- On methodAccess shift to state 76
-- On logicalUnaryOperator shift to state 83
-- On logicalUnaryExpression shift to state 85
-- On localVariableDeclStmt shift to state 426
-- On localVariableDeclOrStmt shift to state 427
-- On localVariableDeclAndStmts shift to state 433
-- On labelStmt shift to state 403
-- On jumpStmt shift to state 404
-- On iterStmt shift to state 405
-- On inclusiveOrExpression shift to state 90
-- On guardingStmt shift to state 406
-- On fieldAccess shift to state 86
-- On expressionStmt shift to state 407
-- On expression shift to state 357
-- On exclusiveOrExpression shift to state 111
-- On equalityExpression shift to state 94
-- On emptyStmt shift to state 409
-- On conditionalOrExpression shift to state 112
-- On conditionalExpression shift to state 151
-- On conditionalAndExpression shift to state 117
-- On complexPrimaryNoParenthesis shift to state 87
-- On complexPrimary shift to state 88
-- On classAllocationExpression shift to state 100
-- On castExpression shift to state 103
-- On block shift to state 410
-- On assignmentExpression shift to state 152
-- On assertStmt shift to state 411
-- On arrayAllocationExpression shift to state 104
-- On arrayAccess shift to state 120
-- On arithmeticUnaryOperator shift to state 121
-- On andExpression shift to state 123
-- On additiveExpression shift to state 140

State 210:
jumpStmt -> THROW . expression SEMI [ error WHILE VOID TRY THROW THIS SYNCHRONIZED SWITCH SUPER STRLIT SHORT SEMI RETURN RCURL PLUS NULLLIT NOT NEW MINUS LPAR LONG LCURL INTLIT INT INCREMENT IF IDENTIFIER FOR FLOATLIT FLOAT FINAL ELSE DOUBLELIT DOUBLE DO DECREMENT CONTINUE CHARLIT CHAR BYTE BREAK BOOLEANLIT BOOLEAN BNOT ASSERT ]
-- On error shift to state 3
-- On VOID shift to state 6
-- On THIS shift to state 7
-- On SUPER shift to state 8
-- On STRLIT shift to state 9
-- On SHORT shift to state 10
-- On PLUS shift to state 11
-- On NULLLIT shift to state 12
-- On NOT shift to state 13
-- On NEW shift to state 14
-- On MINUS shift to state 26
-- On LPAR shift to state 27
-- On LONG shift to state 15
-- On INTLIT shift to state 28
-- On INT shift to state 16
-- On INCREMENT shift to state 29
-- On IDENTIFIER shift to state 17
-- On FLOATLIT shift to state 31
-- On FLOAT shift to state 18
-- On DOUBLELIT shift to state 32
-- On DOUBLE shift to state 19
-- On DECREMENT shift to state 33
-- On CHARLIT shift to state 34
-- On CHAR shift to state 20
-- On BYTE shift to state 21
-- On BOOLEANLIT shift to state 35
-- On BOOLEAN shift to state 22
-- On BNOT shift to state 36
-- On unaryExpression shift to state 44
-- On specialName shift to state 38
-- On shiftExpression shift to state 58
-- On relationalExpression shift to state 79
-- On realPostfixExpression shift to state 39
-- On qualifiedName shift to state 42
-- On primitiveType shift to state 61
-- On primaryExpression shift to state 64
-- On postfixExpression shift to state 65
-- On plainNewAllocationExpression shift to state 68
-- On notJustName shift to state 69
-- On newAllocationExpression shift to state 72
-- On multiplicativeExpression shift to state 73
-- On methodCall shift to state 75
-- On methodAccess shift to state 76
-- On logicalUnaryOperator shift to state 83
-- On logicalUnaryExpression shift to state 85
-- On inclusiveOrExpression shift to state 90
-- On fieldAccess shift to state 86
-- On expression shift to state 211
-- On exclusiveOrExpression shift to state 111
-- On equalityExpression shift to state 94
-- On conditionalOrExpression shift to state 112
-- On conditionalExpression shift to state 151
-- On conditionalAndExpression shift to state 117
-- On complexPrimaryNoParenthesis shift to state 87
-- On complexPrimary shift to state 88
-- On classAllocationExpression shift to state 100
-- On castExpression shift to state 103
-- On assignmentExpression shift to state 152
-- On arrayAllocationExpression shift to state 104
-- On arrayAccess shift to state 120
-- On arithmeticUnaryOperator shift to state 121
-- On andExpression shift to state 123
-- On additiveExpression shift to state 140

State 211:
jumpStmt -> THROW expression . SEMI [ error WHILE VOID TRY THROW THIS SYNCHRONIZED SWITCH SUPER STRLIT SHORT SEMI RETURN RCURL PLUS NULLLIT NOT NEW MINUS LPAR LONG LCURL INTLIT INT INCREMENT IF IDENTIFIER FOR FLOATLIT FLOAT FINAL ELSE DOUBLELIT DOUBLE DO DECREMENT CONTINUE CHARLIT CHAR BYTE BREAK BOOLEANLIT BOOLEAN BNOT ASSERT ]
-- On SEMI shift to state 212

State 212:
jumpStmt -> THROW expression SEMI . [ error WHILE VOID TRY THROW THIS SYNCHRONIZED SWITCH SUPER STRLIT SHORT SEMI RETURN RCURL PLUS NULLLIT NOT NEW MINUS LPAR LONG LCURL INTLIT INT INCREMENT IF IDENTIFIER FOR FLOATLIT FLOAT FINAL ELSE DOUBLELIT DOUBLE DO DECREMENT CONTINUE CHARLIT CHAR BYTE BREAK BOOLEANLIT BOOLEAN BNOT ASSERT ]
-- On error reduce production jumpStmt -> THROW expression SEMI 
-- On WHILE reduce production jumpStmt -> THROW expression SEMI 
-- On VOID reduce production jumpStmt -> THROW expression SEMI 
-- On TRY reduce production jumpStmt -> THROW expression SEMI 
-- On THROW reduce production jumpStmt -> THROW expression SEMI 
-- On THIS reduce production jumpStmt -> THROW expression SEMI 
-- On SYNCHRONIZED reduce production jumpStmt -> THROW expression SEMI 
-- On SWITCH reduce production jumpStmt -> THROW expression SEMI 
-- On SUPER reduce production jumpStmt -> THROW expression SEMI 
-- On STRLIT reduce production jumpStmt -> THROW expression SEMI 
-- On SHORT reduce production jumpStmt -> THROW expression SEMI 
-- On SEMI reduce production jumpStmt -> THROW expression SEMI 
-- On RETURN reduce production jumpStmt -> THROW expression SEMI 
-- On RCURL reduce production jumpStmt -> THROW expression SEMI 
-- On PLUS reduce production jumpStmt -> THROW expression SEMI 
-- On NULLLIT reduce production jumpStmt -> THROW expression SEMI 
-- On NOT reduce production jumpStmt -> THROW expression SEMI 
-- On NEW reduce production jumpStmt -> THROW expression SEMI 
-- On MINUS reduce production jumpStmt -> THROW expression SEMI 
-- On LPAR reduce production jumpStmt -> THROW expression SEMI 
-- On LONG reduce production jumpStmt -> THROW expression SEMI 
-- On LCURL reduce production jumpStmt -> THROW expression SEMI 
-- On INTLIT reduce production jumpStmt -> THROW expression SEMI 
-- On INT reduce production jumpStmt -> THROW expression SEMI 
-- On INCREMENT reduce production jumpStmt -> THROW expression SEMI 
-- On IF reduce production jumpStmt -> THROW expression SEMI 
-- On IDENTIFIER reduce production jumpStmt -> THROW expression SEMI 
-- On FOR reduce production jumpStmt -> THROW expression SEMI 
-- On FLOATLIT reduce production jumpStmt -> THROW expression SEMI 
-- On FLOAT reduce production jumpStmt -> THROW expression SEMI 
-- On FINAL reduce production jumpStmt -> THROW expression SEMI 
-- On ELSE reduce production jumpStmt -> THROW expression SEMI 
-- On DOUBLELIT reduce production jumpStmt -> THROW expression SEMI 
-- On DOUBLE reduce production jumpStmt -> THROW expression SEMI 
-- On DO reduce production jumpStmt -> THROW expression SEMI 
-- On DECREMENT reduce production jumpStmt -> THROW expression SEMI 
-- On CONTINUE reduce production jumpStmt -> THROW expression SEMI 
-- On CHARLIT reduce production jumpStmt -> THROW expression SEMI 
-- On CHAR reduce production jumpStmt -> THROW expression SEMI 
-- On BYTE reduce production jumpStmt -> THROW expression SEMI 
-- On BREAK reduce production jumpStmt -> THROW expression SEMI 
-- On BOOLEANLIT reduce production jumpStmt -> THROW expression SEMI 
-- On BOOLEAN reduce production jumpStmt -> THROW expression SEMI 
-- On BNOT reduce production jumpStmt -> THROW expression SEMI 
-- On ASSERT reduce production jumpStmt -> THROW expression SEMI 

State 213:
guardingStmt -> SYNCHRONIZED . LPAR expression RPAR statement [ error WHILE VOID TRY THROW THIS SYNCHRONIZED SWITCH SUPER STRLIT SHORT SEMI RETURN RCURL PLUS NULLLIT NOT NEW MINUS LPAR LONG LCURL INTLIT INT INCREMENT IF IDENTIFIER FOR FLOATLIT FLOAT FINAL ELSE DOUBLELIT DOUBLE DO DECREMENT CONTINUE CHARLIT CHAR BYTE BREAK BOOLEANLIT BOOLEAN BNOT ASSERT ]
-- On LPAR shift to state 214

State 214:
guardingStmt -> SYNCHRONIZED LPAR . expression RPAR statement [ error WHILE VOID TRY THROW THIS SYNCHRONIZED SWITCH SUPER STRLIT SHORT SEMI RETURN RCURL PLUS NULLLIT NOT NEW MINUS LPAR LONG LCURL INTLIT INT INCREMENT IF IDENTIFIER FOR FLOATLIT FLOAT FINAL ELSE DOUBLELIT DOUBLE DO DECREMENT CONTINUE CHARLIT CHAR BYTE BREAK BOOLEANLIT BOOLEAN BNOT ASSERT ]
-- On error shift to state 3
-- On VOID shift to state 6
-- On THIS shift to state 7
-- On SUPER shift to state 8
-- On STRLIT shift to state 9
-- On SHORT shift to state 10
-- On PLUS shift to state 11
-- On NULLLIT shift to state 12
-- On NOT shift to state 13
-- On NEW shift to state 14
-- On MINUS shift to state 26
-- On LPAR shift to state 27
-- On LONG shift to state 15
-- On INTLIT shift to state 28
-- On INT shift to state 16
-- On INCREMENT shift to state 29
-- On IDENTIFIER shift to state 17
-- On FLOATLIT shift to state 31
-- On FLOAT shift to state 18
-- On DOUBLELIT shift to state 32
-- On DOUBLE shift to state 19
-- On DECREMENT shift to state 33
-- On CHARLIT shift to state 34
-- On CHAR shift to state 20
-- On BYTE shift to state 21
-- On BOOLEANLIT shift to state 35
-- On BOOLEAN shift to state 22
-- On BNOT shift to state 36
-- On unaryExpression shift to state 44
-- On specialName shift to state 38
-- On shiftExpression shift to state 58
-- On relationalExpression shift to state 79
-- On realPostfixExpression shift to state 39
-- On qualifiedName shift to state 42
-- On primitiveType shift to state 61
-- On primaryExpression shift to state 64
-- On postfixExpression shift to state 65
-- On plainNewAllocationExpression shift to state 68
-- On notJustName shift to state 69
-- On newAllocationExpression shift to state 72
-- On multiplicativeExpression shift to state 73
-- On methodCall shift to state 75
-- On methodAccess shift to state 76
-- On logicalUnaryOperator shift to state 83
-- On logicalUnaryExpression shift to state 85
-- On inclusiveOrExpression shift to state 90
-- On fieldAccess shift to state 86
-- On expression shift to state 215
-- On exclusiveOrExpression shift to state 111
-- On equalityExpression shift to state 94
-- On conditionalOrExpression shift to state 112
-- On conditionalExpression shift to state 151
-- On conditionalAndExpression shift to state 117
-- On complexPrimaryNoParenthesis shift to state 87
-- On complexPrimary shift to state 88
-- On classAllocationExpression shift to state 100
-- On castExpression shift to state 103
-- On assignmentExpression shift to state 152
-- On arrayAllocationExpression shift to state 104
-- On arrayAccess shift to state 120
-- On arithmeticUnaryOperator shift to state 121
-- On andExpression shift to state 123
-- On additiveExpression shift to state 140

State 215:
guardingStmt -> SYNCHRONIZED LPAR expression . RPAR statement [ error WHILE VOID TRY THROW THIS SYNCHRONIZED SWITCH SUPER STRLIT SHORT SEMI RETURN RCURL PLUS NULLLIT NOT NEW MINUS LPAR LONG LCURL INTLIT INT INCREMENT IF IDENTIFIER FOR FLOATLIT FLOAT FINAL ELSE DOUBLELIT DOUBLE DO DECREMENT CONTINUE CHARLIT CHAR BYTE BREAK BOOLEANLIT BOOLEAN BNOT ASSERT ]
-- On RPAR shift to state 216

State 216:
guardingStmt -> SYNCHRONIZED LPAR expression RPAR . statement [ error WHILE VOID TRY THROW THIS SYNCHRONIZED SWITCH SUPER STRLIT SHORT SEMI RETURN RCURL PLUS NULLLIT NOT NEW MINUS LPAR LONG LCURL INTLIT INT INCREMENT IF IDENTIFIER FOR FLOATLIT FLOAT FINAL ELSE DOUBLELIT DOUBLE DO DECREMENT CONTINUE CHARLIT CHAR BYTE BREAK BOOLEANLIT BOOLEAN BNOT ASSERT ]
-- On error shift to state 3
-- On WHILE shift to state 4
-- On VOID shift to state 6
-- On TRY shift to state 208
-- On THROW shift to state 210
-- On THIS shift to state 7
-- On SYNCHRONIZED shift to state 213
-- On SWITCH shift to state 217
-- On SUPER shift to state 8
-- On STRLIT shift to state 9
-- On SHORT shift to state 10
-- On SEMI shift to state 238
-- On RETURN shift to state 239
-- On PLUS shift to state 11
-- On NULLLIT shift to state 12
-- On NOT shift to state 13
-- On NEW shift to state 14
-- On MINUS shift to state 26
-- On LPAR shift to state 27
-- On LONG shift to state 15
-- On LCURL shift to state 243
-- On INTLIT shift to state 28
-- On INT shift to state 16
-- On INCREMENT shift to state 29
-- On IF shift to state 245
-- On IDENTIFIER shift to state 249
-- On FOR shift to state 251
-- On FLOATLIT shift to state 31
-- On FLOAT shift to state 18
-- On DOUBLELIT shift to state 32
-- On DOUBLE shift to state 19
-- On DO shift to state 274
-- On DECREMENT shift to state 33
-- On CONTINUE shift to state 387
-- On CHARLIT shift to state 34
-- On CHAR shift to state 20
-- On BYTE shift to state 21
-- On BREAK shift to state 391
-- On BOOLEANLIT shift to state 35
-- On BOOLEAN shift to state 22
-- On BNOT shift to state 36
-- On ASSERT shift to state 395
-- On unaryExpression shift to state 44
-- On statement shift to state 431
-- On specialName shift to state 38
-- On shiftExpression shift to state 58
-- On selectStmt shift to state 402
-- On relationalExpression shift to state 79
-- On realPostfixExpression shift to state 39
-- On qualifiedName shift to state 42
-- On primitiveType shift to state 61
-- On primaryExpression shift to state 64
-- On postfixExpression shift to state 65
-- On plainNewAllocationExpression shift to state 68
-- On notJustName shift to state 69
-- On newAllocationExpression shift to state 72
-- On multiplicativeExpression shift to state 73
-- On methodCall shift to state 75
-- On methodAccess shift to state 76
-- On logicalUnaryOperator shift to state 83
-- On logicalUnaryExpression shift to state 85
-- On labelStmt shift to state 403
-- On jumpStmt shift to state 404
-- On iterStmt shift to state 405
-- On inclusiveOrExpression shift to state 90
-- On guardingStmt shift to state 406
-- On fieldAccess shift to state 86
-- On expressionStmt shift to state 407
-- On expression shift to state 357
-- On exclusiveOrExpression shift to state 111
-- On equalityExpression shift to state 94
-- On emptyStmt shift to state 409
-- On conditionalOrExpression shift to state 112
-- On conditionalExpression shift to state 151
-- On conditionalAndExpression shift to state 117
-- On complexPrimaryNoParenthesis shift to state 87
-- On complexPrimary shift to state 88
-- On classAllocationExpression shift to state 100
-- On castExpression shift to state 103
-- On block shift to state 410
-- On assignmentExpression shift to state 152
-- On assertStmt shift to state 411
-- On arrayAllocationExpression shift to state 104
-- On arrayAccess shift to state 120
-- On arithmeticUnaryOperator shift to state 121
-- On andExpression shift to state 123
-- On additiveExpression shift to state 140

State 217:
selectStmt -> SWITCH . LPAR expression RPAR switchBlock [ error WHILE VOID TRY THROW THIS SYNCHRONIZED SWITCH SUPER STRLIT SHORT SEMI RETURN RCURL PLUS NULLLIT NOT NEW MINUS LPAR LONG LCURL INTLIT INT INCREMENT IF IDENTIFIER FOR FLOATLIT FLOAT FINAL ELSE DOUBLELIT DOUBLE DO DECREMENT CONTINUE CHARLIT CHAR BYTE BREAK BOOLEANLIT BOOLEAN BNOT ASSERT ]
-- On LPAR shift to state 218

State 218:
selectStmt -> SWITCH LPAR . expression RPAR switchBlock [ error WHILE VOID TRY THROW THIS SYNCHRONIZED SWITCH SUPER STRLIT SHORT SEMI RETURN RCURL PLUS NULLLIT NOT NEW MINUS LPAR LONG LCURL INTLIT INT INCREMENT IF IDENTIFIER FOR FLOATLIT FLOAT FINAL ELSE DOUBLELIT DOUBLE DO DECREMENT CONTINUE CHARLIT CHAR BYTE BREAK BOOLEANLIT BOOLEAN BNOT ASSERT ]
-- On error shift to state 3
-- On VOID shift to state 6
-- On THIS shift to state 7
-- On SUPER shift to state 8
-- On STRLIT shift to state 9
-- On SHORT shift to state 10
-- On PLUS shift to state 11
-- On NULLLIT shift to state 12
-- On NOT shift to state 13
-- On NEW shift to state 14
-- On MINUS shift to state 26
-- On LPAR shift to state 27
-- On LONG shift to state 15
-- On INTLIT shift to state 28
-- On INT shift to state 16
-- On INCREMENT shift to state 29
-- On IDENTIFIER shift to state 17
-- On FLOATLIT shift to state 31
-- On FLOAT shift to state 18
-- On DOUBLELIT shift to state 32
-- On DOUBLE shift to state 19
-- On DECREMENT shift to state 33
-- On CHARLIT shift to state 34
-- On CHAR shift to state 20
-- On BYTE shift to state 21
-- On BOOLEANLIT shift to state 35
-- On BOOLEAN shift to state 22
-- On BNOT shift to state 36
-- On unaryExpression shift to state 44
-- On specialName shift to state 38
-- On shiftExpression shift to state 58
-- On relationalExpression shift to state 79
-- On realPostfixExpression shift to state 39
-- On qualifiedName shift to state 42
-- On primitiveType shift to state 61
-- On primaryExpression shift to state 64
-- On postfixExpression shift to state 65
-- On plainNewAllocationExpression shift to state 68
-- On notJustName shift to state 69
-- On newAllocationExpression shift to state 72
-- On multiplicativeExpression shift to state 73
-- On methodCall shift to state 75
-- On methodAccess shift to state 76
-- On logicalUnaryOperator shift to state 83
-- On logicalUnaryExpression shift to state 85
-- On inclusiveOrExpression shift to state 90
-- On fieldAccess shift to state 86
-- On expression shift to state 219
-- On exclusiveOrExpression shift to state 111
-- On equalityExpression shift to state 94
-- On conditionalOrExpression shift to state 112
-- On conditionalExpression shift to state 151
-- On conditionalAndExpression shift to state 117
-- On complexPrimaryNoParenthesis shift to state 87
-- On complexPrimary shift to state 88
-- On classAllocationExpression shift to state 100
-- On castExpression shift to state 103
-- On assignmentExpression shift to state 152
-- On arrayAllocationExpression shift to state 104
-- On arrayAccess shift to state 120
-- On arithmeticUnaryOperator shift to state 121
-- On andExpression shift to state 123
-- On additiveExpression shift to state 140

State 219:
selectStmt -> SWITCH LPAR expression . RPAR switchBlock [ error WHILE VOID TRY THROW THIS SYNCHRONIZED SWITCH SUPER STRLIT SHORT SEMI RETURN RCURL PLUS NULLLIT NOT NEW MINUS LPAR LONG LCURL INTLIT INT INCREMENT IF IDENTIFIER FOR FLOATLIT FLOAT FINAL ELSE DOUBLELIT DOUBLE DO DECREMENT CONTINUE CHARLIT CHAR BYTE BREAK BOOLEANLIT BOOLEAN BNOT ASSERT ]
-- On RPAR shift to state 220

State 220:
selectStmt -> SWITCH LPAR expression RPAR . switchBlock [ error WHILE VOID TRY THROW THIS SYNCHRONIZED SWITCH SUPER STRLIT SHORT SEMI RETURN RCURL PLUS NULLLIT NOT NEW MINUS LPAR LONG LCURL INTLIT INT INCREMENT IF IDENTIFIER FOR FLOATLIT FLOAT FINAL ELSE DOUBLELIT DOUBLE DO DECREMENT CONTINUE CHARLIT CHAR BYTE BREAK BOOLEANLIT BOOLEAN BNOT ASSERT ]
-- On LCURL shift to state 221
-- On switchBlock shift to state 237

State 221:
switchBlock -> LCURL . RCURL [ error WHILE VOID TRY THROW THIS SYNCHRONIZED SWITCH SUPER STRLIT SHORT SEMI RETURN RCURL PLUS NULLLIT NOT NEW MINUS LPAR LONG LCURL INTLIT INT INCREMENT IF IDENTIFIER FOR FLOATLIT FLOAT FINAL ELSE DOUBLELIT DOUBLE DO DECREMENT CONTINUE CHARLIT CHAR BYTE BREAK BOOLEANLIT BOOLEAN BNOT ASSERT ]
switchBlock -> LCURL . switchBlockStmtGroups RCURL [ error WHILE VOID TRY THROW THIS SYNCHRONIZED SWITCH SUPER STRLIT SHORT SEMI RETURN RCURL PLUS NULLLIT NOT NEW MINUS LPAR LONG LCURL INTLIT INT INCREMENT IF IDENTIFIER FOR FLOATLIT FLOAT FINAL ELSE DOUBLELIT DOUBLE DO DECREMENT CONTINUE CHARLIT CHAR BYTE BREAK BOOLEANLIT BOOLEAN BNOT ASSERT ]
-- On RCURL shift to state 222
-- On DEFAULT shift to state 223
-- On CASE shift to state 225
-- On switchLabels shift to state 229
-- On switchLabel shift to state 232
-- On switchBlockStmtGroups shift to state 233
-- On switchBlockStmtGroup shift to state 236

State 222:
switchBlock -> LCURL RCURL . [ error WHILE VOID TRY THROW THIS SYNCHRONIZED SWITCH SUPER STRLIT SHORT SEMI RETURN RCURL PLUS NULLLIT NOT NEW MINUS LPAR LONG LCURL INTLIT INT INCREMENT IF IDENTIFIER FOR FLOATLIT FLOAT FINAL ELSE DOUBLELIT DOUBLE DO DECREMENT CONTINUE CHARLIT CHAR BYTE BREAK BOOLEANLIT BOOLEAN BNOT ASSERT ]
-- On error reduce production switchBlock -> LCURL RCURL 
-- On WHILE reduce production switchBlock -> LCURL RCURL 
-- On VOID reduce production switchBlock -> LCURL RCURL 
-- On TRY reduce production switchBlock -> LCURL RCURL 
-- On THROW reduce production switchBlock -> LCURL RCURL 
-- On THIS reduce production switchBlock -> LCURL RCURL 
-- On SYNCHRONIZED reduce production switchBlock -> LCURL RCURL 
-- On SWITCH reduce production switchBlock -> LCURL RCURL 
-- On SUPER reduce production switchBlock -> LCURL RCURL 
-- On STRLIT reduce production switchBlock -> LCURL RCURL 
-- On SHORT reduce production switchBlock -> LCURL RCURL 
-- On SEMI reduce production switchBlock -> LCURL RCURL 
-- On RETURN reduce production switchBlock -> LCURL RCURL 
-- On RCURL reduce production switchBlock -> LCURL RCURL 
-- On PLUS reduce production switchBlock -> LCURL RCURL 
-- On NULLLIT reduce production switchBlock -> LCURL RCURL 
-- On NOT reduce production switchBlock -> LCURL RCURL 
-- On NEW reduce production switchBlock -> LCURL RCURL 
-- On MINUS reduce production switchBlock -> LCURL RCURL 
-- On LPAR reduce production switchBlock -> LCURL RCURL 
-- On LONG reduce production switchBlock -> LCURL RCURL 
-- On LCURL reduce production switchBlock -> LCURL RCURL 
-- On INTLIT reduce production switchBlock -> LCURL RCURL 
-- On INT reduce production switchBlock -> LCURL RCURL 
-- On INCREMENT reduce production switchBlock -> LCURL RCURL 
-- On IF reduce production switchBlock -> LCURL RCURL 
-- On IDENTIFIER reduce production switchBlock -> LCURL RCURL 
-- On FOR reduce production switchBlock -> LCURL RCURL 
-- On FLOATLIT reduce production switchBlock -> LCURL RCURL 
-- On FLOAT reduce production switchBlock -> LCURL RCURL 
-- On FINAL reduce production switchBlock -> LCURL RCURL 
-- On ELSE reduce production switchBlock -> LCURL RCURL 
-- On DOUBLELIT reduce production switchBlock -> LCURL RCURL 
-- On DOUBLE reduce production switchBlock -> LCURL RCURL 
-- On DO reduce production switchBlock -> LCURL RCURL 
-- On DECREMENT reduce production switchBlock -> LCURL RCURL 
-- On CONTINUE reduce production switchBlock -> LCURL RCURL 
-- On CHARLIT reduce production switchBlock -> LCURL RCURL 
-- On CHAR reduce production switchBlock -> LCURL RCURL 
-- On BYTE reduce production switchBlock -> LCURL RCURL 
-- On BREAK reduce production switchBlock -> LCURL RCURL 
-- On BOOLEANLIT reduce production switchBlock -> LCURL RCURL 
-- On BOOLEAN reduce production switchBlock -> LCURL RCURL 
-- On BNOT reduce production switchBlock -> LCURL RCURL 
-- On ASSERT reduce production switchBlock -> LCURL RCURL 

State 223:
switchLabel -> DEFAULT . COL [ LCURL DEFAULT CASE ]
-- On COL shift to state 224

State 224:
switchLabel -> DEFAULT COL . [ LCURL DEFAULT CASE ]
-- On LCURL reduce production switchLabel -> DEFAULT COL 
-- On DEFAULT reduce production switchLabel -> DEFAULT COL 
-- On CASE reduce production switchLabel -> DEFAULT COL 

State 225:
switchLabel -> CASE . constantExpression COL [ LCURL DEFAULT CASE ]
-- On VOID shift to state 6
-- On THIS shift to state 7
-- On SUPER shift to state 8
-- On STRLIT shift to state 9
-- On SHORT shift to state 10
-- On PLUS shift to state 11
-- On NULLLIT shift to state 12
-- On NOT shift to state 13
-- On NEW shift to state 14
-- On MINUS shift to state 26
-- On LPAR shift to state 27
-- On LONG shift to state 15
-- On INTLIT shift to state 28
-- On INT shift to state 16
-- On INCREMENT shift to state 29
-- On IDENTIFIER shift to state 17
-- On FLOATLIT shift to state 31
-- On FLOAT shift to state 18
-- On DOUBLELIT shift to state 32
-- On DOUBLE shift to state 19
-- On DECREMENT shift to state 33
-- On CHARLIT shift to state 34
-- On CHAR shift to state 20
-- On BYTE shift to state 21
-- On BOOLEANLIT shift to state 35
-- On BOOLEAN shift to state 22
-- On BNOT shift to state 36
-- On unaryExpression shift to state 60
-- On specialName shift to state 38
-- On shiftExpression shift to state 58
-- On relationalExpression shift to state 79
-- On realPostfixExpression shift to state 39
-- On qualifiedName shift to state 42
-- On primitiveType shift to state 61
-- On primaryExpression shift to state 64
-- On postfixExpression shift to state 65
-- On plainNewAllocationExpression shift to state 68
-- On notJustName shift to state 69
-- On newAllocationExpression shift to state 72
-- On multiplicativeExpression shift to state 73
-- On methodCall shift to state 75
-- On methodAccess shift to state 76
-- On logicalUnaryOperator shift to state 83
-- On logicalUnaryExpression shift to state 85
-- On inclusiveOrExpression shift to state 90
-- On fieldAccess shift to state 86
-- On exclusiveOrExpression shift to state 111
-- On equalityExpression shift to state 94
-- On constantExpression shift to state 226
-- On conditionalOrExpression shift to state 112
-- On conditionalExpression shift to state 228
-- On conditionalAndExpression shift to state 117
-- On complexPrimaryNoParenthesis shift to state 87
-- On complexPrimary shift to state 88
-- On classAllocationExpression shift to state 100
-- On castExpression shift to state 103
-- On arrayAllocationExpression shift to state 104
-- On arrayAccess shift to state 120
-- On arithmeticUnaryOperator shift to state 121
-- On andExpression shift to state 123
-- On additiveExpression shift to state 140

State 226:
switchLabel -> CASE constantExpression . COL [ LCURL DEFAULT CASE ]
-- On COL shift to state 227

State 227:
switchLabel -> CASE constantExpression COL . [ LCURL DEFAULT CASE ]
-- On LCURL reduce production switchLabel -> CASE constantExpression COL 
-- On DEFAULT reduce production switchLabel -> CASE constantExpression COL 
-- On CASE reduce production switchLabel -> CASE constantExpression COL 

State 228:
constantExpression -> conditionalExpression . [ COL ]
-- On COL reduce production constantExpression -> conditionalExpression 

State 229:
switchBlockStmtGroup -> switchLabels . block [ RCURL DEFAULT CASE ]
switchLabels -> switchLabels . switchLabel [ LCURL DEFAULT CASE ]
-- On LCURL shift to state 209
-- On DEFAULT shift to state 223
-- On CASE shift to state 225
-- On switchLabel shift to state 230
-- On block shift to state 231

State 230:
switchLabels -> switchLabels switchLabel . [ LCURL DEFAULT CASE ]
-- On LCURL reduce production switchLabels -> switchLabels switchLabel 
-- On DEFAULT reduce production switchLabels -> switchLabels switchLabel 
-- On CASE reduce production switchLabels -> switchLabels switchLabel 

State 231:
switchBlockStmtGroup -> switchLabels block . [ RCURL DEFAULT CASE ]
-- On RCURL reduce production switchBlockStmtGroup -> switchLabels block 
-- On DEFAULT reduce production switchBlockStmtGroup -> switchLabels block 
-- On CASE reduce production switchBlockStmtGroup -> switchLabels block 

State 232:
switchLabels -> switchLabel . [ LCURL DEFAULT CASE ]
-- On LCURL reduce production switchLabels -> switchLabel 
-- On DEFAULT reduce production switchLabels -> switchLabel 
-- On CASE reduce production switchLabels -> switchLabel 

State 233:
switchBlock -> LCURL switchBlockStmtGroups . RCURL [ error WHILE VOID TRY THROW THIS SYNCHRONIZED SWITCH SUPER STRLIT SHORT SEMI RETURN RCURL PLUS NULLLIT NOT NEW MINUS LPAR LONG LCURL INTLIT INT INCREMENT IF IDENTIFIER FOR FLOATLIT FLOAT FINAL ELSE DOUBLELIT DOUBLE DO DECREMENT CONTINUE CHARLIT CHAR BYTE BREAK BOOLEANLIT BOOLEAN BNOT ASSERT ]
switchBlockStmtGroups -> switchBlockStmtGroups . switchBlockStmtGroup [ RCURL DEFAULT CASE ]
-- On RCURL shift to state 234
-- On DEFAULT shift to state 223
-- On CASE shift to state 225
-- On switchLabels shift to state 229
-- On switchLabel shift to state 232
-- On switchBlockStmtGroup shift to state 235

State 234:
switchBlock -> LCURL switchBlockStmtGroups RCURL . [ error WHILE VOID TRY THROW THIS SYNCHRONIZED SWITCH SUPER STRLIT SHORT SEMI RETURN RCURL PLUS NULLLIT NOT NEW MINUS LPAR LONG LCURL INTLIT INT INCREMENT IF IDENTIFIER FOR FLOATLIT FLOAT FINAL ELSE DOUBLELIT DOUBLE DO DECREMENT CONTINUE CHARLIT CHAR BYTE BREAK BOOLEANLIT BOOLEAN BNOT ASSERT ]
-- On error reduce production switchBlock -> LCURL switchBlockStmtGroups RCURL 
-- On WHILE reduce production switchBlock -> LCURL switchBlockStmtGroups RCURL 
-- On VOID reduce production switchBlock -> LCURL switchBlockStmtGroups RCURL 
-- On TRY reduce production switchBlock -> LCURL switchBlockStmtGroups RCURL 
-- On THROW reduce production switchBlock -> LCURL switchBlockStmtGroups RCURL 
-- On THIS reduce production switchBlock -> LCURL switchBlockStmtGroups RCURL 
-- On SYNCHRONIZED reduce production switchBlock -> LCURL switchBlockStmtGroups RCURL 
-- On SWITCH reduce production switchBlock -> LCURL switchBlockStmtGroups RCURL 
-- On SUPER reduce production switchBlock -> LCURL switchBlockStmtGroups RCURL 
-- On STRLIT reduce production switchBlock -> LCURL switchBlockStmtGroups RCURL 
-- On SHORT reduce production switchBlock -> LCURL switchBlockStmtGroups RCURL 
-- On SEMI reduce production switchBlock -> LCURL switchBlockStmtGroups RCURL 
-- On RETURN reduce production switchBlock -> LCURL switchBlockStmtGroups RCURL 
-- On RCURL reduce production switchBlock -> LCURL switchBlockStmtGroups RCURL 
-- On PLUS reduce production switchBlock -> LCURL switchBlockStmtGroups RCURL 
-- On NULLLIT reduce production switchBlock -> LCURL switchBlockStmtGroups RCURL 
-- On NOT reduce production switchBlock -> LCURL switchBlockStmtGroups RCURL 
-- On NEW reduce production switchBlock -> LCURL switchBlockStmtGroups RCURL 
-- On MINUS reduce production switchBlock -> LCURL switchBlockStmtGroups RCURL 
-- On LPAR reduce production switchBlock -> LCURL switchBlockStmtGroups RCURL 
-- On LONG reduce production switchBlock -> LCURL switchBlockStmtGroups RCURL 
-- On LCURL reduce production switchBlock -> LCURL switchBlockStmtGroups RCURL 
-- On INTLIT reduce production switchBlock -> LCURL switchBlockStmtGroups RCURL 
-- On INT reduce production switchBlock -> LCURL switchBlockStmtGroups RCURL 
-- On INCREMENT reduce production switchBlock -> LCURL switchBlockStmtGroups RCURL 
-- On IF reduce production switchBlock -> LCURL switchBlockStmtGroups RCURL 
-- On IDENTIFIER reduce production switchBlock -> LCURL switchBlockStmtGroups RCURL 
-- On FOR reduce production switchBlock -> LCURL switchBlockStmtGroups RCURL 
-- On FLOATLIT reduce production switchBlock -> LCURL switchBlockStmtGroups RCURL 
-- On FLOAT reduce production switchBlock -> LCURL switchBlockStmtGroups RCURL 
-- On FINAL reduce production switchBlock -> LCURL switchBlockStmtGroups RCURL 
-- On ELSE reduce production switchBlock -> LCURL switchBlockStmtGroups RCURL 
-- On DOUBLELIT reduce production switchBlock -> LCURL switchBlockStmtGroups RCURL 
-- On DOUBLE reduce production switchBlock -> LCURL switchBlockStmtGroups RCURL 
-- On DO reduce production switchBlock -> LCURL switchBlockStmtGroups RCURL 
-- On DECREMENT reduce production switchBlock -> LCURL switchBlockStmtGroups RCURL 
-- On CONTINUE reduce production switchBlock -> LCURL switchBlockStmtGroups RCURL 
-- On CHARLIT reduce production switchBlock -> LCURL switchBlockStmtGroups RCURL 
-- On CHAR reduce production switchBlock -> LCURL switchBlockStmtGroups RCURL 
-- On BYTE reduce production switchBlock -> LCURL switchBlockStmtGroups RCURL 
-- On BREAK reduce production switchBlock -> LCURL switchBlockStmtGroups RCURL 
-- On BOOLEANLIT reduce production switchBlock -> LCURL switchBlockStmtGroups RCURL 
-- On BOOLEAN reduce production switchBlock -> LCURL switchBlockStmtGroups RCURL 
-- On BNOT reduce production switchBlock -> LCURL switchBlockStmtGroups RCURL 
-- On ASSERT reduce production switchBlock -> LCURL switchBlockStmtGroups RCURL 

State 235:
switchBlockStmtGroups -> switchBlockStmtGroups switchBlockStmtGroup . [ RCURL DEFAULT CASE ]
-- On RCURL reduce production switchBlockStmtGroups -> switchBlockStmtGroups switchBlockStmtGroup 
-- On DEFAULT reduce production switchBlockStmtGroups -> switchBlockStmtGroups switchBlockStmtGroup 
-- On CASE reduce production switchBlockStmtGroups -> switchBlockStmtGroups switchBlockStmtGroup 

State 236:
switchBlockStmtGroups -> switchBlockStmtGroup . [ RCURL DEFAULT CASE ]
-- On RCURL reduce production switchBlockStmtGroups -> switchBlockStmtGroup 
-- On DEFAULT reduce production switchBlockStmtGroups -> switchBlockStmtGroup 
-- On CASE reduce production switchBlockStmtGroups -> switchBlockStmtGroup 

State 237:
selectStmt -> SWITCH LPAR expression RPAR switchBlock . [ error WHILE VOID TRY THROW THIS SYNCHRONIZED SWITCH SUPER STRLIT SHORT SEMI RETURN RCURL PLUS NULLLIT NOT NEW MINUS LPAR LONG LCURL INTLIT INT INCREMENT IF IDENTIFIER FOR FLOATLIT FLOAT FINAL ELSE DOUBLELIT DOUBLE DO DECREMENT CONTINUE CHARLIT CHAR BYTE BREAK BOOLEANLIT BOOLEAN BNOT ASSERT ]
-- On error reduce production selectStmt -> SWITCH LPAR expression RPAR switchBlock 
-- On WHILE reduce production selectStmt -> SWITCH LPAR expression RPAR switchBlock 
-- On VOID reduce production selectStmt -> SWITCH LPAR expression RPAR switchBlock 
-- On TRY reduce production selectStmt -> SWITCH LPAR expression RPAR switchBlock 
-- On THROW reduce production selectStmt -> SWITCH LPAR expression RPAR switchBlock 
-- On THIS reduce production selectStmt -> SWITCH LPAR expression RPAR switchBlock 
-- On SYNCHRONIZED reduce production selectStmt -> SWITCH LPAR expression RPAR switchBlock 
-- On SWITCH reduce production selectStmt -> SWITCH LPAR expression RPAR switchBlock 
-- On SUPER reduce production selectStmt -> SWITCH LPAR expression RPAR switchBlock 
-- On STRLIT reduce production selectStmt -> SWITCH LPAR expression RPAR switchBlock 
-- On SHORT reduce production selectStmt -> SWITCH LPAR expression RPAR switchBlock 
-- On SEMI reduce production selectStmt -> SWITCH LPAR expression RPAR switchBlock 
-- On RETURN reduce production selectStmt -> SWITCH LPAR expression RPAR switchBlock 
-- On RCURL reduce production selectStmt -> SWITCH LPAR expression RPAR switchBlock 
-- On PLUS reduce production selectStmt -> SWITCH LPAR expression RPAR switchBlock 
-- On NULLLIT reduce production selectStmt -> SWITCH LPAR expression RPAR switchBlock 
-- On NOT reduce production selectStmt -> SWITCH LPAR expression RPAR switchBlock 
-- On NEW reduce production selectStmt -> SWITCH LPAR expression RPAR switchBlock 
-- On MINUS reduce production selectStmt -> SWITCH LPAR expression RPAR switchBlock 
-- On LPAR reduce production selectStmt -> SWITCH LPAR expression RPAR switchBlock 
-- On LONG reduce production selectStmt -> SWITCH LPAR expression RPAR switchBlock 
-- On LCURL reduce production selectStmt -> SWITCH LPAR expression RPAR switchBlock 
-- On INTLIT reduce production selectStmt -> SWITCH LPAR expression RPAR switchBlock 
-- On INT reduce production selectStmt -> SWITCH LPAR expression RPAR switchBlock 
-- On INCREMENT reduce production selectStmt -> SWITCH LPAR expression RPAR switchBlock 
-- On IF reduce production selectStmt -> SWITCH LPAR expression RPAR switchBlock 
-- On IDENTIFIER reduce production selectStmt -> SWITCH LPAR expression RPAR switchBlock 
-- On FOR reduce production selectStmt -> SWITCH LPAR expression RPAR switchBlock 
-- On FLOATLIT reduce production selectStmt -> SWITCH LPAR expression RPAR switchBlock 
-- On FLOAT reduce production selectStmt -> SWITCH LPAR expression RPAR switchBlock 
-- On FINAL reduce production selectStmt -> SWITCH LPAR expression RPAR switchBlock 
-- On ELSE reduce production selectStmt -> SWITCH LPAR expression RPAR switchBlock 
-- On DOUBLELIT reduce production selectStmt -> SWITCH LPAR expression RPAR switchBlock 
-- On DOUBLE reduce production selectStmt -> SWITCH LPAR expression RPAR switchBlock 
-- On DO reduce production selectStmt -> SWITCH LPAR expression RPAR switchBlock 
-- On DECREMENT reduce production selectStmt -> SWITCH LPAR expression RPAR switchBlock 
-- On CONTINUE reduce production selectStmt -> SWITCH LPAR expression RPAR switchBlock 
-- On CHARLIT reduce production selectStmt -> SWITCH LPAR expression RPAR switchBlock 
-- On CHAR reduce production selectStmt -> SWITCH LPAR expression RPAR switchBlock 
-- On BYTE reduce production selectStmt -> SWITCH LPAR expression RPAR switchBlock 
-- On BREAK reduce production selectStmt -> SWITCH LPAR expression RPAR switchBlock 
-- On BOOLEANLIT reduce production selectStmt -> SWITCH LPAR expression RPAR switchBlock 
-- On BOOLEAN reduce production selectStmt -> SWITCH LPAR expression RPAR switchBlock 
-- On BNOT reduce production selectStmt -> SWITCH LPAR expression RPAR switchBlock 
-- On ASSERT reduce production selectStmt -> SWITCH LPAR expression RPAR switchBlock 

State 238:
emptyStmt -> SEMI . [ error WHILE VOID TRY THROW THIS SYNCHRONIZED SWITCH SUPER STRLIT SHORT SEMI RETURN RCURL PLUS NULLLIT NOT NEW MINUS LPAR LONG LCURL INTLIT INT INCREMENT IF IDENTIFIER FOR FLOATLIT FLOAT FINAL ELSE DOUBLELIT DOUBLE DO DECREMENT CONTINUE CHARLIT CHAR BYTE BREAK BOOLEANLIT BOOLEAN BNOT ASSERT ]
-- On error reduce production emptyStmt -> SEMI 
-- On WHILE reduce production emptyStmt -> SEMI 
-- On VOID reduce production emptyStmt -> SEMI 
-- On TRY reduce production emptyStmt -> SEMI 
-- On THROW reduce production emptyStmt -> SEMI 
-- On THIS reduce production emptyStmt -> SEMI 
-- On SYNCHRONIZED reduce production emptyStmt -> SEMI 
-- On SWITCH reduce production emptyStmt -> SEMI 
-- On SUPER reduce production emptyStmt -> SEMI 
-- On STRLIT reduce production emptyStmt -> SEMI 
-- On SHORT reduce production emptyStmt -> SEMI 
-- On SEMI reduce production emptyStmt -> SEMI 
-- On RETURN reduce production emptyStmt -> SEMI 
-- On RCURL reduce production emptyStmt -> SEMI 
-- On PLUS reduce production emptyStmt -> SEMI 
-- On NULLLIT reduce production emptyStmt -> SEMI 
-- On NOT reduce production emptyStmt -> SEMI 
-- On NEW reduce production emptyStmt -> SEMI 
-- On MINUS reduce production emptyStmt -> SEMI 
-- On LPAR reduce production emptyStmt -> SEMI 
-- On LONG reduce production emptyStmt -> SEMI 
-- On LCURL reduce production emptyStmt -> SEMI 
-- On INTLIT reduce production emptyStmt -> SEMI 
-- On INT reduce production emptyStmt -> SEMI 
-- On INCREMENT reduce production emptyStmt -> SEMI 
-- On IF reduce production emptyStmt -> SEMI 
-- On IDENTIFIER reduce production emptyStmt -> SEMI 
-- On FOR reduce production emptyStmt -> SEMI 
-- On FLOATLIT reduce production emptyStmt -> SEMI 
-- On FLOAT reduce production emptyStmt -> SEMI 
-- On FINAL reduce production emptyStmt -> SEMI 
-- On ELSE reduce production emptyStmt -> SEMI 
-- On DOUBLELIT reduce production emptyStmt -> SEMI 
-- On DOUBLE reduce production emptyStmt -> SEMI 
-- On DO reduce production emptyStmt -> SEMI 
-- On DECREMENT reduce production emptyStmt -> SEMI 
-- On CONTINUE reduce production emptyStmt -> SEMI 
-- On CHARLIT reduce production emptyStmt -> SEMI 
-- On CHAR reduce production emptyStmt -> SEMI 
-- On BYTE reduce production emptyStmt -> SEMI 
-- On BREAK reduce production emptyStmt -> SEMI 
-- On BOOLEANLIT reduce production emptyStmt -> SEMI 
-- On BOOLEAN reduce production emptyStmt -> SEMI 
-- On BNOT reduce production emptyStmt -> SEMI 
-- On ASSERT reduce production emptyStmt -> SEMI 

State 239:
jumpStmt -> RETURN . expression SEMI [ error WHILE VOID TRY THROW THIS SYNCHRONIZED SWITCH SUPER STRLIT SHORT SEMI RETURN RCURL PLUS NULLLIT NOT NEW MINUS LPAR LONG LCURL INTLIT INT INCREMENT IF IDENTIFIER FOR FLOATLIT FLOAT FINAL ELSE DOUBLELIT DOUBLE DO DECREMENT CONTINUE CHARLIT CHAR BYTE BREAK BOOLEANLIT BOOLEAN BNOT ASSERT ]
jumpStmt -> RETURN . SEMI [ error WHILE VOID TRY THROW THIS SYNCHRONIZED SWITCH SUPER STRLIT SHORT SEMI RETURN RCURL PLUS NULLLIT NOT NEW MINUS LPAR LONG LCURL INTLIT INT INCREMENT IF IDENTIFIER FOR FLOATLIT FLOAT FINAL ELSE DOUBLELIT DOUBLE DO DECREMENT CONTINUE CHARLIT CHAR BYTE BREAK BOOLEANLIT BOOLEAN BNOT ASSERT ]
-- On error shift to state 3
-- On VOID shift to state 6
-- On THIS shift to state 7
-- On SUPER shift to state 8
-- On STRLIT shift to state 9
-- On SHORT shift to state 10
-- On SEMI shift to state 240
-- On PLUS shift to state 11
-- On NULLLIT shift to state 12
-- On NOT shift to state 13
-- On NEW shift to state 14
-- On MINUS shift to state 26
-- On LPAR shift to state 27
-- On LONG shift to state 15
-- On INTLIT shift to state 28
-- On INT shift to state 16
-- On INCREMENT shift to state 29
-- On IDENTIFIER shift to state 17
-- On FLOATLIT shift to state 31
-- On FLOAT shift to state 18
-- On DOUBLELIT shift to state 32
-- On DOUBLE shift to state 19
-- On DECREMENT shift to state 33
-- On CHARLIT shift to state 34
-- On CHAR shift to state 20
-- On BYTE shift to state 21
-- On BOOLEANLIT shift to state 35
-- On BOOLEAN shift to state 22
-- On BNOT shift to state 36
-- On unaryExpression shift to state 44
-- On specialName shift to state 38
-- On shiftExpression shift to state 58
-- On relationalExpression shift to state 79
-- On realPostfixExpression shift to state 39
-- On qualifiedName shift to state 42
-- On primitiveType shift to state 61
-- On primaryExpression shift to state 64
-- On postfixExpression shift to state 65
-- On plainNewAllocationExpression shift to state 68
-- On notJustName shift to state 69
-- On newAllocationExpression shift to state 72
-- On multiplicativeExpression shift to state 73
-- On methodCall shift to state 75
-- On methodAccess shift to state 76
-- On logicalUnaryOperator shift to state 83
-- On logicalUnaryExpression shift to state 85
-- On inclusiveOrExpression shift to state 90
-- On fieldAccess shift to state 86
-- On expression shift to state 241
-- On exclusiveOrExpression shift to state 111
-- On equalityExpression shift to state 94
-- On conditionalOrExpression shift to state 112
-- On conditionalExpression shift to state 151
-- On conditionalAndExpression shift to state 117
-- On complexPrimaryNoParenthesis shift to state 87
-- On complexPrimary shift to state 88
-- On classAllocationExpression shift to state 100
-- On castExpression shift to state 103
-- On assignmentExpression shift to state 152
-- On arrayAllocationExpression shift to state 104
-- On arrayAccess shift to state 120
-- On arithmeticUnaryOperator shift to state 121
-- On andExpression shift to state 123
-- On additiveExpression shift to state 140

State 240:
jumpStmt -> RETURN SEMI . [ error WHILE VOID TRY THROW THIS SYNCHRONIZED SWITCH SUPER STRLIT SHORT SEMI RETURN RCURL PLUS NULLLIT NOT NEW MINUS LPAR LONG LCURL INTLIT INT INCREMENT IF IDENTIFIER FOR FLOATLIT FLOAT FINAL ELSE DOUBLELIT DOUBLE DO DECREMENT CONTINUE CHARLIT CHAR BYTE BREAK BOOLEANLIT BOOLEAN BNOT ASSERT ]
-- On error reduce production jumpStmt -> RETURN SEMI 
-- On WHILE reduce production jumpStmt -> RETURN SEMI 
-- On VOID reduce production jumpStmt -> RETURN SEMI 
-- On TRY reduce production jumpStmt -> RETURN SEMI 
-- On THROW reduce production jumpStmt -> RETURN SEMI 
-- On THIS reduce production jumpStmt -> RETURN SEMI 
-- On SYNCHRONIZED reduce production jumpStmt -> RETURN SEMI 
-- On SWITCH reduce production jumpStmt -> RETURN SEMI 
-- On SUPER reduce production jumpStmt -> RETURN SEMI 
-- On STRLIT reduce production jumpStmt -> RETURN SEMI 
-- On SHORT reduce production jumpStmt -> RETURN SEMI 
-- On SEMI reduce production jumpStmt -> RETURN SEMI 
-- On RETURN reduce production jumpStmt -> RETURN SEMI 
-- On RCURL reduce production jumpStmt -> RETURN SEMI 
-- On PLUS reduce production jumpStmt -> RETURN SEMI 
-- On NULLLIT reduce production jumpStmt -> RETURN SEMI 
-- On NOT reduce production jumpStmt -> RETURN SEMI 
-- On NEW reduce production jumpStmt -> RETURN SEMI 
-- On MINUS reduce production jumpStmt -> RETURN SEMI 
-- On LPAR reduce production jumpStmt -> RETURN SEMI 
-- On LONG reduce production jumpStmt -> RETURN SEMI 
-- On LCURL reduce production jumpStmt -> RETURN SEMI 
-- On INTLIT reduce production jumpStmt -> RETURN SEMI 
-- On INT reduce production jumpStmt -> RETURN SEMI 
-- On INCREMENT reduce production jumpStmt -> RETURN SEMI 
-- On IF reduce production jumpStmt -> RETURN SEMI 
-- On IDENTIFIER reduce production jumpStmt -> RETURN SEMI 
-- On FOR reduce production jumpStmt -> RETURN SEMI 
-- On FLOATLIT reduce production jumpStmt -> RETURN SEMI 
-- On FLOAT reduce production jumpStmt -> RETURN SEMI 
-- On FINAL reduce production jumpStmt -> RETURN SEMI 
-- On ELSE reduce production jumpStmt -> RETURN SEMI 
-- On DOUBLELIT reduce production jumpStmt -> RETURN SEMI 
-- On DOUBLE reduce production jumpStmt -> RETURN SEMI 
-- On DO reduce production jumpStmt -> RETURN SEMI 
-- On DECREMENT reduce production jumpStmt -> RETURN SEMI 
-- On CONTINUE reduce production jumpStmt -> RETURN SEMI 
-- On CHARLIT reduce production jumpStmt -> RETURN SEMI 
-- On CHAR reduce production jumpStmt -> RETURN SEMI 
-- On BYTE reduce production jumpStmt -> RETURN SEMI 
-- On BREAK reduce production jumpStmt -> RETURN SEMI 
-- On BOOLEANLIT reduce production jumpStmt -> RETURN SEMI 
-- On BOOLEAN reduce production jumpStmt -> RETURN SEMI 
-- On BNOT reduce production jumpStmt -> RETURN SEMI 
-- On ASSERT reduce production jumpStmt -> RETURN SEMI 

State 241:
jumpStmt -> RETURN expression . SEMI [ error WHILE VOID TRY THROW THIS SYNCHRONIZED SWITCH SUPER STRLIT SHORT SEMI RETURN RCURL PLUS NULLLIT NOT NEW MINUS LPAR LONG LCURL INTLIT INT INCREMENT IF IDENTIFIER FOR FLOATLIT FLOAT FINAL ELSE DOUBLELIT DOUBLE DO DECREMENT CONTINUE CHARLIT CHAR BYTE BREAK BOOLEANLIT BOOLEAN BNOT ASSERT ]
-- On SEMI shift to state 242

State 242:
jumpStmt -> RETURN expression SEMI . [ error WHILE VOID TRY THROW THIS SYNCHRONIZED SWITCH SUPER STRLIT SHORT SEMI RETURN RCURL PLUS NULLLIT NOT NEW MINUS LPAR LONG LCURL INTLIT INT INCREMENT IF IDENTIFIER FOR FLOATLIT FLOAT FINAL ELSE DOUBLELIT DOUBLE DO DECREMENT CONTINUE CHARLIT CHAR BYTE BREAK BOOLEANLIT BOOLEAN BNOT ASSERT ]
-- On error reduce production jumpStmt -> RETURN expression SEMI 
-- On WHILE reduce production jumpStmt -> RETURN expression SEMI 
-- On VOID reduce production jumpStmt -> RETURN expression SEMI 
-- On TRY reduce production jumpStmt -> RETURN expression SEMI 
-- On THROW reduce production jumpStmt -> RETURN expression SEMI 
-- On THIS reduce production jumpStmt -> RETURN expression SEMI 
-- On SYNCHRONIZED reduce production jumpStmt -> RETURN expression SEMI 
-- On SWITCH reduce production jumpStmt -> RETURN expression SEMI 
-- On SUPER reduce production jumpStmt -> RETURN expression SEMI 
-- On STRLIT reduce production jumpStmt -> RETURN expression SEMI 
-- On SHORT reduce production jumpStmt -> RETURN expression SEMI 
-- On SEMI reduce production jumpStmt -> RETURN expression SEMI 
-- On RETURN reduce production jumpStmt -> RETURN expression SEMI 
-- On RCURL reduce production jumpStmt -> RETURN expression SEMI 
-- On PLUS reduce production jumpStmt -> RETURN expression SEMI 
-- On NULLLIT reduce production jumpStmt -> RETURN expression SEMI 
-- On NOT reduce production jumpStmt -> RETURN expression SEMI 
-- On NEW reduce production jumpStmt -> RETURN expression SEMI 
-- On MINUS reduce production jumpStmt -> RETURN expression SEMI 
-- On LPAR reduce production jumpStmt -> RETURN expression SEMI 
-- On LONG reduce production jumpStmt -> RETURN expression SEMI 
-- On LCURL reduce production jumpStmt -> RETURN expression SEMI 
-- On INTLIT reduce production jumpStmt -> RETURN expression SEMI 
-- On INT reduce production jumpStmt -> RETURN expression SEMI 
-- On INCREMENT reduce production jumpStmt -> RETURN expression SEMI 
-- On IF reduce production jumpStmt -> RETURN expression SEMI 
-- On IDENTIFIER reduce production jumpStmt -> RETURN expression SEMI 
-- On FOR reduce production jumpStmt -> RETURN expression SEMI 
-- On FLOATLIT reduce production jumpStmt -> RETURN expression SEMI 
-- On FLOAT reduce production jumpStmt -> RETURN expression SEMI 
-- On FINAL reduce production jumpStmt -> RETURN expression SEMI 
-- On ELSE reduce production jumpStmt -> RETURN expression SEMI 
-- On DOUBLELIT reduce production jumpStmt -> RETURN expression SEMI 
-- On DOUBLE reduce production jumpStmt -> RETURN expression SEMI 
-- On DO reduce production jumpStmt -> RETURN expression SEMI 
-- On DECREMENT reduce production jumpStmt -> RETURN expression SEMI 
-- On CONTINUE reduce production jumpStmt -> RETURN expression SEMI 
-- On CHARLIT reduce production jumpStmt -> RETURN expression SEMI 
-- On CHAR reduce production jumpStmt -> RETURN expression SEMI 
-- On BYTE reduce production jumpStmt -> RETURN expression SEMI 
-- On BREAK reduce production jumpStmt -> RETURN expression SEMI 
-- On BOOLEANLIT reduce production jumpStmt -> RETURN expression SEMI 
-- On BOOLEAN reduce production jumpStmt -> RETURN expression SEMI 
-- On BNOT reduce production jumpStmt -> RETURN expression SEMI 
-- On ASSERT reduce production jumpStmt -> RETURN expression SEMI 

State 243:
block -> LCURL . localVariableDeclAndStmts RCURL [ error WHILE VOID TRY THROW THIS SYNCHRONIZED SWITCH SUPER STRLIT SHORT SEMI RETURN RCURL PLUS NULLLIT NOT NEW MINUS LPAR LONG LCURL INTLIT INT INCREMENT IF IDENTIFIER FOR FLOATLIT FLOAT FINALLY FINAL ELSE DOUBLELIT DOUBLE DO DECREMENT CONTINUE CHARLIT CHAR CATCH BYTE BREAK BOOLEANLIT BOOLEAN BNOT ASSERT ]
block -> LCURL . RCURL [ error WHILE VOID TRY THROW THIS SYNCHRONIZED SWITCH SUPER STRLIT SHORT SEMI RETURN RCURL PLUS NULLLIT NOT NEW MINUS LPAR LONG LCURL INTLIT INT INCREMENT IF IDENTIFIER FOR FLOATLIT FLOAT FINALLY FINAL ELSE DOUBLELIT DOUBLE DO DECREMENT CONTINUE CHARLIT CHAR CATCH BYTE BREAK BOOLEANLIT BOOLEAN BNOT ASSERT ]
-- On error shift to state 3
-- On WHILE shift to state 4
-- On VOID shift to state 6
-- On TRY shift to state 208
-- On THROW shift to state 210
-- On THIS shift to state 7
-- On SYNCHRONIZED shift to state 213
-- On SWITCH shift to state 217
-- On SUPER shift to state 8
-- On STRLIT shift to state 9
-- On SHORT shift to state 10
-- On SEMI shift to state 238
-- On RETURN shift to state 239
-- On RCURL shift to state 244
-- On PLUS shift to state 11
-- On NULLLIT shift to state 12
-- On NOT shift to state 13
-- On NEW shift to state 14
-- On MINUS shift to state 26
-- On LPAR shift to state 27
-- On LONG shift to state 15
-- On LCURL shift to state 243
-- On INTLIT shift to state 28
-- On INT shift to state 16
-- On INCREMENT shift to state 29
-- On IF shift to state 245
-- On IDENTIFIER shift to state 249
-- On FOR shift to state 251
-- On FLOATLIT shift to state 31
-- On FLOAT shift to state 18
-- On FINAL shift to state 254
-- On DOUBLELIT shift to state 32
-- On DOUBLE shift to state 19
-- On DO shift to state 274
-- On DECREMENT shift to state 33
-- On CONTINUE shift to state 387
-- On CHARLIT shift to state 34
-- On CHAR shift to state 20
-- On BYTE shift to state 21
-- On BREAK shift to state 391
-- On BOOLEANLIT shift to state 35
-- On BOOLEAN shift to state 22
-- On BNOT shift to state 36
-- On ASSERT shift to state 395
-- On unaryExpression shift to state 44
-- On typeSpecifier shift to state 422
-- On typeName shift to state 130
-- On statement shift to state 423
-- On specialName shift to state 38
-- On shiftExpression shift to state 58
-- On selectStmt shift to state 402
-- On relationalExpression shift to state 79
-- On realPostfixExpression shift to state 39
-- On qualifiedName shift to state 424
-- On primitiveType shift to state 425
-- On primaryExpression shift to state 64
-- On postfixExpression shift to state 65
-- On plainNewAllocationExpression shift to state 68
-- On notJustName shift to state 69
-- On newAllocationExpression shift to state 72
-- On multiplicativeExpression shift to state 73
-- On methodCall shift to state 75
-- On methodAccess shift to state 76
-- On logicalUnaryOperator shift to state 83
-- On logicalUnaryExpression shift to state 85
-- On localVariableDeclStmt shift to state 426
-- On localVariableDeclOrStmt shift to state 427
-- On localVariableDeclAndStmts shift to state 428
-- On labelStmt shift to state 403
-- On jumpStmt shift to state 404
-- On iterStmt shift to state 405
-- On inclusiveOrExpression shift to state 90
-- On guardingStmt shift to state 406
-- On fieldAccess shift to state 86
-- On expressionStmt shift to state 407
-- On expression shift to state 357
-- On exclusiveOrExpression shift to state 111
-- On equalityExpression shift to state 94
-- On emptyStmt shift to state 409
-- On conditionalOrExpression shift to state 112
-- On conditionalExpression shift to state 151
-- On conditionalAndExpression shift to state 117
-- On complexPrimaryNoParenthesis shift to state 87
-- On complexPrimary shift to state 88
-- On classAllocationExpression shift to state 100
-- On castExpression shift to state 103
-- On block shift to state 410
-- On assignmentExpression shift to state 152
-- On assertStmt shift to state 411
-- On arrayAllocationExpression shift to state 104
-- On arrayAccess shift to state 120
-- On arithmeticUnaryOperator shift to state 121
-- On andExpression shift to state 123
-- On additiveExpression shift to state 140

State 244:
block -> LCURL RCURL . [ error WHILE VOID TRY THROW THIS SYNCHRONIZED SWITCH SUPER STRLIT SHORT SEMI RETURN RCURL PLUS NULLLIT NOT NEW MINUS LPAR LONG LCURL INTLIT INT INCREMENT IF IDENTIFIER FOR FLOATLIT FLOAT FINALLY FINAL ELSE DOUBLELIT DOUBLE DO DECREMENT CONTINUE CHARLIT CHAR CATCH BYTE BREAK BOOLEANLIT BOOLEAN BNOT ASSERT ]
-- On error reduce production block -> LCURL RCURL 
-- On WHILE reduce production block -> LCURL RCURL 
-- On VOID reduce production block -> LCURL RCURL 
-- On TRY reduce production block -> LCURL RCURL 
-- On THROW reduce production block -> LCURL RCURL 
-- On THIS reduce production block -> LCURL RCURL 
-- On SYNCHRONIZED reduce production block -> LCURL RCURL 
-- On SWITCH reduce production block -> LCURL RCURL 
-- On SUPER reduce production block -> LCURL RCURL 
-- On STRLIT reduce production block -> LCURL RCURL 
-- On SHORT reduce production block -> LCURL RCURL 
-- On SEMI reduce production block -> LCURL RCURL 
-- On RETURN reduce production block -> LCURL RCURL 
-- On RCURL reduce production block -> LCURL RCURL 
-- On PLUS reduce production block -> LCURL RCURL 
-- On NULLLIT reduce production block -> LCURL RCURL 
-- On NOT reduce production block -> LCURL RCURL 
-- On NEW reduce production block -> LCURL RCURL 
-- On MINUS reduce production block -> LCURL RCURL 
-- On LPAR reduce production block -> LCURL RCURL 
-- On LONG reduce production block -> LCURL RCURL 
-- On LCURL reduce production block -> LCURL RCURL 
-- On INTLIT reduce production block -> LCURL RCURL 
-- On INT reduce production block -> LCURL RCURL 
-- On INCREMENT reduce production block -> LCURL RCURL 
-- On IF reduce production block -> LCURL RCURL 
-- On IDENTIFIER reduce production block -> LCURL RCURL 
-- On FOR reduce production block -> LCURL RCURL 
-- On FLOATLIT reduce production block -> LCURL RCURL 
-- On FLOAT reduce production block -> LCURL RCURL 
-- On FINALLY reduce production block -> LCURL RCURL 
-- On FINAL reduce production block -> LCURL RCURL 
-- On ELSE reduce production block -> LCURL RCURL 
-- On DOUBLELIT reduce production block -> LCURL RCURL 
-- On DOUBLE reduce production block -> LCURL RCURL 
-- On DO reduce production block -> LCURL RCURL 
-- On DECREMENT reduce production block -> LCURL RCURL 
-- On CONTINUE reduce production block -> LCURL RCURL 
-- On CHARLIT reduce production block -> LCURL RCURL 
-- On CHAR reduce production block -> LCURL RCURL 
-- On CATCH reduce production block -> LCURL RCURL 
-- On BYTE reduce production block -> LCURL RCURL 
-- On BREAK reduce production block -> LCURL RCURL 
-- On BOOLEANLIT reduce production block -> LCURL RCURL 
-- On BOOLEAN reduce production block -> LCURL RCURL 
-- On BNOT reduce production block -> LCURL RCURL 
-- On ASSERT reduce production block -> LCURL RCURL 

State 245:
selectStmt -> IF . LPAR expression RPAR statement [ error WHILE VOID TRY THROW THIS SYNCHRONIZED SWITCH SUPER STRLIT SHORT SEMI RETURN RCURL PLUS NULLLIT NOT NEW MINUS LPAR LONG LCURL INTLIT INT INCREMENT IF IDENTIFIER FOR FLOATLIT FLOAT FINAL ELSE DOUBLELIT DOUBLE DO DECREMENT CONTINUE CHARLIT CHAR BYTE BREAK BOOLEANLIT BOOLEAN BNOT ASSERT ]
selectStmt -> IF . LPAR expression RPAR statement ELSE statement [ error WHILE VOID TRY THROW THIS SYNCHRONIZED SWITCH SUPER STRLIT SHORT SEMI RETURN RCURL PLUS NULLLIT NOT NEW MINUS LPAR LONG LCURL INTLIT INT INCREMENT IF IDENTIFIER FOR FLOATLIT FLOAT FINAL ELSE DOUBLELIT DOUBLE DO DECREMENT CONTINUE CHARLIT CHAR BYTE BREAK BOOLEANLIT BOOLEAN BNOT ASSERT ]
-- On LPAR shift to state 246

State 246:
selectStmt -> IF LPAR . expression RPAR statement [ error WHILE VOID TRY THROW THIS SYNCHRONIZED SWITCH SUPER STRLIT SHORT SEMI RETURN RCURL PLUS NULLLIT NOT NEW MINUS LPAR LONG LCURL INTLIT INT INCREMENT IF IDENTIFIER FOR FLOATLIT FLOAT FINAL ELSE DOUBLELIT DOUBLE DO DECREMENT CONTINUE CHARLIT CHAR BYTE BREAK BOOLEANLIT BOOLEAN BNOT ASSERT ]
selectStmt -> IF LPAR . expression RPAR statement ELSE statement [ error WHILE VOID TRY THROW THIS SYNCHRONIZED SWITCH SUPER STRLIT SHORT SEMI RETURN RCURL PLUS NULLLIT NOT NEW MINUS LPAR LONG LCURL INTLIT INT INCREMENT IF IDENTIFIER FOR FLOATLIT FLOAT FINAL ELSE DOUBLELIT DOUBLE DO DECREMENT CONTINUE CHARLIT CHAR BYTE BREAK BOOLEANLIT BOOLEAN BNOT ASSERT ]
-- On error shift to state 3
-- On VOID shift to state 6
-- On THIS shift to state 7
-- On SUPER shift to state 8
-- On STRLIT shift to state 9
-- On SHORT shift to state 10
-- On PLUS shift to state 11
-- On NULLLIT shift to state 12
-- On NOT shift to state 13
-- On NEW shift to state 14
-- On MINUS shift to state 26
-- On LPAR shift to state 27
-- On LONG shift to state 15
-- On INTLIT shift to state 28
-- On INT shift to state 16
-- On INCREMENT shift to state 29
-- On IDENTIFIER shift to state 17
-- On FLOATLIT shift to state 31
-- On FLOAT shift to state 18
-- On DOUBLELIT shift to state 32
-- On DOUBLE shift to state 19
-- On DECREMENT shift to state 33
-- On CHARLIT shift to state 34
-- On CHAR shift to state 20
-- On BYTE shift to state 21
-- On BOOLEANLIT shift to state 35
-- On BOOLEAN shift to state 22
-- On BNOT shift to state 36
-- On unaryExpression shift to state 44
-- On specialName shift to state 38
-- On shiftExpression shift to state 58
-- On relationalExpression shift to state 79
-- On realPostfixExpression shift to state 39
-- On qualifiedName shift to state 42
-- On primitiveType shift to state 61
-- On primaryExpression shift to state 64
-- On postfixExpression shift to state 65
-- On plainNewAllocationExpression shift to state 68
-- On notJustName shift to state 69
-- On newAllocationExpression shift to state 72
-- On multiplicativeExpression shift to state 73
-- On methodCall shift to state 75
-- On methodAccess shift to state 76
-- On logicalUnaryOperator shift to state 83
-- On logicalUnaryExpression shift to state 85
-- On inclusiveOrExpression shift to state 90
-- On fieldAccess shift to state 86
-- On expression shift to state 247
-- On exclusiveOrExpression shift to state 111
-- On equalityExpression shift to state 94
-- On conditionalOrExpression shift to state 112
-- On conditionalExpression shift to state 151
-- On conditionalAndExpression shift to state 117
-- On complexPrimaryNoParenthesis shift to state 87
-- On complexPrimary shift to state 88
-- On classAllocationExpression shift to state 100
-- On castExpression shift to state 103
-- On assignmentExpression shift to state 152
-- On arrayAllocationExpression shift to state 104
-- On arrayAccess shift to state 120
-- On arithmeticUnaryOperator shift to state 121
-- On andExpression shift to state 123
-- On additiveExpression shift to state 140

State 247:
selectStmt -> IF LPAR expression . RPAR statement [ error WHILE VOID TRY THROW THIS SYNCHRONIZED SWITCH SUPER STRLIT SHORT SEMI RETURN RCURL PLUS NULLLIT NOT NEW MINUS LPAR LONG LCURL INTLIT INT INCREMENT IF IDENTIFIER FOR FLOATLIT FLOAT FINAL ELSE DOUBLELIT DOUBLE DO DECREMENT CONTINUE CHARLIT CHAR BYTE BREAK BOOLEANLIT BOOLEAN BNOT ASSERT ]
selectStmt -> IF LPAR expression . RPAR statement ELSE statement [ error WHILE VOID TRY THROW THIS SYNCHRONIZED SWITCH SUPER STRLIT SHORT SEMI RETURN RCURL PLUS NULLLIT NOT NEW MINUS LPAR LONG LCURL INTLIT INT INCREMENT IF IDENTIFIER FOR FLOATLIT FLOAT FINAL ELSE DOUBLELIT DOUBLE DO DECREMENT CONTINUE CHARLIT CHAR BYTE BREAK BOOLEANLIT BOOLEAN BNOT ASSERT ]
-- On RPAR shift to state 248

State 248:
selectStmt -> IF LPAR expression RPAR . statement [ error WHILE VOID TRY THROW THIS SYNCHRONIZED SWITCH SUPER STRLIT SHORT SEMI RETURN RCURL PLUS NULLLIT NOT NEW MINUS LPAR LONG LCURL INTLIT INT INCREMENT IF IDENTIFIER FOR FLOATLIT FLOAT FINAL ELSE DOUBLELIT DOUBLE DO DECREMENT CONTINUE CHARLIT CHAR BYTE BREAK BOOLEANLIT BOOLEAN BNOT ASSERT ]
selectStmt -> IF LPAR expression RPAR . statement ELSE statement [ error WHILE VOID TRY THROW THIS SYNCHRONIZED SWITCH SUPER STRLIT SHORT SEMI RETURN RCURL PLUS NULLLIT NOT NEW MINUS LPAR LONG LCURL INTLIT INT INCREMENT IF IDENTIFIER FOR FLOATLIT FLOAT FINAL ELSE DOUBLELIT DOUBLE DO DECREMENT CONTINUE CHARLIT CHAR BYTE BREAK BOOLEANLIT BOOLEAN BNOT ASSERT ]
-- On error shift to state 3
-- On WHILE shift to state 4
-- On VOID shift to state 6
-- On TRY shift to state 208
-- On THROW shift to state 210
-- On THIS shift to state 7
-- On SYNCHRONIZED shift to state 213
-- On SWITCH shift to state 217
-- On SUPER shift to state 8
-- On STRLIT shift to state 9
-- On SHORT shift to state 10
-- On SEMI shift to state 238
-- On RETURN shift to state 239
-- On PLUS shift to state 11
-- On NULLLIT shift to state 12
-- On NOT shift to state 13
-- On NEW shift to state 14
-- On MINUS shift to state 26
-- On LPAR shift to state 27
-- On LONG shift to state 15
-- On LCURL shift to state 243
-- On INTLIT shift to state 28
-- On INT shift to state 16
-- On INCREMENT shift to state 29
-- On IF shift to state 245
-- On IDENTIFIER shift to state 249
-- On FOR shift to state 251
-- On FLOATLIT shift to state 31
-- On FLOAT shift to state 18
-- On DOUBLELIT shift to state 32
-- On DOUBLE shift to state 19
-- On DO shift to state 274
-- On DECREMENT shift to state 33
-- On CONTINUE shift to state 387
-- On CHARLIT shift to state 34
-- On CHAR shift to state 20
-- On BYTE shift to state 21
-- On BREAK shift to state 391
-- On BOOLEANLIT shift to state 35
-- On BOOLEAN shift to state 22
-- On BNOT shift to state 36
-- On ASSERT shift to state 395
-- On unaryExpression shift to state 44
-- On statement shift to state 419
-- On specialName shift to state 38
-- On shiftExpression shift to state 58
-- On selectStmt shift to state 402
-- On relationalExpression shift to state 79
-- On realPostfixExpression shift to state 39
-- On qualifiedName shift to state 42
-- On primitiveType shift to state 61
-- On primaryExpression shift to state 64
-- On postfixExpression shift to state 65
-- On plainNewAllocationExpression shift to state 68
-- On notJustName shift to state 69
-- On newAllocationExpression shift to state 72
-- On multiplicativeExpression shift to state 73
-- On methodCall shift to state 75
-- On methodAccess shift to state 76
-- On logicalUnaryOperator shift to state 83
-- On logicalUnaryExpression shift to state 85
-- On labelStmt shift to state 403
-- On jumpStmt shift to state 404
-- On iterStmt shift to state 405
-- On inclusiveOrExpression shift to state 90
-- On guardingStmt shift to state 406
-- On fieldAccess shift to state 86
-- On expressionStmt shift to state 407
-- On expression shift to state 357
-- On exclusiveOrExpression shift to state 111
-- On equalityExpression shift to state 94
-- On emptyStmt shift to state 409
-- On conditionalOrExpression shift to state 112
-- On conditionalExpression shift to state 151
-- On conditionalAndExpression shift to state 117
-- On complexPrimaryNoParenthesis shift to state 87
-- On complexPrimary shift to state 88
-- On classAllocationExpression shift to state 100
-- On castExpression shift to state 103
-- On block shift to state 410
-- On assignmentExpression shift to state 152
-- On assertStmt shift to state 411
-- On arrayAllocationExpression shift to state 104
-- On arrayAccess shift to state 120
-- On arithmeticUnaryOperator shift to state 121
-- On andExpression shift to state 123
-- On additiveExpression shift to state 140

State 249:
labelStmt -> IDENTIFIER . COL [ error WHILE VOID TRY THROW THIS SYNCHRONIZED SWITCH SUPER STRLIT SHORT SEMI RETURN RCURL PLUS NULLLIT NOT NEW MINUS LPAR LONG LCURL INTLIT INT INCREMENT IF IDENTIFIER FOR FLOATLIT FLOAT FINAL ELSE DOUBLELIT DOUBLE DO DECREMENT CONTINUE CHARLIT CHAR BYTE BREAK BOOLEANLIT BOOLEAN BNOT ASSERT ]
qualifiedName -> IDENTIFIER . [ XOREQUAL XOR SEMI RSHIFTEQUAL RSHIFT QM PLUS PEQUAL OREQUAL OR NEQUAL MULEQUAL MUL MODEQUAL MOD MINUSEQUAL MINUS LTHAN LSHIFTEQUAL LSHIFT LPAR LOGSHIFTEQUAL LOGSHIFT LETHAN LBRAC INSTANCEOF INCREMENT IDENTIFIER GTHAN GETHAN EQUAL DOT DIVEQUAL DIV DIM DECREMENT BOR BAND ASSIGN ANDEQUAL AND ]
-- On COL shift to state 250
-- On XOREQUAL reduce production qualifiedName -> IDENTIFIER 
-- On XOR reduce production qualifiedName -> IDENTIFIER 
-- On SEMI reduce production qualifiedName -> IDENTIFIER 
-- On RSHIFTEQUAL reduce production qualifiedName -> IDENTIFIER 
-- On RSHIFT reduce production qualifiedName -> IDENTIFIER 
-- On QM reduce production qualifiedName -> IDENTIFIER 
-- On PLUS reduce production qualifiedName -> IDENTIFIER 
-- On PEQUAL reduce production qualifiedName -> IDENTIFIER 
-- On OREQUAL reduce production qualifiedName -> IDENTIFIER 
-- On OR reduce production qualifiedName -> IDENTIFIER 
-- On NEQUAL reduce production qualifiedName -> IDENTIFIER 
-- On MULEQUAL reduce production qualifiedName -> IDENTIFIER 
-- On MUL reduce production qualifiedName -> IDENTIFIER 
-- On MODEQUAL reduce production qualifiedName -> IDENTIFIER 
-- On MOD reduce production qualifiedName -> IDENTIFIER 
-- On MINUSEQUAL reduce production qualifiedName -> IDENTIFIER 
-- On MINUS reduce production qualifiedName -> IDENTIFIER 
-- On LTHAN reduce production qualifiedName -> IDENTIFIER 
-- On LSHIFTEQUAL reduce production qualifiedName -> IDENTIFIER 
-- On LSHIFT reduce production qualifiedName -> IDENTIFIER 
-- On LPAR reduce production qualifiedName -> IDENTIFIER 
-- On LOGSHIFTEQUAL reduce production qualifiedName -> IDENTIFIER 
-- On LOGSHIFT reduce production qualifiedName -> IDENTIFIER 
-- On LETHAN reduce production qualifiedName -> IDENTIFIER 
-- On LBRAC reduce production qualifiedName -> IDENTIFIER 
-- On INSTANCEOF reduce production qualifiedName -> IDENTIFIER 
-- On INCREMENT reduce production qualifiedName -> IDENTIFIER 
-- On IDENTIFIER reduce production qualifiedName -> IDENTIFIER 
-- On GTHAN reduce production qualifiedName -> IDENTIFIER 
-- On GETHAN reduce production qualifiedName -> IDENTIFIER 
-- On EQUAL reduce production qualifiedName -> IDENTIFIER 
-- On DOT reduce production qualifiedName -> IDENTIFIER 
-- On DIVEQUAL reduce production qualifiedName -> IDENTIFIER 
-- On DIV reduce production qualifiedName -> IDENTIFIER 
-- On DIM reduce production qualifiedName -> IDENTIFIER 
-- On DECREMENT reduce production qualifiedName -> IDENTIFIER 
-- On BOR reduce production qualifiedName -> IDENTIFIER 
-- On BAND reduce production qualifiedName -> IDENTIFIER 
-- On ASSIGN reduce production qualifiedName -> IDENTIFIER 
-- On ANDEQUAL reduce production qualifiedName -> IDENTIFIER 
-- On AND reduce production qualifiedName -> IDENTIFIER 

State 250:
labelStmt -> IDENTIFIER COL . [ error WHILE VOID TRY THROW THIS SYNCHRONIZED SWITCH SUPER STRLIT SHORT SEMI RETURN RCURL PLUS NULLLIT NOT NEW MINUS LPAR LONG LCURL INTLIT INT INCREMENT IF IDENTIFIER FOR FLOATLIT FLOAT FINAL ELSE DOUBLELIT DOUBLE DO DECREMENT CONTINUE CHARLIT CHAR BYTE BREAK BOOLEANLIT BOOLEAN BNOT ASSERT ]
-- On error reduce production labelStmt -> IDENTIFIER COL 
-- On WHILE reduce production labelStmt -> IDENTIFIER COL 
-- On VOID reduce production labelStmt -> IDENTIFIER COL 
-- On TRY reduce production labelStmt -> IDENTIFIER COL 
-- On THROW reduce production labelStmt -> IDENTIFIER COL 
-- On THIS reduce production labelStmt -> IDENTIFIER COL 
-- On SYNCHRONIZED reduce production labelStmt -> IDENTIFIER COL 
-- On SWITCH reduce production labelStmt -> IDENTIFIER COL 
-- On SUPER reduce production labelStmt -> IDENTIFIER COL 
-- On STRLIT reduce production labelStmt -> IDENTIFIER COL 
-- On SHORT reduce production labelStmt -> IDENTIFIER COL 
-- On SEMI reduce production labelStmt -> IDENTIFIER COL 
-- On RETURN reduce production labelStmt -> IDENTIFIER COL 
-- On RCURL reduce production labelStmt -> IDENTIFIER COL 
-- On PLUS reduce production labelStmt -> IDENTIFIER COL 
-- On NULLLIT reduce production labelStmt -> IDENTIFIER COL 
-- On NOT reduce production labelStmt -> IDENTIFIER COL 
-- On NEW reduce production labelStmt -> IDENTIFIER COL 
-- On MINUS reduce production labelStmt -> IDENTIFIER COL 
-- On LPAR reduce production labelStmt -> IDENTIFIER COL 
-- On LONG reduce production labelStmt -> IDENTIFIER COL 
-- On LCURL reduce production labelStmt -> IDENTIFIER COL 
-- On INTLIT reduce production labelStmt -> IDENTIFIER COL 
-- On INT reduce production labelStmt -> IDENTIFIER COL 
-- On INCREMENT reduce production labelStmt -> IDENTIFIER COL 
-- On IF reduce production labelStmt -> IDENTIFIER COL 
-- On IDENTIFIER reduce production labelStmt -> IDENTIFIER COL 
-- On FOR reduce production labelStmt -> IDENTIFIER COL 
-- On FLOATLIT reduce production labelStmt -> IDENTIFIER COL 
-- On FLOAT reduce production labelStmt -> IDENTIFIER COL 
-- On FINAL reduce production labelStmt -> IDENTIFIER COL 
-- On ELSE reduce production labelStmt -> IDENTIFIER COL 
-- On DOUBLELIT reduce production labelStmt -> IDENTIFIER COL 
-- On DOUBLE reduce production labelStmt -> IDENTIFIER COL 
-- On DO reduce production labelStmt -> IDENTIFIER COL 
-- On DECREMENT reduce production labelStmt -> IDENTIFIER COL 
-- On CONTINUE reduce production labelStmt -> IDENTIFIER COL 
-- On CHARLIT reduce production labelStmt -> IDENTIFIER COL 
-- On CHAR reduce production labelStmt -> IDENTIFIER COL 
-- On BYTE reduce production labelStmt -> IDENTIFIER COL 
-- On BREAK reduce production labelStmt -> IDENTIFIER COL 
-- On BOOLEANLIT reduce production labelStmt -> IDENTIFIER COL 
-- On BOOLEAN reduce production labelStmt -> IDENTIFIER COL 
-- On BNOT reduce production labelStmt -> IDENTIFIER COL 
-- On ASSERT reduce production labelStmt -> IDENTIFIER COL 

State 251:
iterStmt -> FOR . LPAR forInit forExpr forIncr RPAR statement [ error WHILE VOID TRY THROW THIS SYNCHRONIZED SWITCH SUPER STRLIT SHORT SEMI RETURN RCURL PLUS NULLLIT NOT NEW MINUS LPAR LONG LCURL INTLIT INT INCREMENT IF IDENTIFIER FOR FLOATLIT FLOAT FINAL ELSE DOUBLELIT DOUBLE DO DECREMENT CONTINUE CHARLIT CHAR BYTE BREAK BOOLEANLIT BOOLEAN BNOT ASSERT ]
iterStmt -> FOR . LPAR forInit forExpr RPAR statement [ error WHILE VOID TRY THROW THIS SYNCHRONIZED SWITCH SUPER STRLIT SHORT SEMI RETURN RCURL PLUS NULLLIT NOT NEW MINUS LPAR LONG LCURL INTLIT INT INCREMENT IF IDENTIFIER FOR FLOATLIT FLOAT FINAL ELSE DOUBLELIT DOUBLE DO DECREMENT CONTINUE CHARLIT CHAR BYTE BREAK BOOLEANLIT BOOLEAN BNOT ASSERT ]
iterStmt -> FOR . LPAR forVarOpt COL expression RPAR statement [ error WHILE VOID TRY THROW THIS SYNCHRONIZED SWITCH SUPER STRLIT SHORT SEMI RETURN RCURL PLUS NULLLIT NOT NEW MINUS LPAR LONG LCURL INTLIT INT INCREMENT IF IDENTIFIER FOR FLOATLIT FLOAT FINAL ELSE DOUBLELIT DOUBLE DO DECREMENT CONTINUE CHARLIT CHAR BYTE BREAK BOOLEANLIT BOOLEAN BNOT ASSERT ]
-- On LPAR shift to state 252

State 252:
iterStmt -> FOR LPAR . forInit forExpr forIncr RPAR statement [ error WHILE VOID TRY THROW THIS SYNCHRONIZED SWITCH SUPER STRLIT SHORT SEMI RETURN RCURL PLUS NULLLIT NOT NEW MINUS LPAR LONG LCURL INTLIT INT INCREMENT IF IDENTIFIER FOR FLOATLIT FLOAT FINAL ELSE DOUBLELIT DOUBLE DO DECREMENT CONTINUE CHARLIT CHAR BYTE BREAK BOOLEANLIT BOOLEAN BNOT ASSERT ]
iterStmt -> FOR LPAR . forInit forExpr RPAR statement [ error WHILE VOID TRY THROW THIS SYNCHRONIZED SWITCH SUPER STRLIT SHORT SEMI RETURN RCURL PLUS NULLLIT NOT NEW MINUS LPAR LONG LCURL INTLIT INT INCREMENT IF IDENTIFIER FOR FLOATLIT FLOAT FINAL ELSE DOUBLELIT DOUBLE DO DECREMENT CONTINUE CHARLIT CHAR BYTE BREAK BOOLEANLIT BOOLEAN BNOT ASSERT ]
iterStmt -> FOR LPAR . forVarOpt COL expression RPAR statement [ error WHILE VOID TRY THROW THIS SYNCHRONIZED SWITCH SUPER STRLIT SHORT SEMI RETURN RCURL PLUS NULLLIT NOT NEW MINUS LPAR LONG LCURL INTLIT INT INCREMENT IF IDENTIFIER FOR FLOATLIT FLOAT FINAL ELSE DOUBLELIT DOUBLE DO DECREMENT CONTINUE CHARLIT CHAR BYTE BREAK BOOLEANLIT BOOLEAN BNOT ASSERT ]
-- On VOID shift to state 6
-- On SHORT shift to state 10
-- On SEMI shift to state 253
-- On LONG shift to state 15
-- On INT shift to state 16
-- On IDENTIFIER shift to state 17
-- On FLOAT shift to state 18
-- On FINAL shift to state 254
-- On DOUBLE shift to state 19
-- On CHAR shift to state 20
-- On BYTE shift to state 21
-- On BOOLEAN shift to state 22
-- On typeSpecifier shift to state 265
-- On typeName shift to state 130
-- On qualifiedName shift to state 134
-- On primitiveType shift to state 137
-- On localVariableDeclStmt shift to state 269
-- On forVarOpt shift to state 270
-- On forInit shift to state 412

State 253:
forInit -> SEMI . [ error VOID THIS SUPER STRLIT SHORT SEMI PLUS NULLLIT NOT NEW MINUS LPAR LONG INTLIT INT INCREMENT IDENTIFIER FLOATLIT FLOAT DOUBLELIT DOUBLE DECREMENT CHARLIT CHAR BYTE BOOLEANLIT BOOLEAN BNOT ]
-- On error reduce production forInit -> SEMI 
-- On VOID reduce production forInit -> SEMI 
-- On THIS reduce production forInit -> SEMI 
-- On SUPER reduce production forInit -> SEMI 
-- On STRLIT reduce production forInit -> SEMI 
-- On SHORT reduce production forInit -> SEMI 
-- On SEMI reduce production forInit -> SEMI 
-- On PLUS reduce production forInit -> SEMI 
-- On NULLLIT reduce production forInit -> SEMI 
-- On NOT reduce production forInit -> SEMI 
-- On NEW reduce production forInit -> SEMI 
-- On MINUS reduce production forInit -> SEMI 
-- On LPAR reduce production forInit -> SEMI 
-- On LONG reduce production forInit -> SEMI 
-- On INTLIT reduce production forInit -> SEMI 
-- On INT reduce production forInit -> SEMI 
-- On INCREMENT reduce production forInit -> SEMI 
-- On IDENTIFIER reduce production forInit -> SEMI 
-- On FLOATLIT reduce production forInit -> SEMI 
-- On FLOAT reduce production forInit -> SEMI 
-- On DOUBLELIT reduce production forInit -> SEMI 
-- On DOUBLE reduce production forInit -> SEMI 
-- On DECREMENT reduce production forInit -> SEMI 
-- On CHARLIT reduce production forInit -> SEMI 
-- On CHAR reduce production forInit -> SEMI 
-- On BYTE reduce production forInit -> SEMI 
-- On BOOLEANLIT reduce production forInit -> SEMI 
-- On BOOLEAN reduce production forInit -> SEMI 
-- On BNOT reduce production forInit -> SEMI 

State 254:
localVariableDeclStmt -> FINAL . typeSpecifier variableDeclarators SEMI [ error WHILE VOID TRY THROW THIS SYNCHRONIZED SWITCH SUPER STRLIT SHORT SEMI RETURN RCURL PLUS NULLLIT NOT NEW MINUS LPAR LONG LCURL INTLIT INT INCREMENT IF IDENTIFIER FOR FLOATLIT FLOAT FINAL DOUBLELIT DOUBLE DO DECREMENT CONTINUE CHARLIT CHAR BYTE BREAK BOOLEANLIT BOOLEAN BNOT ASSERT ]
-- On VOID shift to state 6
-- On SHORT shift to state 10
-- On LONG shift to state 15
-- On INT shift to state 16
-- On IDENTIFIER shift to state 17
-- On FLOAT shift to state 18
-- On DOUBLE shift to state 19
-- On CHAR shift to state 20
-- On BYTE shift to state 21
-- On BOOLEAN shift to state 22
-- On typeSpecifier shift to state 255
-- On typeName shift to state 130
-- On qualifiedName shift to state 134
-- On primitiveType shift to state 137

State 255:
localVariableDeclStmt -> FINAL typeSpecifier . variableDeclarators SEMI [ error WHILE VOID TRY THROW THIS SYNCHRONIZED SWITCH SUPER STRLIT SHORT SEMI RETURN RCURL PLUS NULLLIT NOT NEW MINUS LPAR LONG LCURL INTLIT INT INCREMENT IF IDENTIFIER FOR FLOATLIT FLOAT FINAL DOUBLELIT DOUBLE DO DECREMENT CONTINUE CHARLIT CHAR BYTE BREAK BOOLEANLIT BOOLEAN BNOT ASSERT ]
-- On IDENTIFIER shift to state 256
-- On variableDeclarators shift to state 257
-- On variableDeclarator shift to state 264
-- On declaratorName shift to state 261

State 256:
declaratorName -> IDENTIFIER . [ SEMI COMM ASSIGN ]
-- On SEMI reduce production declaratorName -> IDENTIFIER 
-- On COMM reduce production declaratorName -> IDENTIFIER 
-- On ASSIGN reduce production declaratorName -> IDENTIFIER 

State 257:
localVariableDeclStmt -> FINAL typeSpecifier variableDeclarators . SEMI [ error WHILE VOID TRY THROW THIS SYNCHRONIZED SWITCH SUPER STRLIT SHORT SEMI RETURN RCURL PLUS NULLLIT NOT NEW MINUS LPAR LONG LCURL INTLIT INT INCREMENT IF IDENTIFIER FOR FLOATLIT FLOAT FINAL DOUBLELIT DOUBLE DO DECREMENT CONTINUE CHARLIT CHAR BYTE BREAK BOOLEANLIT BOOLEAN BNOT ASSERT ]
variableDeclarators -> variableDeclarators . COMM variableDeclarator [ SEMI COMM ]
-- On SEMI shift to state 258
-- On COMM shift to state 259

State 258:
localVariableDeclStmt -> FINAL typeSpecifier variableDeclarators SEMI . [ error WHILE VOID TRY THROW THIS SYNCHRONIZED SWITCH SUPER STRLIT SHORT SEMI RETURN RCURL PLUS NULLLIT NOT NEW MINUS LPAR LONG LCURL INTLIT INT INCREMENT IF IDENTIFIER FOR FLOATLIT FLOAT FINAL DOUBLELIT DOUBLE DO DECREMENT CONTINUE CHARLIT CHAR BYTE BREAK BOOLEANLIT BOOLEAN BNOT ASSERT ]
-- On error reduce production localVariableDeclStmt -> FINAL typeSpecifier variableDeclarators SEMI 
-- On WHILE reduce production localVariableDeclStmt -> FINAL typeSpecifier variableDeclarators SEMI 
-- On VOID reduce production localVariableDeclStmt -> FINAL typeSpecifier variableDeclarators SEMI 
-- On TRY reduce production localVariableDeclStmt -> FINAL typeSpecifier variableDeclarators SEMI 
-- On THROW reduce production localVariableDeclStmt -> FINAL typeSpecifier variableDeclarators SEMI 
-- On THIS reduce production localVariableDeclStmt -> FINAL typeSpecifier variableDeclarators SEMI 
-- On SYNCHRONIZED reduce production localVariableDeclStmt -> FINAL typeSpecifier variableDeclarators SEMI 
-- On SWITCH reduce production localVariableDeclStmt -> FINAL typeSpecifier variableDeclarators SEMI 
-- On SUPER reduce production localVariableDeclStmt -> FINAL typeSpecifier variableDeclarators SEMI 
-- On STRLIT reduce production localVariableDeclStmt -> FINAL typeSpecifier variableDeclarators SEMI 
-- On SHORT reduce production localVariableDeclStmt -> FINAL typeSpecifier variableDeclarators SEMI 
-- On SEMI reduce production localVariableDeclStmt -> FINAL typeSpecifier variableDeclarators SEMI 
-- On RETURN reduce production localVariableDeclStmt -> FINAL typeSpecifier variableDeclarators SEMI 
-- On RCURL reduce production localVariableDeclStmt -> FINAL typeSpecifier variableDeclarators SEMI 
-- On PLUS reduce production localVariableDeclStmt -> FINAL typeSpecifier variableDeclarators SEMI 
-- On NULLLIT reduce production localVariableDeclStmt -> FINAL typeSpecifier variableDeclarators SEMI 
-- On NOT reduce production localVariableDeclStmt -> FINAL typeSpecifier variableDeclarators SEMI 
-- On NEW reduce production localVariableDeclStmt -> FINAL typeSpecifier variableDeclarators SEMI 
-- On MINUS reduce production localVariableDeclStmt -> FINAL typeSpecifier variableDeclarators SEMI 
-- On LPAR reduce production localVariableDeclStmt -> FINAL typeSpecifier variableDeclarators SEMI 
-- On LONG reduce production localVariableDeclStmt -> FINAL typeSpecifier variableDeclarators SEMI 
-- On LCURL reduce production localVariableDeclStmt -> FINAL typeSpecifier variableDeclarators SEMI 
-- On INTLIT reduce production localVariableDeclStmt -> FINAL typeSpecifier variableDeclarators SEMI 
-- On INT reduce production localVariableDeclStmt -> FINAL typeSpecifier variableDeclarators SEMI 
-- On INCREMENT reduce production localVariableDeclStmt -> FINAL typeSpecifier variableDeclarators SEMI 
-- On IF reduce production localVariableDeclStmt -> FINAL typeSpecifier variableDeclarators SEMI 
-- On IDENTIFIER reduce production localVariableDeclStmt -> FINAL typeSpecifier variableDeclarators SEMI 
-- On FOR reduce production localVariableDeclStmt -> FINAL typeSpecifier variableDeclarators SEMI 
-- On FLOATLIT reduce production localVariableDeclStmt -> FINAL typeSpecifier variableDeclarators SEMI 
-- On FLOAT reduce production localVariableDeclStmt -> FINAL typeSpecifier variableDeclarators SEMI 
-- On FINAL reduce production localVariableDeclStmt -> FINAL typeSpecifier variableDeclarators SEMI 
-- On DOUBLELIT reduce production localVariableDeclStmt -> FINAL typeSpecifier variableDeclarators SEMI 
-- On DOUBLE reduce production localVariableDeclStmt -> FINAL typeSpecifier variableDeclarators SEMI 
-- On DO reduce production localVariableDeclStmt -> FINAL typeSpecifier variableDeclarators SEMI 
-- On DECREMENT reduce production localVariableDeclStmt -> FINAL typeSpecifier variableDeclarators SEMI 
-- On CONTINUE reduce production localVariableDeclStmt -> FINAL typeSpecifier variableDeclarators SEMI 
-- On CHARLIT reduce production localVariableDeclStmt -> FINAL typeSpecifier variableDeclarators SEMI 
-- On CHAR reduce production localVariableDeclStmt -> FINAL typeSpecifier variableDeclarators SEMI 
-- On BYTE reduce production localVariableDeclStmt -> FINAL typeSpecifier variableDeclarators SEMI 
-- On BREAK reduce production localVariableDeclStmt -> FINAL typeSpecifier variableDeclarators SEMI 
-- On BOOLEANLIT reduce production localVariableDeclStmt -> FINAL typeSpecifier variableDeclarators SEMI 
-- On BOOLEAN reduce production localVariableDeclStmt -> FINAL typeSpecifier variableDeclarators SEMI 
-- On BNOT reduce production localVariableDeclStmt -> FINAL typeSpecifier variableDeclarators SEMI 
-- On ASSERT reduce production localVariableDeclStmt -> FINAL typeSpecifier variableDeclarators SEMI 

State 259:
variableDeclarators -> variableDeclarators COMM . variableDeclarator [ SEMI COMM ]
-- On IDENTIFIER shift to state 256
-- On variableDeclarator shift to state 260
-- On declaratorName shift to state 261

State 260:
variableDeclarators -> variableDeclarators COMM variableDeclarator . [ SEMI COMM ]
-- On SEMI reduce production variableDeclarators -> variableDeclarators COMM variableDeclarator 
-- On COMM reduce production variableDeclarators -> variableDeclarators COMM variableDeclarator 

State 261:
variableDeclarator -> declaratorName . [ SEMI COMM ]
variableDeclarator -> declaratorName . ASSIGN variableInitializer [ SEMI COMM ]
-- On ASSIGN shift to state 262
-- On SEMI reduce production variableDeclarator -> declaratorName 
-- On COMM reduce production variableDeclarator -> declaratorName 

State 262:
variableDeclarator -> declaratorName ASSIGN . variableInitializer [ SEMI COMM ]
-- On error shift to state 3
-- On VOID shift to state 6
-- On THIS shift to state 7
-- On SUPER shift to state 8
-- On STRLIT shift to state 9
-- On SHORT shift to state 10
-- On PLUS shift to state 11
-- On NULLLIT shift to state 12
-- On NOT shift to state 13
-- On NEW shift to state 14
-- On MINUS shift to state 26
-- On LPAR shift to state 27
-- On LONG shift to state 15
-- On LCURL shift to state 107
-- On INTLIT shift to state 28
-- On INT shift to state 16
-- On INCREMENT shift to state 29
-- On IDENTIFIER shift to state 17
-- On FLOATLIT shift to state 31
-- On FLOAT shift to state 18
-- On DOUBLELIT shift to state 32
-- On DOUBLE shift to state 19
-- On DECREMENT shift to state 33
-- On CHARLIT shift to state 34
-- On CHAR shift to state 20
-- On BYTE shift to state 21
-- On BOOLEANLIT shift to state 35
-- On BOOLEAN shift to state 22
-- On BNOT shift to state 36
-- On variableInitializer shift to state 263
-- On unaryExpression shift to state 44
-- On specialName shift to state 38
-- On shiftExpression shift to state 58
-- On relationalExpression shift to state 79
-- On realPostfixExpression shift to state 39
-- On qualifiedName shift to state 42
-- On primitiveType shift to state 61
-- On primaryExpression shift to state 64
-- On postfixExpression shift to state 65
-- On plainNewAllocationExpression shift to state 68
-- On notJustName shift to state 69
-- On newAllocationExpression shift to state 72
-- On multiplicativeExpression shift to state 73
-- On methodCall shift to state 75
-- On methodAccess shift to state 76
-- On logicalUnaryOperator shift to state 83
-- On logicalUnaryExpression shift to state 85
-- On inclusiveOrExpression shift to state 90
-- On fieldAccess shift to state 86
-- On expression shift to state 110
-- On exclusiveOrExpression shift to state 111
-- On equalityExpression shift to state 94
-- On conditionalOrExpression shift to state 112
-- On conditionalExpression shift to state 151
-- On conditionalAndExpression shift to state 117
-- On complexPrimaryNoParenthesis shift to state 87
-- On complexPrimary shift to state 88
-- On classAllocationExpression shift to state 100
-- On castExpression shift to state 103
-- On assignmentExpression shift to state 152
-- On arrayAllocationExpression shift to state 104
-- On arrayAccess shift to state 120
-- On arithmeticUnaryOperator shift to state 121
-- On andExpression shift to state 123
-- On additiveExpression shift to state 140

State 263:
variableDeclarator -> declaratorName ASSIGN variableInitializer . [ SEMI COMM ]
-- On SEMI reduce production variableDeclarator -> declaratorName ASSIGN variableInitializer 
-- On COMM reduce production variableDeclarator -> declaratorName ASSIGN variableInitializer 

State 264:
variableDeclarators -> variableDeclarator . [ SEMI COMM ]
-- On SEMI reduce production variableDeclarators -> variableDeclarator 
-- On COMM reduce production variableDeclarators -> variableDeclarator 

State 265:
forVarOpt -> typeSpecifier . IDENTIFIER [ COL ]
localVariableDeclStmt -> typeSpecifier . variableDeclarators SEMI [ error VOID THIS SUPER STRLIT SHORT SEMI PLUS NULLLIT NOT NEW MINUS LPAR LONG INTLIT INT INCREMENT IDENTIFIER FLOATLIT FLOAT DOUBLELIT DOUBLE DECREMENT CHARLIT CHAR BYTE BOOLEANLIT BOOLEAN BNOT ]
-- On IDENTIFIER shift to state 266
-- On variableDeclarators shift to state 267
-- On variableDeclarator shift to state 264
-- On declaratorName shift to state 261

State 266:
declaratorName -> IDENTIFIER . [ SEMI COMM ASSIGN ]
forVarOpt -> typeSpecifier IDENTIFIER . [ COL ]
-- On SEMI reduce production declaratorName -> IDENTIFIER 
-- On COMM reduce production declaratorName -> IDENTIFIER 
-- On COL reduce production forVarOpt -> typeSpecifier IDENTIFIER 
-- On ASSIGN reduce production declaratorName -> IDENTIFIER 

State 267:
localVariableDeclStmt -> typeSpecifier variableDeclarators . SEMI [ error WHILE VOID TRY THROW THIS SYNCHRONIZED SWITCH SUPER STRLIT SHORT SEMI RETURN RCURL PLUS NULLLIT NOT NEW MINUS LPAR LONG LCURL INTLIT INT INCREMENT IF IDENTIFIER FOR FLOATLIT FLOAT FINAL DOUBLELIT DOUBLE DO DECREMENT CONTINUE CHARLIT CHAR BYTE BREAK BOOLEANLIT BOOLEAN BNOT ASSERT ]
variableDeclarators -> variableDeclarators . COMM variableDeclarator [ SEMI COMM ]
-- On SEMI shift to state 268
-- On COMM shift to state 259

State 268:
localVariableDeclStmt -> typeSpecifier variableDeclarators SEMI . [ error WHILE VOID TRY THROW THIS SYNCHRONIZED SWITCH SUPER STRLIT SHORT SEMI RETURN RCURL PLUS NULLLIT NOT NEW MINUS LPAR LONG LCURL INTLIT INT INCREMENT IF IDENTIFIER FOR FLOATLIT FLOAT FINAL DOUBLELIT DOUBLE DO DECREMENT CONTINUE CHARLIT CHAR BYTE BREAK BOOLEANLIT BOOLEAN BNOT ASSERT ]
-- On error reduce production localVariableDeclStmt -> typeSpecifier variableDeclarators SEMI 
-- On WHILE reduce production localVariableDeclStmt -> typeSpecifier variableDeclarators SEMI 
-- On VOID reduce production localVariableDeclStmt -> typeSpecifier variableDeclarators SEMI 
-- On TRY reduce production localVariableDeclStmt -> typeSpecifier variableDeclarators SEMI 
-- On THROW reduce production localVariableDeclStmt -> typeSpecifier variableDeclarators SEMI 
-- On THIS reduce production localVariableDeclStmt -> typeSpecifier variableDeclarators SEMI 
-- On SYNCHRONIZED reduce production localVariableDeclStmt -> typeSpecifier variableDeclarators SEMI 
-- On SWITCH reduce production localVariableDeclStmt -> typeSpecifier variableDeclarators SEMI 
-- On SUPER reduce production localVariableDeclStmt -> typeSpecifier variableDeclarators SEMI 
-- On STRLIT reduce production localVariableDeclStmt -> typeSpecifier variableDeclarators SEMI 
-- On SHORT reduce production localVariableDeclStmt -> typeSpecifier variableDeclarators SEMI 
-- On SEMI reduce production localVariableDeclStmt -> typeSpecifier variableDeclarators SEMI 
-- On RETURN reduce production localVariableDeclStmt -> typeSpecifier variableDeclarators SEMI 
-- On RCURL reduce production localVariableDeclStmt -> typeSpecifier variableDeclarators SEMI 
-- On PLUS reduce production localVariableDeclStmt -> typeSpecifier variableDeclarators SEMI 
-- On NULLLIT reduce production localVariableDeclStmt -> typeSpecifier variableDeclarators SEMI 
-- On NOT reduce production localVariableDeclStmt -> typeSpecifier variableDeclarators SEMI 
-- On NEW reduce production localVariableDeclStmt -> typeSpecifier variableDeclarators SEMI 
-- On MINUS reduce production localVariableDeclStmt -> typeSpecifier variableDeclarators SEMI 
-- On LPAR reduce production localVariableDeclStmt -> typeSpecifier variableDeclarators SEMI 
-- On LONG reduce production localVariableDeclStmt -> typeSpecifier variableDeclarators SEMI 
-- On LCURL reduce production localVariableDeclStmt -> typeSpecifier variableDeclarators SEMI 
-- On INTLIT reduce production localVariableDeclStmt -> typeSpecifier variableDeclarators SEMI 
-- On INT reduce production localVariableDeclStmt -> typeSpecifier variableDeclarators SEMI 
-- On INCREMENT reduce production localVariableDeclStmt -> typeSpecifier variableDeclarators SEMI 
-- On IF reduce production localVariableDeclStmt -> typeSpecifier variableDeclarators SEMI 
-- On IDENTIFIER reduce production localVariableDeclStmt -> typeSpecifier variableDeclarators SEMI 
-- On FOR reduce production localVariableDeclStmt -> typeSpecifier variableDeclarators SEMI 
-- On FLOATLIT reduce production localVariableDeclStmt -> typeSpecifier variableDeclarators SEMI 
-- On FLOAT reduce production localVariableDeclStmt -> typeSpecifier variableDeclarators SEMI 
-- On FINAL reduce production localVariableDeclStmt -> typeSpecifier variableDeclarators SEMI 
-- On DOUBLELIT reduce production localVariableDeclStmt -> typeSpecifier variableDeclarators SEMI 
-- On DOUBLE reduce production localVariableDeclStmt -> typeSpecifier variableDeclarators SEMI 
-- On DO reduce production localVariableDeclStmt -> typeSpecifier variableDeclarators SEMI 
-- On DECREMENT reduce production localVariableDeclStmt -> typeSpecifier variableDeclarators SEMI 
-- On CONTINUE reduce production localVariableDeclStmt -> typeSpecifier variableDeclarators SEMI 
-- On CHARLIT reduce production localVariableDeclStmt -> typeSpecifier variableDeclarators SEMI 
-- On CHAR reduce production localVariableDeclStmt -> typeSpecifier variableDeclarators SEMI 
-- On BYTE reduce production localVariableDeclStmt -> typeSpecifier variableDeclarators SEMI 
-- On BREAK reduce production localVariableDeclStmt -> typeSpecifier variableDeclarators SEMI 
-- On BOOLEANLIT reduce production localVariableDeclStmt -> typeSpecifier variableDeclarators SEMI 
-- On BOOLEAN reduce production localVariableDeclStmt -> typeSpecifier variableDeclarators SEMI 
-- On BNOT reduce production localVariableDeclStmt -> typeSpecifier variableDeclarators SEMI 
-- On ASSERT reduce production localVariableDeclStmt -> typeSpecifier variableDeclarators SEMI 

State 269:
forInit -> localVariableDeclStmt . [ error VOID THIS SUPER STRLIT SHORT SEMI PLUS NULLLIT NOT NEW MINUS LPAR LONG INTLIT INT INCREMENT IDENTIFIER FLOATLIT FLOAT DOUBLELIT DOUBLE DECREMENT CHARLIT CHAR BYTE BOOLEANLIT BOOLEAN BNOT ]
-- On error reduce production forInit -> localVariableDeclStmt 
-- On VOID reduce production forInit -> localVariableDeclStmt 
-- On THIS reduce production forInit -> localVariableDeclStmt 
-- On SUPER reduce production forInit -> localVariableDeclStmt 
-- On STRLIT reduce production forInit -> localVariableDeclStmt 
-- On SHORT reduce production forInit -> localVariableDeclStmt 
-- On SEMI reduce production forInit -> localVariableDeclStmt 
-- On PLUS reduce production forInit -> localVariableDeclStmt 
-- On NULLLIT reduce production forInit -> localVariableDeclStmt 
-- On NOT reduce production forInit -> localVariableDeclStmt 
-- On NEW reduce production forInit -> localVariableDeclStmt 
-- On MINUS reduce production forInit -> localVariableDeclStmt 
-- On LPAR reduce production forInit -> localVariableDeclStmt 
-- On LONG reduce production forInit -> localVariableDeclStmt 
-- On INTLIT reduce production forInit -> localVariableDeclStmt 
-- On INT reduce production forInit -> localVariableDeclStmt 
-- On INCREMENT reduce production forInit -> localVariableDeclStmt 
-- On IDENTIFIER reduce production forInit -> localVariableDeclStmt 
-- On FLOATLIT reduce production forInit -> localVariableDeclStmt 
-- On FLOAT reduce production forInit -> localVariableDeclStmt 
-- On DOUBLELIT reduce production forInit -> localVariableDeclStmt 
-- On DOUBLE reduce production forInit -> localVariableDeclStmt 
-- On DECREMENT reduce production forInit -> localVariableDeclStmt 
-- On CHARLIT reduce production forInit -> localVariableDeclStmt 
-- On CHAR reduce production forInit -> localVariableDeclStmt 
-- On BYTE reduce production forInit -> localVariableDeclStmt 
-- On BOOLEANLIT reduce production forInit -> localVariableDeclStmt 
-- On BOOLEAN reduce production forInit -> localVariableDeclStmt 
-- On BNOT reduce production forInit -> localVariableDeclStmt 

State 270:
iterStmt -> FOR LPAR forVarOpt . COL expression RPAR statement [ error WHILE VOID TRY THROW THIS SYNCHRONIZED SWITCH SUPER STRLIT SHORT SEMI RETURN RCURL PLUS NULLLIT NOT NEW MINUS LPAR LONG LCURL INTLIT INT INCREMENT IF IDENTIFIER FOR FLOATLIT FLOAT FINAL ELSE DOUBLELIT DOUBLE DO DECREMENT CONTINUE CHARLIT CHAR BYTE BREAK BOOLEANLIT BOOLEAN BNOT ASSERT ]
-- On COL shift to state 271

State 271:
iterStmt -> FOR LPAR forVarOpt COL . expression RPAR statement [ error WHILE VOID TRY THROW THIS SYNCHRONIZED SWITCH SUPER STRLIT SHORT SEMI RETURN RCURL PLUS NULLLIT NOT NEW MINUS LPAR LONG LCURL INTLIT INT INCREMENT IF IDENTIFIER FOR FLOATLIT FLOAT FINAL ELSE DOUBLELIT DOUBLE DO DECREMENT CONTINUE CHARLIT CHAR BYTE BREAK BOOLEANLIT BOOLEAN BNOT ASSERT ]
-- On error shift to state 3
-- On VOID shift to state 6
-- On THIS shift to state 7
-- On SUPER shift to state 8
-- On STRLIT shift to state 9
-- On SHORT shift to state 10
-- On PLUS shift to state 11
-- On NULLLIT shift to state 12
-- On NOT shift to state 13
-- On NEW shift to state 14
-- On MINUS shift to state 26
-- On LPAR shift to state 27
-- On LONG shift to state 15
-- On INTLIT shift to state 28
-- On INT shift to state 16
-- On INCREMENT shift to state 29
-- On IDENTIFIER shift to state 17
-- On FLOATLIT shift to state 31
-- On FLOAT shift to state 18
-- On DOUBLELIT shift to state 32
-- On DOUBLE shift to state 19
-- On DECREMENT shift to state 33
-- On CHARLIT shift to state 34
-- On CHAR shift to state 20
-- On BYTE shift to state 21
-- On BOOLEANLIT shift to state 35
-- On BOOLEAN shift to state 22
-- On BNOT shift to state 36
-- On unaryExpression shift to state 44
-- On specialName shift to state 38
-- On shiftExpression shift to state 58
-- On relationalExpression shift to state 79
-- On realPostfixExpression shift to state 39
-- On qualifiedName shift to state 42
-- On primitiveType shift to state 61
-- On primaryExpression shift to state 64
-- On postfixExpression shift to state 65
-- On plainNewAllocationExpression shift to state 68
-- On notJustName shift to state 69
-- On newAllocationExpression shift to state 72
-- On multiplicativeExpression shift to state 73
-- On methodCall shift to state 75
-- On methodAccess shift to state 76
-- On logicalUnaryOperator shift to state 83
-- On logicalUnaryExpression shift to state 85
-- On inclusiveOrExpression shift to state 90
-- On fieldAccess shift to state 86
-- On expression shift to state 272
-- On exclusiveOrExpression shift to state 111
-- On equalityExpression shift to state 94
-- On conditionalOrExpression shift to state 112
-- On conditionalExpression shift to state 151
-- On conditionalAndExpression shift to state 117
-- On complexPrimaryNoParenthesis shift to state 87
-- On complexPrimary shift to state 88
-- On classAllocationExpression shift to state 100
-- On castExpression shift to state 103
-- On assignmentExpression shift to state 152
-- On arrayAllocationExpression shift to state 104
-- On arrayAccess shift to state 120
-- On arithmeticUnaryOperator shift to state 121
-- On andExpression shift to state 123
-- On additiveExpression shift to state 140

State 272:
iterStmt -> FOR LPAR forVarOpt COL expression . RPAR statement [ error WHILE VOID TRY THROW THIS SYNCHRONIZED SWITCH SUPER STRLIT SHORT SEMI RETURN RCURL PLUS NULLLIT NOT NEW MINUS LPAR LONG LCURL INTLIT INT INCREMENT IF IDENTIFIER FOR FLOATLIT FLOAT FINAL ELSE DOUBLELIT DOUBLE DO DECREMENT CONTINUE CHARLIT CHAR BYTE BREAK BOOLEANLIT BOOLEAN BNOT ASSERT ]
-- On RPAR shift to state 273

State 273:
iterStmt -> FOR LPAR forVarOpt COL expression RPAR . statement [ error WHILE VOID TRY THROW THIS SYNCHRONIZED SWITCH SUPER STRLIT SHORT SEMI RETURN RCURL PLUS NULLLIT NOT NEW MINUS LPAR LONG LCURL INTLIT INT INCREMENT IF IDENTIFIER FOR FLOATLIT FLOAT FINAL ELSE DOUBLELIT DOUBLE DO DECREMENT CONTINUE CHARLIT CHAR BYTE BREAK BOOLEANLIT BOOLEAN BNOT ASSERT ]
-- On error shift to state 3
-- On WHILE shift to state 4
-- On VOID shift to state 6
-- On TRY shift to state 208
-- On THROW shift to state 210
-- On THIS shift to state 7
-- On SYNCHRONIZED shift to state 213
-- On SWITCH shift to state 217
-- On SUPER shift to state 8
-- On STRLIT shift to state 9
-- On SHORT shift to state 10
-- On SEMI shift to state 238
-- On RETURN shift to state 239
-- On PLUS shift to state 11
-- On NULLLIT shift to state 12
-- On NOT shift to state 13
-- On NEW shift to state 14
-- On MINUS shift to state 26
-- On LPAR shift to state 27
-- On LONG shift to state 15
-- On LCURL shift to state 243
-- On INTLIT shift to state 28
-- On INT shift to state 16
-- On INCREMENT shift to state 29
-- On IF shift to state 245
-- On IDENTIFIER shift to state 249
-- On FOR shift to state 251
-- On FLOATLIT shift to state 31
-- On FLOAT shift to state 18
-- On DOUBLELIT shift to state 32
-- On DOUBLE shift to state 19
-- On DO shift to state 274
-- On DECREMENT shift to state 33
-- On CONTINUE shift to state 387
-- On CHARLIT shift to state 34
-- On CHAR shift to state 20
-- On BYTE shift to state 21
-- On BREAK shift to state 391
-- On BOOLEANLIT shift to state 35
-- On BOOLEAN shift to state 22
-- On BNOT shift to state 36
-- On ASSERT shift to state 395
-- On unaryExpression shift to state 44
-- On statement shift to state 401
-- On specialName shift to state 38
-- On shiftExpression shift to state 58
-- On selectStmt shift to state 402
-- On relationalExpression shift to state 79
-- On realPostfixExpression shift to state 39
-- On qualifiedName shift to state 42
-- On primitiveType shift to state 61
-- On primaryExpression shift to state 64
-- On postfixExpression shift to state 65
-- On plainNewAllocationExpression shift to state 68
-- On notJustName shift to state 69
-- On newAllocationExpression shift to state 72
-- On multiplicativeExpression shift to state 73
-- On methodCall shift to state 75
-- On methodAccess shift to state 76
-- On logicalUnaryOperator shift to state 83
-- On logicalUnaryExpression shift to state 85
-- On labelStmt shift to state 403
-- On jumpStmt shift to state 404
-- On iterStmt shift to state 405
-- On inclusiveOrExpression shift to state 90
-- On guardingStmt shift to state 406
-- On fieldAccess shift to state 86
-- On expressionStmt shift to state 407
-- On expression shift to state 357
-- On exclusiveOrExpression shift to state 111
-- On equalityExpression shift to state 94
-- On emptyStmt shift to state 409
-- On conditionalOrExpression shift to state 112
-- On conditionalExpression shift to state 151
-- On conditionalAndExpression shift to state 117
-- On complexPrimaryNoParenthesis shift to state 87
-- On complexPrimary shift to state 88
-- On classAllocationExpression shift to state 100
-- On castExpression shift to state 103
-- On block shift to state 410
-- On assignmentExpression shift to state 152
-- On assertStmt shift to state 411
-- On arrayAllocationExpression shift to state 104
-- On arrayAccess shift to state 120
-- On arithmeticUnaryOperator shift to state 121
-- On andExpression shift to state 123
-- On additiveExpression shift to state 140

State 274:
iterStmt -> DO . statement WHILE LPAR expression RPAR SEMI [ error WHILE VOID TRY THROW THIS SYNCHRONIZED SWITCH SUPER STRLIT SHORT SEMI RETURN RCURL PLUS NULLLIT NOT NEW MINUS LPAR LONG LCURL INTLIT INT INCREMENT IF IDENTIFIER FOR FLOATLIT FLOAT FINAL ELSE DOUBLELIT DOUBLE DO DECREMENT CONTINUE CHARLIT CHAR BYTE BREAK BOOLEANLIT BOOLEAN BNOT ASSERT ]
-- On error shift to state 3
-- On WHILE shift to state 275
-- On VOID shift to state 6
-- On TRY shift to state 279
-- On THROW shift to state 296
-- On THIS shift to state 7
-- On SYNCHRONIZED shift to state 299
-- On SWITCH shift to state 303
-- On SUPER shift to state 8
-- On STRLIT shift to state 9
-- On SHORT shift to state 10
-- On SEMI shift to state 312
-- On RETURN shift to state 313
-- On PLUS shift to state 11
-- On NULLLIT shift to state 12
-- On NOT shift to state 13
-- On NEW shift to state 14
-- On MINUS shift to state 26
-- On LPAR shift to state 27
-- On LONG shift to state 15
-- On LCURL shift to state 209
-- On INTLIT shift to state 28
-- On INT shift to state 16
-- On INCREMENT shift to state 29
-- On IF shift to state 317
-- On IDENTIFIER shift to state 321
-- On FOR shift to state 323
-- On FLOATLIT shift to state 31
-- On FLOAT shift to state 18
-- On DOUBLELIT shift to state 32
-- On DOUBLE shift to state 19
-- On DO shift to state 329
-- On DECREMENT shift to state 33
-- On CONTINUE shift to state 330
-- On CHARLIT shift to state 34
-- On CHAR shift to state 20
-- On BYTE shift to state 21
-- On BREAK shift to state 334
-- On BOOLEANLIT shift to state 35
-- On BOOLEAN shift to state 22
-- On BNOT shift to state 36
-- On ASSERT shift to state 338
-- On unaryExpression shift to state 44
-- On statement shift to state 381
-- On specialName shift to state 38
-- On shiftExpression shift to state 58
-- On selectStmt shift to state 350
-- On relationalExpression shift to state 79
-- On realPostfixExpression shift to state 39
-- On qualifiedName shift to state 42
-- On primitiveType shift to state 61
-- On primaryExpression shift to state 64
-- On postfixExpression shift to state 65
-- On plainNewAllocationExpression shift to state 68
-- On notJustName shift to state 69
-- On newAllocationExpression shift to state 72
-- On multiplicativeExpression shift to state 73
-- On methodCall shift to state 75
-- On methodAccess shift to state 76
-- On logicalUnaryOperator shift to state 83
-- On logicalUnaryExpression shift to state 85
-- On labelStmt shift to state 351
-- On jumpStmt shift to state 352
-- On iterStmt shift to state 353
-- On inclusiveOrExpression shift to state 90
-- On guardingStmt shift to state 354
-- On fieldAccess shift to state 86
-- On expressionStmt shift to state 355
-- On expression shift to state 357
-- On exclusiveOrExpression shift to state 111
-- On equalityExpression shift to state 94
-- On emptyStmt shift to state 358
-- On conditionalOrExpression shift to state 112
-- On conditionalExpression shift to state 151
-- On conditionalAndExpression shift to state 117
-- On complexPrimaryNoParenthesis shift to state 87
-- On complexPrimary shift to state 88
-- On classAllocationExpression shift to state 100
-- On castExpression shift to state 103
-- On block shift to state 359
-- On assignmentExpression shift to state 152
-- On assertStmt shift to state 360
-- On arrayAllocationExpression shift to state 104
-- On arrayAccess shift to state 120
-- On arithmeticUnaryOperator shift to state 121
-- On andExpression shift to state 123
-- On additiveExpression shift to state 140

State 275:
iterStmt -> WHILE . LPAR expression RPAR statement [ WHILE ELSE ]
-- On LPAR shift to state 276

State 276:
iterStmt -> WHILE LPAR . expression RPAR statement [ WHILE ELSE ]
-- On error shift to state 3
-- On VOID shift to state 6
-- On THIS shift to state 7
-- On SUPER shift to state 8
-- On STRLIT shift to state 9
-- On SHORT shift to state 10
-- On PLUS shift to state 11
-- On NULLLIT shift to state 12
-- On NOT shift to state 13
-- On NEW shift to state 14
-- On MINUS shift to state 26
-- On LPAR shift to state 27
-- On LONG shift to state 15
-- On INTLIT shift to state 28
-- On INT shift to state 16
-- On INCREMENT shift to state 29
-- On IDENTIFIER shift to state 17
-- On FLOATLIT shift to state 31
-- On FLOAT shift to state 18
-- On DOUBLELIT shift to state 32
-- On DOUBLE shift to state 19
-- On DECREMENT shift to state 33
-- On CHARLIT shift to state 34
-- On CHAR shift to state 20
-- On BYTE shift to state 21
-- On BOOLEANLIT shift to state 35
-- On BOOLEAN shift to state 22
-- On BNOT shift to state 36
-- On unaryExpression shift to state 44
-- On specialName shift to state 38
-- On shiftExpression shift to state 58
-- On relationalExpression shift to state 79
-- On realPostfixExpression shift to state 39
-- On qualifiedName shift to state 42
-- On primitiveType shift to state 61
-- On primaryExpression shift to state 64
-- On postfixExpression shift to state 65
-- On plainNewAllocationExpression shift to state 68
-- On notJustName shift to state 69
-- On newAllocationExpression shift to state 72
-- On multiplicativeExpression shift to state 73
-- On methodCall shift to state 75
-- On methodAccess shift to state 76
-- On logicalUnaryOperator shift to state 83
-- On logicalUnaryExpression shift to state 85
-- On inclusiveOrExpression shift to state 90
-- On fieldAccess shift to state 86
-- On expression shift to state 277
-- On exclusiveOrExpression shift to state 111
-- On equalityExpression shift to state 94
-- On conditionalOrExpression shift to state 112
-- On conditionalExpression shift to state 151
-- On conditionalAndExpression shift to state 117
-- On complexPrimaryNoParenthesis shift to state 87
-- On complexPrimary shift to state 88
-- On classAllocationExpression shift to state 100
-- On castExpression shift to state 103
-- On assignmentExpression shift to state 152
-- On arrayAllocationExpression shift to state 104
-- On arrayAccess shift to state 120
-- On arithmeticUnaryOperator shift to state 121
-- On andExpression shift to state 123
-- On additiveExpression shift to state 140

State 277:
iterStmt -> WHILE LPAR expression . RPAR statement [ WHILE ELSE ]
-- On RPAR shift to state 278

State 278:
iterStmt -> WHILE LPAR expression RPAR . statement [ WHILE ELSE ]
-- On error shift to state 3
-- On WHILE shift to state 275
-- On VOID shift to state 6
-- On TRY shift to state 279
-- On THROW shift to state 296
-- On THIS shift to state 7
-- On SYNCHRONIZED shift to state 299
-- On SWITCH shift to state 303
-- On SUPER shift to state 8
-- On STRLIT shift to state 9
-- On SHORT shift to state 10
-- On SEMI shift to state 312
-- On RETURN shift to state 313
-- On PLUS shift to state 11
-- On NULLLIT shift to state 12
-- On NOT shift to state 13
-- On NEW shift to state 14
-- On MINUS shift to state 26
-- On LPAR shift to state 27
-- On LONG shift to state 15
-- On LCURL shift to state 209
-- On INTLIT shift to state 28
-- On INT shift to state 16
-- On INCREMENT shift to state 29
-- On IF shift to state 317
-- On IDENTIFIER shift to state 321
-- On FOR shift to state 323
-- On FLOATLIT shift to state 31
-- On FLOAT shift to state 18
-- On DOUBLELIT shift to state 32
-- On DOUBLE shift to state 19
-- On DO shift to state 329
-- On DECREMENT shift to state 33
-- On CONTINUE shift to state 330
-- On CHARLIT shift to state 34
-- On CHAR shift to state 20
-- On BYTE shift to state 21
-- On BREAK shift to state 334
-- On BOOLEANLIT shift to state 35
-- On BOOLEAN shift to state 22
-- On BNOT shift to state 36
-- On ASSERT shift to state 338
-- On unaryExpression shift to state 44
-- On statement shift to state 380
-- On specialName shift to state 38
-- On shiftExpression shift to state 58
-- On selectStmt shift to state 350
-- On relationalExpression shift to state 79
-- On realPostfixExpression shift to state 39
-- On qualifiedName shift to state 42
-- On primitiveType shift to state 61
-- On primaryExpression shift to state 64
-- On postfixExpression shift to state 65
-- On plainNewAllocationExpression shift to state 68
-- On notJustName shift to state 69
-- On newAllocationExpression shift to state 72
-- On multiplicativeExpression shift to state 73
-- On methodCall shift to state 75
-- On methodAccess shift to state 76
-- On logicalUnaryOperator shift to state 83
-- On logicalUnaryExpression shift to state 85
-- On labelStmt shift to state 351
-- On jumpStmt shift to state 352
-- On iterStmt shift to state 353
-- On inclusiveOrExpression shift to state 90
-- On guardingStmt shift to state 354
-- On fieldAccess shift to state 86
-- On expressionStmt shift to state 355
-- On expression shift to state 357
-- On exclusiveOrExpression shift to state 111
-- On equalityExpression shift to state 94
-- On emptyStmt shift to state 358
-- On conditionalOrExpression shift to state 112
-- On conditionalExpression shift to state 151
-- On conditionalAndExpression shift to state 117
-- On complexPrimaryNoParenthesis shift to state 87
-- On complexPrimary shift to state 88
-- On classAllocationExpression shift to state 100
-- On castExpression shift to state 103
-- On block shift to state 359
-- On assignmentExpression shift to state 152
-- On assertStmt shift to state 360
-- On arrayAllocationExpression shift to state 104
-- On arrayAccess shift to state 120
-- On arithmeticUnaryOperator shift to state 121
-- On andExpression shift to state 123
-- On additiveExpression shift to state 140

State 279:
guardingStmt -> TRY . block finally [ WHILE ELSE ]
guardingStmt -> TRY . block catches [ WHILE ELSE ]
guardingStmt -> TRY . block catches finally [ WHILE ELSE ]
-- On LCURL shift to state 209
-- On block shift to state 280

State 280:
guardingStmt -> TRY block . finally [ WHILE ELSE ]
guardingStmt -> TRY block . catches [ WHILE ELSE ]
guardingStmt -> TRY block . catches finally [ WHILE ELSE ]
-- On FINALLY shift to state 281
-- On CATCH shift to state 283
-- On finally shift to state 289
-- On catches shift to state 290
-- On catchHeader shift to state 292
-- On catch shift to state 295

State 281:
finally -> FINALLY . block [ WHILE ELSE ]
-- On LCURL shift to state 209
-- On block shift to state 282

State 282:
finally -> FINALLY block . [ WHILE ELSE ]
-- On WHILE reduce production finally -> FINALLY block 
-- On ELSE reduce production finally -> FINALLY block 

State 283:
catchHeader -> CATCH . LPAR typeSpecifier IDENTIFIER RPAR [ LCURL ]
catchHeader -> CATCH . LPAR typeSpecifier RPAR [ LCURL ]
-- On LPAR shift to state 284

State 284:
catchHeader -> CATCH LPAR . typeSpecifier IDENTIFIER RPAR [ LCURL ]
catchHeader -> CATCH LPAR . typeSpecifier RPAR [ LCURL ]
-- On VOID shift to state 6
-- On SHORT shift to state 10
-- On LONG shift to state 15
-- On INT shift to state 16
-- On IDENTIFIER shift to state 17
-- On FLOAT shift to state 18
-- On DOUBLE shift to state 19
-- On CHAR shift to state 20
-- On BYTE shift to state 21
-- On BOOLEAN shift to state 22
-- On typeSpecifier shift to state 285
-- On typeName shift to state 130
-- On qualifiedName shift to state 134
-- On primitiveType shift to state 137

State 285:
catchHeader -> CATCH LPAR typeSpecifier . IDENTIFIER RPAR [ LCURL ]
catchHeader -> CATCH LPAR typeSpecifier . RPAR [ LCURL ]
-- On RPAR shift to state 286
-- On IDENTIFIER shift to state 287

State 286:
catchHeader -> CATCH LPAR typeSpecifier RPAR . [ LCURL ]
-- On LCURL reduce production catchHeader -> CATCH LPAR typeSpecifier RPAR 

State 287:
catchHeader -> CATCH LPAR typeSpecifier IDENTIFIER . RPAR [ LCURL ]
-- On RPAR shift to state 288

State 288:
catchHeader -> CATCH LPAR typeSpecifier IDENTIFIER RPAR . [ LCURL ]
-- On LCURL reduce production catchHeader -> CATCH LPAR typeSpecifier IDENTIFIER RPAR 

State 289:
guardingStmt -> TRY block finally . [ WHILE ELSE ]
-- On WHILE reduce production guardingStmt -> TRY block finally 
-- On ELSE reduce production guardingStmt -> TRY block finally 

State 290:
catches -> catches . catch [ WHILE FINALLY ELSE CATCH ]
guardingStmt -> TRY block catches . [ WHILE ELSE ]
guardingStmt -> TRY block catches . finally [ WHILE ELSE ]
-- On FINALLY shift to state 281
-- On CATCH shift to state 283
-- On finally shift to state 291
-- On catchHeader shift to state 292
-- On catch shift to state 294
-- On WHILE reduce production guardingStmt -> TRY block catches 
-- On ELSE reduce production guardingStmt -> TRY block catches 

State 291:
guardingStmt -> TRY block catches finally . [ WHILE ELSE ]
-- On WHILE reduce production guardingStmt -> TRY block catches finally 
-- On ELSE reduce production guardingStmt -> TRY block catches finally 

State 292:
catch -> catchHeader . block [ WHILE FINALLY ELSE CATCH ]
-- On LCURL shift to state 209
-- On block shift to state 293

State 293:
catch -> catchHeader block . [ WHILE FINALLY ELSE CATCH ]
-- On WHILE reduce production catch -> catchHeader block 
-- On FINALLY reduce production catch -> catchHeader block 
-- On ELSE reduce production catch -> catchHeader block 
-- On CATCH reduce production catch -> catchHeader block 

State 294:
catches -> catches catch . [ WHILE FINALLY ELSE CATCH ]
-- On WHILE reduce production catches -> catches catch 
-- On FINALLY reduce production catches -> catches catch 
-- On ELSE reduce production catches -> catches catch 
-- On CATCH reduce production catches -> catches catch 

State 295:
catches -> catch . [ WHILE FINALLY ELSE CATCH ]
-- On WHILE reduce production catches -> catch 
-- On FINALLY reduce production catches -> catch 
-- On ELSE reduce production catches -> catch 
-- On CATCH reduce production catches -> catch 

State 296:
jumpStmt -> THROW . expression SEMI [ WHILE ELSE ]
-- On error shift to state 3
-- On VOID shift to state 6
-- On THIS shift to state 7
-- On SUPER shift to state 8
-- On STRLIT shift to state 9
-- On SHORT shift to state 10
-- On PLUS shift to state 11
-- On NULLLIT shift to state 12
-- On NOT shift to state 13
-- On NEW shift to state 14
-- On MINUS shift to state 26
-- On LPAR shift to state 27
-- On LONG shift to state 15
-- On INTLIT shift to state 28
-- On INT shift to state 16
-- On INCREMENT shift to state 29
-- On IDENTIFIER shift to state 17
-- On FLOATLIT shift to state 31
-- On FLOAT shift to state 18
-- On DOUBLELIT shift to state 32
-- On DOUBLE shift to state 19
-- On DECREMENT shift to state 33
-- On CHARLIT shift to state 34
-- On CHAR shift to state 20
-- On BYTE shift to state 21
-- On BOOLEANLIT shift to state 35
-- On BOOLEAN shift to state 22
-- On BNOT shift to state 36
-- On unaryExpression shift to state 44
-- On specialName shift to state 38
-- On shiftExpression shift to state 58
-- On relationalExpression shift to state 79
-- On realPostfixExpression shift to state 39
-- On qualifiedName shift to state 42
-- On primitiveType shift to state 61
-- On primaryExpression shift to state 64
-- On postfixExpression shift to state 65
-- On plainNewAllocationExpression shift to state 68
-- On notJustName shift to state 69
-- On newAllocationExpression shift to state 72
-- On multiplicativeExpression shift to state 73
-- On methodCall shift to state 75
-- On methodAccess shift to state 76
-- On logicalUnaryOperator shift to state 83
-- On logicalUnaryExpression shift to state 85
-- On inclusiveOrExpression shift to state 90
-- On fieldAccess shift to state 86
-- On expression shift to state 297
-- On exclusiveOrExpression shift to state 111
-- On equalityExpression shift to state 94
-- On conditionalOrExpression shift to state 112
-- On conditionalExpression shift to state 151
-- On conditionalAndExpression shift to state 117
-- On complexPrimaryNoParenthesis shift to state 87
-- On complexPrimary shift to state 88
-- On classAllocationExpression shift to state 100
-- On castExpression shift to state 103
-- On assignmentExpression shift to state 152
-- On arrayAllocationExpression shift to state 104
-- On arrayAccess shift to state 120
-- On arithmeticUnaryOperator shift to state 121
-- On andExpression shift to state 123
-- On additiveExpression shift to state 140

State 297:
jumpStmt -> THROW expression . SEMI [ WHILE ELSE ]
-- On SEMI shift to state 298

State 298:
jumpStmt -> THROW expression SEMI . [ WHILE ELSE ]
-- On WHILE reduce production jumpStmt -> THROW expression SEMI 
-- On ELSE reduce production jumpStmt -> THROW expression SEMI 

State 299:
guardingStmt -> SYNCHRONIZED . LPAR expression RPAR statement [ WHILE ELSE ]
-- On LPAR shift to state 300

State 300:
guardingStmt -> SYNCHRONIZED LPAR . expression RPAR statement [ WHILE ELSE ]
-- On error shift to state 3
-- On VOID shift to state 6
-- On THIS shift to state 7
-- On SUPER shift to state 8
-- On STRLIT shift to state 9
-- On SHORT shift to state 10
-- On PLUS shift to state 11
-- On NULLLIT shift to state 12
-- On NOT shift to state 13
-- On NEW shift to state 14
-- On MINUS shift to state 26
-- On LPAR shift to state 27
-- On LONG shift to state 15
-- On INTLIT shift to state 28
-- On INT shift to state 16
-- On INCREMENT shift to state 29
-- On IDENTIFIER shift to state 17
-- On FLOATLIT shift to state 31
-- On FLOAT shift to state 18
-- On DOUBLELIT shift to state 32
-- On DOUBLE shift to state 19
-- On DECREMENT shift to state 33
-- On CHARLIT shift to state 34
-- On CHAR shift to state 20
-- On BYTE shift to state 21
-- On BOOLEANLIT shift to state 35
-- On BOOLEAN shift to state 22
-- On BNOT shift to state 36
-- On unaryExpression shift to state 44
-- On specialName shift to state 38
-- On shiftExpression shift to state 58
-- On relationalExpression shift to state 79
-- On realPostfixExpression shift to state 39
-- On qualifiedName shift to state 42
-- On primitiveType shift to state 61
-- On primaryExpression shift to state 64
-- On postfixExpression shift to state 65
-- On plainNewAllocationExpression shift to state 68
-- On notJustName shift to state 69
-- On newAllocationExpression shift to state 72
-- On multiplicativeExpression shift to state 73
-- On methodCall shift to state 75
-- On methodAccess shift to state 76
-- On logicalUnaryOperator shift to state 83
-- On logicalUnaryExpression shift to state 85
-- On inclusiveOrExpression shift to state 90
-- On fieldAccess shift to state 86
-- On expression shift to state 301
-- On exclusiveOrExpression shift to state 111
-- On equalityExpression shift to state 94
-- On conditionalOrExpression shift to state 112
-- On conditionalExpression shift to state 151
-- On conditionalAndExpression shift to state 117
-- On complexPrimaryNoParenthesis shift to state 87
-- On complexPrimary shift to state 88
-- On classAllocationExpression shift to state 100
-- On castExpression shift to state 103
-- On assignmentExpression shift to state 152
-- On arrayAllocationExpression shift to state 104
-- On arrayAccess shift to state 120
-- On arithmeticUnaryOperator shift to state 121
-- On andExpression shift to state 123
-- On additiveExpression shift to state 140

State 301:
guardingStmt -> SYNCHRONIZED LPAR expression . RPAR statement [ WHILE ELSE ]
-- On RPAR shift to state 302

State 302:
guardingStmt -> SYNCHRONIZED LPAR expression RPAR . statement [ WHILE ELSE ]
-- On error shift to state 3
-- On WHILE shift to state 275
-- On VOID shift to state 6
-- On TRY shift to state 279
-- On THROW shift to state 296
-- On THIS shift to state 7
-- On SYNCHRONIZED shift to state 299
-- On SWITCH shift to state 303
-- On SUPER shift to state 8
-- On STRLIT shift to state 9
-- On SHORT shift to state 10
-- On SEMI shift to state 312
-- On RETURN shift to state 313
-- On PLUS shift to state 11
-- On NULLLIT shift to state 12
-- On NOT shift to state 13
-- On NEW shift to state 14
-- On MINUS shift to state 26
-- On LPAR shift to state 27
-- On LONG shift to state 15
-- On LCURL shift to state 209
-- On INTLIT shift to state 28
-- On INT shift to state 16
-- On INCREMENT shift to state 29
-- On IF shift to state 317
-- On IDENTIFIER shift to state 321
-- On FOR shift to state 323
-- On FLOATLIT shift to state 31
-- On FLOAT shift to state 18
-- On DOUBLELIT shift to state 32
-- On DOUBLE shift to state 19
-- On DO shift to state 329
-- On DECREMENT shift to state 33
-- On CONTINUE shift to state 330
-- On CHARLIT shift to state 34
-- On CHAR shift to state 20
-- On BYTE shift to state 21
-- On BREAK shift to state 334
-- On BOOLEANLIT shift to state 35
-- On BOOLEAN shift to state 22
-- On BNOT shift to state 36
-- On ASSERT shift to state 338
-- On unaryExpression shift to state 44
-- On statement shift to state 379
-- On specialName shift to state 38
-- On shiftExpression shift to state 58
-- On selectStmt shift to state 350
-- On relationalExpression shift to state 79
-- On realPostfixExpression shift to state 39
-- On qualifiedName shift to state 42
-- On primitiveType shift to state 61
-- On primaryExpression shift to state 64
-- On postfixExpression shift to state 65
-- On plainNewAllocationExpression shift to state 68
-- On notJustName shift to state 69
-- On newAllocationExpression shift to state 72
-- On multiplicativeExpression shift to state 73
-- On methodCall shift to state 75
-- On methodAccess shift to state 76
-- On logicalUnaryOperator shift to state 83
-- On logicalUnaryExpression shift to state 85
-- On labelStmt shift to state 351
-- On jumpStmt shift to state 352
-- On iterStmt shift to state 353
-- On inclusiveOrExpression shift to state 90
-- On guardingStmt shift to state 354
-- On fieldAccess shift to state 86
-- On expressionStmt shift to state 355
-- On expression shift to state 357
-- On exclusiveOrExpression shift to state 111
-- On equalityExpression shift to state 94
-- On emptyStmt shift to state 358
-- On conditionalOrExpression shift to state 112
-- On conditionalExpression shift to state 151
-- On conditionalAndExpression shift to state 117
-- On complexPrimaryNoParenthesis shift to state 87
-- On complexPrimary shift to state 88
-- On classAllocationExpression shift to state 100
-- On castExpression shift to state 103
-- On block shift to state 359
-- On assignmentExpression shift to state 152
-- On assertStmt shift to state 360
-- On arrayAllocationExpression shift to state 104
-- On arrayAccess shift to state 120
-- On arithmeticUnaryOperator shift to state 121
-- On andExpression shift to state 123
-- On additiveExpression shift to state 140

State 303:
selectStmt -> SWITCH . LPAR expression RPAR switchBlock [ WHILE ELSE ]
-- On LPAR shift to state 304

State 304:
selectStmt -> SWITCH LPAR . expression RPAR switchBlock [ WHILE ELSE ]
-- On error shift to state 3
-- On VOID shift to state 6
-- On THIS shift to state 7
-- On SUPER shift to state 8
-- On STRLIT shift to state 9
-- On SHORT shift to state 10
-- On PLUS shift to state 11
-- On NULLLIT shift to state 12
-- On NOT shift to state 13
-- On NEW shift to state 14
-- On MINUS shift to state 26
-- On LPAR shift to state 27
-- On LONG shift to state 15
-- On INTLIT shift to state 28
-- On INT shift to state 16
-- On INCREMENT shift to state 29
-- On IDENTIFIER shift to state 17
-- On FLOATLIT shift to state 31
-- On FLOAT shift to state 18
-- On DOUBLELIT shift to state 32
-- On DOUBLE shift to state 19
-- On DECREMENT shift to state 33
-- On CHARLIT shift to state 34
-- On CHAR shift to state 20
-- On BYTE shift to state 21
-- On BOOLEANLIT shift to state 35
-- On BOOLEAN shift to state 22
-- On BNOT shift to state 36
-- On unaryExpression shift to state 44
-- On specialName shift to state 38
-- On shiftExpression shift to state 58
-- On relationalExpression shift to state 79
-- On realPostfixExpression shift to state 39
-- On qualifiedName shift to state 42
-- On primitiveType shift to state 61
-- On primaryExpression shift to state 64
-- On postfixExpression shift to state 65
-- On plainNewAllocationExpression shift to state 68
-- On notJustName shift to state 69
-- On newAllocationExpression shift to state 72
-- On multiplicativeExpression shift to state 73
-- On methodCall shift to state 75
-- On methodAccess shift to state 76
-- On logicalUnaryOperator shift to state 83
-- On logicalUnaryExpression shift to state 85
-- On inclusiveOrExpression shift to state 90
-- On fieldAccess shift to state 86
-- On expression shift to state 305
-- On exclusiveOrExpression shift to state 111
-- On equalityExpression shift to state 94
-- On conditionalOrExpression shift to state 112
-- On conditionalExpression shift to state 151
-- On conditionalAndExpression shift to state 117
-- On complexPrimaryNoParenthesis shift to state 87
-- On complexPrimary shift to state 88
-- On classAllocationExpression shift to state 100
-- On castExpression shift to state 103
-- On assignmentExpression shift to state 152
-- On arrayAllocationExpression shift to state 104
-- On arrayAccess shift to state 120
-- On arithmeticUnaryOperator shift to state 121
-- On andExpression shift to state 123
-- On additiveExpression shift to state 140

State 305:
selectStmt -> SWITCH LPAR expression . RPAR switchBlock [ WHILE ELSE ]
-- On RPAR shift to state 306

State 306:
selectStmt -> SWITCH LPAR expression RPAR . switchBlock [ WHILE ELSE ]
-- On LCURL shift to state 307
-- On switchBlock shift to state 311

State 307:
switchBlock -> LCURL . RCURL [ WHILE ELSE ]
switchBlock -> LCURL . switchBlockStmtGroups RCURL [ WHILE ELSE ]
-- On RCURL shift to state 308
-- On DEFAULT shift to state 223
-- On CASE shift to state 225
-- On switchLabels shift to state 229
-- On switchLabel shift to state 232
-- On switchBlockStmtGroups shift to state 309
-- On switchBlockStmtGroup shift to state 236

State 308:
switchBlock -> LCURL RCURL . [ WHILE ELSE ]
-- On WHILE reduce production switchBlock -> LCURL RCURL 
-- On ELSE reduce production switchBlock -> LCURL RCURL 

State 309:
switchBlock -> LCURL switchBlockStmtGroups . RCURL [ WHILE ELSE ]
switchBlockStmtGroups -> switchBlockStmtGroups . switchBlockStmtGroup [ RCURL DEFAULT CASE ]
-- On RCURL shift to state 310
-- On DEFAULT shift to state 223
-- On CASE shift to state 225
-- On switchLabels shift to state 229
-- On switchLabel shift to state 232
-- On switchBlockStmtGroup shift to state 235

State 310:
switchBlock -> LCURL switchBlockStmtGroups RCURL . [ WHILE ELSE ]
-- On WHILE reduce production switchBlock -> LCURL switchBlockStmtGroups RCURL 
-- On ELSE reduce production switchBlock -> LCURL switchBlockStmtGroups RCURL 

State 311:
selectStmt -> SWITCH LPAR expression RPAR switchBlock . [ WHILE ELSE ]
-- On WHILE reduce production selectStmt -> SWITCH LPAR expression RPAR switchBlock 
-- On ELSE reduce production selectStmt -> SWITCH LPAR expression RPAR switchBlock 

State 312:
emptyStmt -> SEMI . [ WHILE ELSE ]
-- On WHILE reduce production emptyStmt -> SEMI 
-- On ELSE reduce production emptyStmt -> SEMI 

State 313:
jumpStmt -> RETURN . expression SEMI [ WHILE ELSE ]
jumpStmt -> RETURN . SEMI [ WHILE ELSE ]
-- On error shift to state 3
-- On VOID shift to state 6
-- On THIS shift to state 7
-- On SUPER shift to state 8
-- On STRLIT shift to state 9
-- On SHORT shift to state 10
-- On SEMI shift to state 314
-- On PLUS shift to state 11
-- On NULLLIT shift to state 12
-- On NOT shift to state 13
-- On NEW shift to state 14
-- On MINUS shift to state 26
-- On LPAR shift to state 27
-- On LONG shift to state 15
-- On INTLIT shift to state 28
-- On INT shift to state 16
-- On INCREMENT shift to state 29
-- On IDENTIFIER shift to state 17
-- On FLOATLIT shift to state 31
-- On FLOAT shift to state 18
-- On DOUBLELIT shift to state 32
-- On DOUBLE shift to state 19
-- On DECREMENT shift to state 33
-- On CHARLIT shift to state 34
-- On CHAR shift to state 20
-- On BYTE shift to state 21
-- On BOOLEANLIT shift to state 35
-- On BOOLEAN shift to state 22
-- On BNOT shift to state 36
-- On unaryExpression shift to state 44
-- On specialName shift to state 38
-- On shiftExpression shift to state 58
-- On relationalExpression shift to state 79
-- On realPostfixExpression shift to state 39
-- On qualifiedName shift to state 42
-- On primitiveType shift to state 61
-- On primaryExpression shift to state 64
-- On postfixExpression shift to state 65
-- On plainNewAllocationExpression shift to state 68
-- On notJustName shift to state 69
-- On newAllocationExpression shift to state 72
-- On multiplicativeExpression shift to state 73
-- On methodCall shift to state 75
-- On methodAccess shift to state 76
-- On logicalUnaryOperator shift to state 83
-- On logicalUnaryExpression shift to state 85
-- On inclusiveOrExpression shift to state 90
-- On fieldAccess shift to state 86
-- On expression shift to state 315
-- On exclusiveOrExpression shift to state 111
-- On equalityExpression shift to state 94
-- On conditionalOrExpression shift to state 112
-- On conditionalExpression shift to state 151
-- On conditionalAndExpression shift to state 117
-- On complexPrimaryNoParenthesis shift to state 87
-- On complexPrimary shift to state 88
-- On classAllocationExpression shift to state 100
-- On castExpression shift to state 103
-- On assignmentExpression shift to state 152
-- On arrayAllocationExpression shift to state 104
-- On arrayAccess shift to state 120
-- On arithmeticUnaryOperator shift to state 121
-- On andExpression shift to state 123
-- On additiveExpression shift to state 140

State 314:
jumpStmt -> RETURN SEMI . [ WHILE ELSE ]
-- On WHILE reduce production jumpStmt -> RETURN SEMI 
-- On ELSE reduce production jumpStmt -> RETURN SEMI 

State 315:
jumpStmt -> RETURN expression . SEMI [ WHILE ELSE ]
-- On SEMI shift to state 316

State 316:
jumpStmt -> RETURN expression SEMI . [ WHILE ELSE ]
-- On WHILE reduce production jumpStmt -> RETURN expression SEMI 
-- On ELSE reduce production jumpStmt -> RETURN expression SEMI 

State 317:
selectStmt -> IF . LPAR expression RPAR statement [ WHILE ELSE ]
selectStmt -> IF . LPAR expression RPAR statement ELSE statement [ WHILE ELSE ]
-- On LPAR shift to state 318

State 318:
selectStmt -> IF LPAR . expression RPAR statement [ WHILE ELSE ]
selectStmt -> IF LPAR . expression RPAR statement ELSE statement [ WHILE ELSE ]
-- On error shift to state 3
-- On VOID shift to state 6
-- On THIS shift to state 7
-- On SUPER shift to state 8
-- On STRLIT shift to state 9
-- On SHORT shift to state 10
-- On PLUS shift to state 11
-- On NULLLIT shift to state 12
-- On NOT shift to state 13
-- On NEW shift to state 14
-- On MINUS shift to state 26
-- On LPAR shift to state 27
-- On LONG shift to state 15
-- On INTLIT shift to state 28
-- On INT shift to state 16
-- On INCREMENT shift to state 29
-- On IDENTIFIER shift to state 17
-- On FLOATLIT shift to state 31
-- On FLOAT shift to state 18
-- On DOUBLELIT shift to state 32
-- On DOUBLE shift to state 19
-- On DECREMENT shift to state 33
-- On CHARLIT shift to state 34
-- On CHAR shift to state 20
-- On BYTE shift to state 21
-- On BOOLEANLIT shift to state 35
-- On BOOLEAN shift to state 22
-- On BNOT shift to state 36
-- On unaryExpression shift to state 44
-- On specialName shift to state 38
-- On shiftExpression shift to state 58
-- On relationalExpression shift to state 79
-- On realPostfixExpression shift to state 39
-- On qualifiedName shift to state 42
-- On primitiveType shift to state 61
-- On primaryExpression shift to state 64
-- On postfixExpression shift to state 65
-- On plainNewAllocationExpression shift to state 68
-- On notJustName shift to state 69
-- On newAllocationExpression shift to state 72
-- On multiplicativeExpression shift to state 73
-- On methodCall shift to state 75
-- On methodAccess shift to state 76
-- On logicalUnaryOperator shift to state 83
-- On logicalUnaryExpression shift to state 85
-- On inclusiveOrExpression shift to state 90
-- On fieldAccess shift to state 86
-- On expression shift to state 319
-- On exclusiveOrExpression shift to state 111
-- On equalityExpression shift to state 94
-- On conditionalOrExpression shift to state 112
-- On conditionalExpression shift to state 151
-- On conditionalAndExpression shift to state 117
-- On complexPrimaryNoParenthesis shift to state 87
-- On complexPrimary shift to state 88
-- On classAllocationExpression shift to state 100
-- On castExpression shift to state 103
-- On assignmentExpression shift to state 152
-- On arrayAllocationExpression shift to state 104
-- On arrayAccess shift to state 120
-- On arithmeticUnaryOperator shift to state 121
-- On andExpression shift to state 123
-- On additiveExpression shift to state 140

State 319:
selectStmt -> IF LPAR expression . RPAR statement [ WHILE ELSE ]
selectStmt -> IF LPAR expression . RPAR statement ELSE statement [ WHILE ELSE ]
-- On RPAR shift to state 320

State 320:
selectStmt -> IF LPAR expression RPAR . statement [ WHILE ELSE ]
selectStmt -> IF LPAR expression RPAR . statement ELSE statement [ WHILE ELSE ]
-- On error shift to state 3
-- On WHILE shift to state 275
-- On VOID shift to state 6
-- On TRY shift to state 279
-- On THROW shift to state 296
-- On THIS shift to state 7
-- On SYNCHRONIZED shift to state 299
-- On SWITCH shift to state 303
-- On SUPER shift to state 8
-- On STRLIT shift to state 9
-- On SHORT shift to state 10
-- On SEMI shift to state 312
-- On RETURN shift to state 313
-- On PLUS shift to state 11
-- On NULLLIT shift to state 12
-- On NOT shift to state 13
-- On NEW shift to state 14
-- On MINUS shift to state 26
-- On LPAR shift to state 27
-- On LONG shift to state 15
-- On LCURL shift to state 209
-- On INTLIT shift to state 28
-- On INT shift to state 16
-- On INCREMENT shift to state 29
-- On IF shift to state 317
-- On IDENTIFIER shift to state 321
-- On FOR shift to state 323
-- On FLOATLIT shift to state 31
-- On FLOAT shift to state 18
-- On DOUBLELIT shift to state 32
-- On DOUBLE shift to state 19
-- On DO shift to state 329
-- On DECREMENT shift to state 33
-- On CONTINUE shift to state 330
-- On CHARLIT shift to state 34
-- On CHAR shift to state 20
-- On BYTE shift to state 21
-- On BREAK shift to state 334
-- On BOOLEANLIT shift to state 35
-- On BOOLEAN shift to state 22
-- On BNOT shift to state 36
-- On ASSERT shift to state 338
-- On unaryExpression shift to state 44
-- On statement shift to state 376
-- On specialName shift to state 38
-- On shiftExpression shift to state 58
-- On selectStmt shift to state 350
-- On relationalExpression shift to state 79
-- On realPostfixExpression shift to state 39
-- On qualifiedName shift to state 42
-- On primitiveType shift to state 61
-- On primaryExpression shift to state 64
-- On postfixExpression shift to state 65
-- On plainNewAllocationExpression shift to state 68
-- On notJustName shift to state 69
-- On newAllocationExpression shift to state 72
-- On multiplicativeExpression shift to state 73
-- On methodCall shift to state 75
-- On methodAccess shift to state 76
-- On logicalUnaryOperator shift to state 83
-- On logicalUnaryExpression shift to state 85
-- On labelStmt shift to state 351
-- On jumpStmt shift to state 352
-- On iterStmt shift to state 353
-- On inclusiveOrExpression shift to state 90
-- On guardingStmt shift to state 354
-- On fieldAccess shift to state 86
-- On expressionStmt shift to state 355
-- On expression shift to state 357
-- On exclusiveOrExpression shift to state 111
-- On equalityExpression shift to state 94
-- On emptyStmt shift to state 358
-- On conditionalOrExpression shift to state 112
-- On conditionalExpression shift to state 151
-- On conditionalAndExpression shift to state 117
-- On complexPrimaryNoParenthesis shift to state 87
-- On complexPrimary shift to state 88
-- On classAllocationExpression shift to state 100
-- On castExpression shift to state 103
-- On block shift to state 359
-- On assignmentExpression shift to state 152
-- On assertStmt shift to state 360
-- On arrayAllocationExpression shift to state 104
-- On arrayAccess shift to state 120
-- On arithmeticUnaryOperator shift to state 121
-- On andExpression shift to state 123
-- On additiveExpression shift to state 140

State 321:
labelStmt -> IDENTIFIER . COL [ WHILE ELSE ]
qualifiedName -> IDENTIFIER . [ XOREQUAL XOR SEMI RSHIFTEQUAL RSHIFT QM PLUS PEQUAL OREQUAL OR NEQUAL MULEQUAL MUL MODEQUAL MOD MINUSEQUAL MINUS LTHAN LSHIFTEQUAL LSHIFT LPAR LOGSHIFTEQUAL LOGSHIFT LETHAN LBRAC INSTANCEOF INCREMENT GTHAN GETHAN EQUAL DOT DIVEQUAL DIV DECREMENT BOR BAND ASSIGN ANDEQUAL AND ]
-- On COL shift to state 322
-- On XOREQUAL reduce production qualifiedName -> IDENTIFIER 
-- On XOR reduce production qualifiedName -> IDENTIFIER 
-- On SEMI reduce production qualifiedName -> IDENTIFIER 
-- On RSHIFTEQUAL reduce production qualifiedName -> IDENTIFIER 
-- On RSHIFT reduce production qualifiedName -> IDENTIFIER 
-- On QM reduce production qualifiedName -> IDENTIFIER 
-- On PLUS reduce production qualifiedName -> IDENTIFIER 
-- On PEQUAL reduce production qualifiedName -> IDENTIFIER 
-- On OREQUAL reduce production qualifiedName -> IDENTIFIER 
-- On OR reduce production qualifiedName -> IDENTIFIER 
-- On NEQUAL reduce production qualifiedName -> IDENTIFIER 
-- On MULEQUAL reduce production qualifiedName -> IDENTIFIER 
-- On MUL reduce production qualifiedName -> IDENTIFIER 
-- On MODEQUAL reduce production qualifiedName -> IDENTIFIER 
-- On MOD reduce production qualifiedName -> IDENTIFIER 
-- On MINUSEQUAL reduce production qualifiedName -> IDENTIFIER 
-- On MINUS reduce production qualifiedName -> IDENTIFIER 
-- On LTHAN reduce production qualifiedName -> IDENTIFIER 
-- On LSHIFTEQUAL reduce production qualifiedName -> IDENTIFIER 
-- On LSHIFT reduce production qualifiedName -> IDENTIFIER 
-- On LPAR reduce production qualifiedName -> IDENTIFIER 
-- On LOGSHIFTEQUAL reduce production qualifiedName -> IDENTIFIER 
-- On LOGSHIFT reduce production qualifiedName -> IDENTIFIER 
-- On LETHAN reduce production qualifiedName -> IDENTIFIER 
-- On LBRAC reduce production qualifiedName -> IDENTIFIER 
-- On INSTANCEOF reduce production qualifiedName -> IDENTIFIER 
-- On INCREMENT reduce production qualifiedName -> IDENTIFIER 
-- On GTHAN reduce production qualifiedName -> IDENTIFIER 
-- On GETHAN reduce production qualifiedName -> IDENTIFIER 
-- On EQUAL reduce production qualifiedName -> IDENTIFIER 
-- On DOT reduce production qualifiedName -> IDENTIFIER 
-- On DIVEQUAL reduce production qualifiedName -> IDENTIFIER 
-- On DIV reduce production qualifiedName -> IDENTIFIER 
-- On DECREMENT reduce production qualifiedName -> IDENTIFIER 
-- On BOR reduce production qualifiedName -> IDENTIFIER 
-- On BAND reduce production qualifiedName -> IDENTIFIER 
-- On ASSIGN reduce production qualifiedName -> IDENTIFIER 
-- On ANDEQUAL reduce production qualifiedName -> IDENTIFIER 
-- On AND reduce production qualifiedName -> IDENTIFIER 

State 322:
labelStmt -> IDENTIFIER COL . [ WHILE ELSE ]
-- On WHILE reduce production labelStmt -> IDENTIFIER COL 
-- On ELSE reduce production labelStmt -> IDENTIFIER COL 

State 323:
iterStmt -> FOR . LPAR forInit forExpr forIncr RPAR statement [ WHILE ELSE ]
iterStmt -> FOR . LPAR forInit forExpr RPAR statement [ WHILE ELSE ]
iterStmt -> FOR . LPAR forVarOpt COL expression RPAR statement [ WHILE ELSE ]
-- On LPAR shift to state 324

State 324:
iterStmt -> FOR LPAR . forInit forExpr forIncr RPAR statement [ WHILE ELSE ]
iterStmt -> FOR LPAR . forInit forExpr RPAR statement [ WHILE ELSE ]
iterStmt -> FOR LPAR . forVarOpt COL expression RPAR statement [ WHILE ELSE ]
-- On VOID shift to state 6
-- On SHORT shift to state 10
-- On SEMI shift to state 253
-- On LONG shift to state 15
-- On INT shift to state 16
-- On IDENTIFIER shift to state 17
-- On FLOAT shift to state 18
-- On FINAL shift to state 254
-- On DOUBLE shift to state 19
-- On CHAR shift to state 20
-- On BYTE shift to state 21
-- On BOOLEAN shift to state 22
-- On typeSpecifier shift to state 265
-- On typeName shift to state 130
-- On qualifiedName shift to state 134
-- On primitiveType shift to state 137
-- On localVariableDeclStmt shift to state 269
-- On forVarOpt shift to state 325
-- On forInit shift to state 362

State 325:
iterStmt -> FOR LPAR forVarOpt . COL expression RPAR statement [ WHILE ELSE ]
-- On COL shift to state 326

State 326:
iterStmt -> FOR LPAR forVarOpt COL . expression RPAR statement [ WHILE ELSE ]
-- On error shift to state 3
-- On VOID shift to state 6
-- On THIS shift to state 7
-- On SUPER shift to state 8
-- On STRLIT shift to state 9
-- On SHORT shift to state 10
-- On PLUS shift to state 11
-- On NULLLIT shift to state 12
-- On NOT shift to state 13
-- On NEW shift to state 14
-- On MINUS shift to state 26
-- On LPAR shift to state 27
-- On LONG shift to state 15
-- On INTLIT shift to state 28
-- On INT shift to state 16
-- On INCREMENT shift to state 29
-- On IDENTIFIER shift to state 17
-- On FLOATLIT shift to state 31
-- On FLOAT shift to state 18
-- On DOUBLELIT shift to state 32
-- On DOUBLE shift to state 19
-- On DECREMENT shift to state 33
-- On CHARLIT shift to state 34
-- On CHAR shift to state 20
-- On BYTE shift to state 21
-- On BOOLEANLIT shift to state 35
-- On BOOLEAN shift to state 22
-- On BNOT shift to state 36
-- On unaryExpression shift to state 44
-- On specialName shift to state 38
-- On shiftExpression shift to state 58
-- On relationalExpression shift to state 79
-- On realPostfixExpression shift to state 39
-- On qualifiedName shift to state 42
-- On primitiveType shift to state 61
-- On primaryExpression shift to state 64
-- On postfixExpression shift to state 65
-- On plainNewAllocationExpression shift to state 68
-- On notJustName shift to state 69
-- On newAllocationExpression shift to state 72
-- On multiplicativeExpression shift to state 73
-- On methodCall shift to state 75
-- On methodAccess shift to state 76
-- On logicalUnaryOperator shift to state 83
-- On logicalUnaryExpression shift to state 85
-- On inclusiveOrExpression shift to state 90
-- On fieldAccess shift to state 86
-- On expression shift to state 327
-- On exclusiveOrExpression shift to state 111
-- On equalityExpression shift to state 94
-- On conditionalOrExpression shift to state 112
-- On conditionalExpression shift to state 151
-- On conditionalAndExpression shift to state 117
-- On complexPrimaryNoParenthesis shift to state 87
-- On complexPrimary shift to state 88
-- On classAllocationExpression shift to state 100
-- On castExpression shift to state 103
-- On assignmentExpression shift to state 152
-- On arrayAllocationExpression shift to state 104
-- On arrayAccess shift to state 120
-- On arithmeticUnaryOperator shift to state 121
-- On andExpression shift to state 123
-- On additiveExpression shift to state 140

State 327:
iterStmt -> FOR LPAR forVarOpt COL expression . RPAR statement [ WHILE ELSE ]
-- On RPAR shift to state 328

State 328:
iterStmt -> FOR LPAR forVarOpt COL expression RPAR . statement [ WHILE ELSE ]
-- On error shift to state 3
-- On WHILE shift to state 275
-- On VOID shift to state 6
-- On TRY shift to state 279
-- On THROW shift to state 296
-- On THIS shift to state 7
-- On SYNCHRONIZED shift to state 299
-- On SWITCH shift to state 303
-- On SUPER shift to state 8
-- On STRLIT shift to state 9
-- On SHORT shift to state 10
-- On SEMI shift to state 312
-- On RETURN shift to state 313
-- On PLUS shift to state 11
-- On NULLLIT shift to state 12
-- On NOT shift to state 13
-- On NEW shift to state 14
-- On MINUS shift to state 26
-- On LPAR shift to state 27
-- On LONG shift to state 15
-- On LCURL shift to state 209
-- On INTLIT shift to state 28
-- On INT shift to state 16
-- On INCREMENT shift to state 29
-- On IF shift to state 317
-- On IDENTIFIER shift to state 321
-- On FOR shift to state 323
-- On FLOATLIT shift to state 31
-- On FLOAT shift to state 18
-- On DOUBLELIT shift to state 32
-- On DOUBLE shift to state 19
-- On DO shift to state 329
-- On DECREMENT shift to state 33
-- On CONTINUE shift to state 330
-- On CHARLIT shift to state 34
-- On CHAR shift to state 20
-- On BYTE shift to state 21
-- On BREAK shift to state 334
-- On BOOLEANLIT shift to state 35
-- On BOOLEAN shift to state 22
-- On BNOT shift to state 36
-- On ASSERT shift to state 338
-- On unaryExpression shift to state 44
-- On statement shift to state 361
-- On specialName shift to state 38
-- On shiftExpression shift to state 58
-- On selectStmt shift to state 350
-- On relationalExpression shift to state 79
-- On realPostfixExpression shift to state 39
-- On qualifiedName shift to state 42
-- On primitiveType shift to state 61
-- On primaryExpression shift to state 64
-- On postfixExpression shift to state 65
-- On plainNewAllocationExpression shift to state 68
-- On notJustName shift to state 69
-- On newAllocationExpression shift to state 72
-- On multiplicativeExpression shift to state 73
-- On methodCall shift to state 75
-- On methodAccess shift to state 76
-- On logicalUnaryOperator shift to state 83
-- On logicalUnaryExpression shift to state 85
-- On labelStmt shift to state 351
-- On jumpStmt shift to state 352
-- On iterStmt shift to state 353
-- On inclusiveOrExpression shift to state 90
-- On guardingStmt shift to state 354
-- On fieldAccess shift to state 86
-- On expressionStmt shift to state 355
-- On expression shift to state 357
-- On exclusiveOrExpression shift to state 111
-- On equalityExpression shift to state 94
-- On emptyStmt shift to state 358
-- On conditionalOrExpression shift to state 112
-- On conditionalExpression shift to state 151
-- On conditionalAndExpression shift to state 117
-- On complexPrimaryNoParenthesis shift to state 87
-- On complexPrimary shift to state 88
-- On classAllocationExpression shift to state 100
-- On castExpression shift to state 103
-- On block shift to state 359
-- On assignmentExpression shift to state 152
-- On assertStmt shift to state 360
-- On arrayAllocationExpression shift to state 104
-- On arrayAccess shift to state 120
-- On arithmeticUnaryOperator shift to state 121
-- On andExpression shift to state 123
-- On additiveExpression shift to state 140

State 329:
iterStmt -> DO . statement WHILE LPAR expression RPAR SEMI [ WHILE ELSE ]
-- On error shift to state 3
-- On WHILE shift to state 275
-- On VOID shift to state 6
-- On TRY shift to state 279
-- On THROW shift to state 296
-- On THIS shift to state 7
-- On SYNCHRONIZED shift to state 299
-- On SWITCH shift to state 303
-- On SUPER shift to state 8
-- On STRLIT shift to state 9
-- On SHORT shift to state 10
-- On SEMI shift to state 312
-- On RETURN shift to state 313
-- On PLUS shift to state 11
-- On NULLLIT shift to state 12
-- On NOT shift to state 13
-- On NEW shift to state 14
-- On MINUS shift to state 26
-- On LPAR shift to state 27
-- On LONG shift to state 15
-- On LCURL shift to state 209
-- On INTLIT shift to state 28
-- On INT shift to state 16
-- On INCREMENT shift to state 29
-- On IF shift to state 317
-- On IDENTIFIER shift to state 321
-- On FOR shift to state 323
-- On FLOATLIT shift to state 31
-- On FLOAT shift to state 18
-- On DOUBLELIT shift to state 32
-- On DOUBLE shift to state 19
-- On DO shift to state 329
-- On DECREMENT shift to state 33
-- On CONTINUE shift to state 330
-- On CHARLIT shift to state 34
-- On CHAR shift to state 20
-- On BYTE shift to state 21
-- On BREAK shift to state 334
-- On BOOLEANLIT shift to state 35
-- On BOOLEAN shift to state 22
-- On BNOT shift to state 36
-- On ASSERT shift to state 338
-- On unaryExpression shift to state 44
-- On statement shift to state 344
-- On specialName shift to state 38
-- On shiftExpression shift to state 58
-- On selectStmt shift to state 350
-- On relationalExpression shift to state 79
-- On realPostfixExpression shift to state 39
-- On qualifiedName shift to state 42
-- On primitiveType shift to state 61
-- On primaryExpression shift to state 64
-- On postfixExpression shift to state 65
-- On plainNewAllocationExpression shift to state 68
-- On notJustName shift to state 69
-- On newAllocationExpression shift to state 72
-- On multiplicativeExpression shift to state 73
-- On methodCall shift to state 75
-- On methodAccess shift to state 76
-- On logicalUnaryOperator shift to state 83
-- On logicalUnaryExpression shift to state 85
-- On labelStmt shift to state 351
-- On jumpStmt shift to state 352
-- On iterStmt shift to state 353
-- On inclusiveOrExpression shift to state 90
-- On guardingStmt shift to state 354
-- On fieldAccess shift to state 86
-- On expressionStmt shift to state 355
-- On expression shift to state 357
-- On exclusiveOrExpression shift to state 111
-- On equalityExpression shift to state 94
-- On emptyStmt shift to state 358
-- On conditionalOrExpression shift to state 112
-- On conditionalExpression shift to state 151
-- On conditionalAndExpression shift to state 117
-- On complexPrimaryNoParenthesis shift to state 87
-- On complexPrimary shift to state 88
-- On classAllocationExpression shift to state 100
-- On castExpression shift to state 103
-- On block shift to state 359
-- On assignmentExpression shift to state 152
-- On assertStmt shift to state 360
-- On arrayAllocationExpression shift to state 104
-- On arrayAccess shift to state 120
-- On arithmeticUnaryOperator shift to state 121
-- On andExpression shift to state 123
-- On additiveExpression shift to state 140

State 330:
jumpStmt -> CONTINUE . IDENTIFIER SEMI [ WHILE ELSE ]
jumpStmt -> CONTINUE . SEMI [ WHILE ELSE ]
-- On SEMI shift to state 331
-- On IDENTIFIER shift to state 332

State 331:
jumpStmt -> CONTINUE SEMI . [ WHILE ELSE ]
-- On WHILE reduce production jumpStmt -> CONTINUE SEMI 
-- On ELSE reduce production jumpStmt -> CONTINUE SEMI 

State 332:
jumpStmt -> CONTINUE IDENTIFIER . SEMI [ WHILE ELSE ]
-- On SEMI shift to state 333

State 333:
jumpStmt -> CONTINUE IDENTIFIER SEMI . [ WHILE ELSE ]
-- On WHILE reduce production jumpStmt -> CONTINUE IDENTIFIER SEMI 
-- On ELSE reduce production jumpStmt -> CONTINUE IDENTIFIER SEMI 

State 334:
jumpStmt -> BREAK . IDENTIFIER SEMI [ WHILE ELSE ]
jumpStmt -> BREAK . SEMI [ WHILE ELSE ]
-- On SEMI shift to state 335
-- On IDENTIFIER shift to state 336

State 335:
jumpStmt -> BREAK SEMI . [ WHILE ELSE ]
-- On WHILE reduce production jumpStmt -> BREAK SEMI 
-- On ELSE reduce production jumpStmt -> BREAK SEMI 

State 336:
jumpStmt -> BREAK IDENTIFIER . SEMI [ WHILE ELSE ]
-- On SEMI shift to state 337

State 337:
jumpStmt -> BREAK IDENTIFIER SEMI . [ WHILE ELSE ]
-- On WHILE reduce production jumpStmt -> BREAK IDENTIFIER SEMI 
-- On ELSE reduce production jumpStmt -> BREAK IDENTIFIER SEMI 

State 338:
assertStmt -> ASSERT . expression SEMI [ WHILE ELSE ]
assertStmt -> ASSERT . expression COL expression SEMI [ WHILE ELSE ]
-- On error shift to state 3
-- On VOID shift to state 6
-- On THIS shift to state 7
-- On SUPER shift to state 8
-- On STRLIT shift to state 9
-- On SHORT shift to state 10
-- On PLUS shift to state 11
-- On NULLLIT shift to state 12
-- On NOT shift to state 13
-- On NEW shift to state 14
-- On MINUS shift to state 26
-- On LPAR shift to state 27
-- On LONG shift to state 15
-- On INTLIT shift to state 28
-- On INT shift to state 16
-- On INCREMENT shift to state 29
-- On IDENTIFIER shift to state 17
-- On FLOATLIT shift to state 31
-- On FLOAT shift to state 18
-- On DOUBLELIT shift to state 32
-- On DOUBLE shift to state 19
-- On DECREMENT shift to state 33
-- On CHARLIT shift to state 34
-- On CHAR shift to state 20
-- On BYTE shift to state 21
-- On BOOLEANLIT shift to state 35
-- On BOOLEAN shift to state 22
-- On BNOT shift to state 36
-- On unaryExpression shift to state 44
-- On specialName shift to state 38
-- On shiftExpression shift to state 58
-- On relationalExpression shift to state 79
-- On realPostfixExpression shift to state 39
-- On qualifiedName shift to state 42
-- On primitiveType shift to state 61
-- On primaryExpression shift to state 64
-- On postfixExpression shift to state 65
-- On plainNewAllocationExpression shift to state 68
-- On notJustName shift to state 69
-- On newAllocationExpression shift to state 72
-- On multiplicativeExpression shift to state 73
-- On methodCall shift to state 75
-- On methodAccess shift to state 76
-- On logicalUnaryOperator shift to state 83
-- On logicalUnaryExpression shift to state 85
-- On inclusiveOrExpression shift to state 90
-- On fieldAccess shift to state 86
-- On expression shift to state 339
-- On exclusiveOrExpression shift to state 111
-- On equalityExpression shift to state 94
-- On conditionalOrExpression shift to state 112
-- On conditionalExpression shift to state 151
-- On conditionalAndExpression shift to state 117
-- On complexPrimaryNoParenthesis shift to state 87
-- On complexPrimary shift to state 88
-- On classAllocationExpression shift to state 100
-- On castExpression shift to state 103
-- On assignmentExpression shift to state 152
-- On arrayAllocationExpression shift to state 104
-- On arrayAccess shift to state 120
-- On arithmeticUnaryOperator shift to state 121
-- On andExpression shift to state 123
-- On additiveExpression shift to state 140

State 339:
assertStmt -> ASSERT expression . SEMI [ WHILE ELSE ]
assertStmt -> ASSERT expression . COL expression SEMI [ WHILE ELSE ]
-- On SEMI shift to state 340
-- On COL shift to state 341

State 340:
assertStmt -> ASSERT expression SEMI . [ WHILE ELSE ]
-- On WHILE reduce production assertStmt -> ASSERT expression SEMI 
-- On ELSE reduce production assertStmt -> ASSERT expression SEMI 

State 341:
assertStmt -> ASSERT expression COL . expression SEMI [ WHILE ELSE ]
-- On error shift to state 3
-- On VOID shift to state 6
-- On THIS shift to state 7
-- On SUPER shift to state 8
-- On STRLIT shift to state 9
-- On SHORT shift to state 10
-- On PLUS shift to state 11
-- On NULLLIT shift to state 12
-- On NOT shift to state 13
-- On NEW shift to state 14
-- On MINUS shift to state 26
-- On LPAR shift to state 27
-- On LONG shift to state 15
-- On INTLIT shift to state 28
-- On INT shift to state 16
-- On INCREMENT shift to state 29
-- On IDENTIFIER shift to state 17
-- On FLOATLIT shift to state 31
-- On FLOAT shift to state 18
-- On DOUBLELIT shift to state 32
-- On DOUBLE shift to state 19
-- On DECREMENT shift to state 33
-- On CHARLIT shift to state 34
-- On CHAR shift to state 20
-- On BYTE shift to state 21
-- On BOOLEANLIT shift to state 35
-- On BOOLEAN shift to state 22
-- On BNOT shift to state 36
-- On unaryExpression shift to state 44
-- On specialName shift to state 38
-- On shiftExpression shift to state 58
-- On relationalExpression shift to state 79
-- On realPostfixExpression shift to state 39
-- On qualifiedName shift to state 42
-- On primitiveType shift to state 61
-- On primaryExpression shift to state 64
-- On postfixExpression shift to state 65
-- On plainNewAllocationExpression shift to state 68
-- On notJustName shift to state 69
-- On newAllocationExpression shift to state 72
-- On multiplicativeExpression shift to state 73
-- On methodCall shift to state 75
-- On methodAccess shift to state 76
-- On logicalUnaryOperator shift to state 83
-- On logicalUnaryExpression shift to state 85
-- On inclusiveOrExpression shift to state 90
-- On fieldAccess shift to state 86
-- On expression shift to state 342
-- On exclusiveOrExpression shift to state 111
-- On equalityExpression shift to state 94
-- On conditionalOrExpression shift to state 112
-- On conditionalExpression shift to state 151
-- On conditionalAndExpression shift to state 117
-- On complexPrimaryNoParenthesis shift to state 87
-- On complexPrimary shift to state 88
-- On classAllocationExpression shift to state 100
-- On castExpression shift to state 103
-- On assignmentExpression shift to state 152
-- On arrayAllocationExpression shift to state 104
-- On arrayAccess shift to state 120
-- On arithmeticUnaryOperator shift to state 121
-- On andExpression shift to state 123
-- On additiveExpression shift to state 140

State 342:
assertStmt -> ASSERT expression COL expression . SEMI [ WHILE ELSE ]
-- On SEMI shift to state 343

State 343:
assertStmt -> ASSERT expression COL expression SEMI . [ WHILE ELSE ]
-- On WHILE reduce production assertStmt -> ASSERT expression COL expression SEMI 
-- On ELSE reduce production assertStmt -> ASSERT expression COL expression SEMI 

State 344:
iterStmt -> DO statement . WHILE LPAR expression RPAR SEMI [ WHILE ELSE ]
-- On WHILE shift to state 345

State 345:
iterStmt -> DO statement WHILE . LPAR expression RPAR SEMI [ WHILE ELSE ]
-- On LPAR shift to state 346

State 346:
iterStmt -> DO statement WHILE LPAR . expression RPAR SEMI [ WHILE ELSE ]
-- On error shift to state 3
-- On VOID shift to state 6
-- On THIS shift to state 7
-- On SUPER shift to state 8
-- On STRLIT shift to state 9
-- On SHORT shift to state 10
-- On PLUS shift to state 11
-- On NULLLIT shift to state 12
-- On NOT shift to state 13
-- On NEW shift to state 14
-- On MINUS shift to state 26
-- On LPAR shift to state 27
-- On LONG shift to state 15
-- On INTLIT shift to state 28
-- On INT shift to state 16
-- On INCREMENT shift to state 29
-- On IDENTIFIER shift to state 17
-- On FLOATLIT shift to state 31
-- On FLOAT shift to state 18
-- On DOUBLELIT shift to state 32
-- On DOUBLE shift to state 19
-- On DECREMENT shift to state 33
-- On CHARLIT shift to state 34
-- On CHAR shift to state 20
-- On BYTE shift to state 21
-- On BOOLEANLIT shift to state 35
-- On BOOLEAN shift to state 22
-- On BNOT shift to state 36
-- On unaryExpression shift to state 44
-- On specialName shift to state 38
-- On shiftExpression shift to state 58
-- On relationalExpression shift to state 79
-- On realPostfixExpression shift to state 39
-- On qualifiedName shift to state 42
-- On primitiveType shift to state 61
-- On primaryExpression shift to state 64
-- On postfixExpression shift to state 65
-- On plainNewAllocationExpression shift to state 68
-- On notJustName shift to state 69
-- On newAllocationExpression shift to state 72
-- On multiplicativeExpression shift to state 73
-- On methodCall shift to state 75
-- On methodAccess shift to state 76
-- On logicalUnaryOperator shift to state 83
-- On logicalUnaryExpression shift to state 85
-- On inclusiveOrExpression shift to state 90
-- On fieldAccess shift to state 86
-- On expression shift to state 347
-- On exclusiveOrExpression shift to state 111
-- On equalityExpression shift to state 94
-- On conditionalOrExpression shift to state 112
-- On conditionalExpression shift to state 151
-- On conditionalAndExpression shift to state 117
-- On complexPrimaryNoParenthesis shift to state 87
-- On complexPrimary shift to state 88
-- On classAllocationExpression shift to state 100
-- On castExpression shift to state 103
-- On assignmentExpression shift to state 152
-- On arrayAllocationExpression shift to state 104
-- On arrayAccess shift to state 120
-- On arithmeticUnaryOperator shift to state 121
-- On andExpression shift to state 123
-- On additiveExpression shift to state 140

State 347:
iterStmt -> DO statement WHILE LPAR expression . RPAR SEMI [ WHILE ELSE ]
-- On RPAR shift to state 348

State 348:
iterStmt -> DO statement WHILE LPAR expression RPAR . SEMI [ WHILE ELSE ]
-- On SEMI shift to state 349

State 349:
iterStmt -> DO statement WHILE LPAR expression RPAR SEMI . [ WHILE ELSE ]
-- On WHILE reduce production iterStmt -> DO statement WHILE LPAR expression RPAR SEMI 
-- On ELSE reduce production iterStmt -> DO statement WHILE LPAR expression RPAR SEMI 

State 350:
statement -> selectStmt . [ WHILE ELSE ]
-- On WHILE reduce production statement -> selectStmt 
-- On ELSE reduce production statement -> selectStmt 

State 351:
statement -> labelStmt . [ WHILE ELSE ]
-- On WHILE reduce production statement -> labelStmt 
-- On ELSE reduce production statement -> labelStmt 

State 352:
statement -> jumpStmt . [ WHILE ELSE ]
-- On WHILE reduce production statement -> jumpStmt 
-- On ELSE reduce production statement -> jumpStmt 

State 353:
statement -> iterStmt . [ WHILE ELSE ]
-- On WHILE reduce production statement -> iterStmt 
-- On ELSE reduce production statement -> iterStmt 

State 354:
statement -> guardingStmt . [ WHILE ELSE ]
-- On WHILE reduce production statement -> guardingStmt 
-- On ELSE reduce production statement -> guardingStmt 

State 355:
statement -> expressionStmt . SEMI [ WHILE ELSE ]
-- On SEMI shift to state 356

State 356:
statement -> expressionStmt SEMI . [ WHILE ELSE ]
-- On WHILE reduce production statement -> expressionStmt SEMI 
-- On ELSE reduce production statement -> expressionStmt SEMI 

State 357:
expressionStmt -> expression . [ SEMI RPAR COMM ]
-- On SEMI reduce production expressionStmt -> expression 
-- On RPAR reduce production expressionStmt -> expression 
-- On COMM reduce production expressionStmt -> expression 

State 358:
statement -> emptyStmt . [ WHILE ELSE ]
-- On WHILE reduce production statement -> emptyStmt 
-- On ELSE reduce production statement -> emptyStmt 

State 359:
statement -> block . [ WHILE ELSE ]
-- On WHILE reduce production statement -> block 
-- On ELSE reduce production statement -> block 

State 360:
statement -> assertStmt . [ WHILE ELSE ]
-- On WHILE reduce production statement -> assertStmt 
-- On ELSE reduce production statement -> assertStmt 

State 361:
iterStmt -> FOR LPAR forVarOpt COL expression RPAR statement . [ WHILE ELSE ]
-- On WHILE reduce production iterStmt -> FOR LPAR forVarOpt COL expression RPAR statement 
-- On ELSE reduce production iterStmt -> FOR LPAR forVarOpt COL expression RPAR statement 

State 362:
iterStmt -> FOR LPAR forInit . forExpr forIncr RPAR statement [ WHILE ELSE ]
iterStmt -> FOR LPAR forInit . forExpr RPAR statement [ WHILE ELSE ]
-- On error shift to state 3
-- On VOID shift to state 6
-- On THIS shift to state 7
-- On SUPER shift to state 8
-- On STRLIT shift to state 9
-- On SHORT shift to state 10
-- On SEMI shift to state 363
-- On PLUS shift to state 11
-- On NULLLIT shift to state 12
-- On NOT shift to state 13
-- On NEW shift to state 14
-- On MINUS shift to state 26
-- On LPAR shift to state 27
-- On LONG shift to state 15
-- On INTLIT shift to state 28
-- On INT shift to state 16
-- On INCREMENT shift to state 29
-- On IDENTIFIER shift to state 17
-- On FLOATLIT shift to state 31
-- On FLOAT shift to state 18
-- On DOUBLELIT shift to state 32
-- On DOUBLE shift to state 19
-- On DECREMENT shift to state 33
-- On CHARLIT shift to state 34
-- On CHAR shift to state 20
-- On BYTE shift to state 21
-- On BOOLEANLIT shift to state 35
-- On BOOLEAN shift to state 22
-- On BNOT shift to state 36
-- On unaryExpression shift to state 44
-- On specialName shift to state 38
-- On shiftExpression shift to state 58
-- On relationalExpression shift to state 79
-- On realPostfixExpression shift to state 39
-- On qualifiedName shift to state 42
-- On primitiveType shift to state 61
-- On primaryExpression shift to state 64
-- On postfixExpression shift to state 65
-- On plainNewAllocationExpression shift to state 68
-- On notJustName shift to state 69
-- On newAllocationExpression shift to state 72
-- On multiplicativeExpression shift to state 73
-- On methodCall shift to state 75
-- On methodAccess shift to state 76
-- On logicalUnaryOperator shift to state 83
-- On logicalUnaryExpression shift to state 85
-- On inclusiveOrExpression shift to state 90
-- On forExpr shift to state 364
-- On fieldAccess shift to state 86
-- On expression shift to state 374
-- On exclusiveOrExpression shift to state 111
-- On equalityExpression shift to state 94
-- On conditionalOrExpression shift to state 112
-- On conditionalExpression shift to state 151
-- On conditionalAndExpression shift to state 117
-- On complexPrimaryNoParenthesis shift to state 87
-- On complexPrimary shift to state 88
-- On classAllocationExpression shift to state 100
-- On castExpression shift to state 103
-- On assignmentExpression shift to state 152
-- On arrayAllocationExpression shift to state 104
-- On arrayAccess shift to state 120
-- On arithmeticUnaryOperator shift to state 121
-- On andExpression shift to state 123
-- On additiveExpression shift to state 140

State 363:
forExpr -> SEMI . [ error VOID THIS SUPER STRLIT SHORT RPAR PLUS NULLLIT NOT NEW MINUS LPAR LONG INTLIT INT INCREMENT IDENTIFIER FLOATLIT FLOAT DOUBLELIT DOUBLE DECREMENT CHARLIT CHAR BYTE BOOLEANLIT BOOLEAN BNOT ]
-- On error reduce production forExpr -> SEMI 
-- On VOID reduce production forExpr -> SEMI 
-- On THIS reduce production forExpr -> SEMI 
-- On SUPER reduce production forExpr -> SEMI 
-- On STRLIT reduce production forExpr -> SEMI 
-- On SHORT reduce production forExpr -> SEMI 
-- On RPAR reduce production forExpr -> SEMI 
-- On PLUS reduce production forExpr -> SEMI 
-- On NULLLIT reduce production forExpr -> SEMI 
-- On NOT reduce production forExpr -> SEMI 
-- On NEW reduce production forExpr -> SEMI 
-- On MINUS reduce production forExpr -> SEMI 
-- On LPAR reduce production forExpr -> SEMI 
-- On LONG reduce production forExpr -> SEMI 
-- On INTLIT reduce production forExpr -> SEMI 
-- On INT reduce production forExpr -> SEMI 
-- On INCREMENT reduce production forExpr -> SEMI 
-- On IDENTIFIER reduce production forExpr -> SEMI 
-- On FLOATLIT reduce production forExpr -> SEMI 
-- On FLOAT reduce production forExpr -> SEMI 
-- On DOUBLELIT reduce production forExpr -> SEMI 
-- On DOUBLE reduce production forExpr -> SEMI 
-- On DECREMENT reduce production forExpr -> SEMI 
-- On CHARLIT reduce production forExpr -> SEMI 
-- On CHAR reduce production forExpr -> SEMI 
-- On BYTE reduce production forExpr -> SEMI 
-- On BOOLEANLIT reduce production forExpr -> SEMI 
-- On BOOLEAN reduce production forExpr -> SEMI 
-- On BNOT reduce production forExpr -> SEMI 

State 364:
iterStmt -> FOR LPAR forInit forExpr . forIncr RPAR statement [ WHILE ELSE ]
iterStmt -> FOR LPAR forInit forExpr . RPAR statement [ WHILE ELSE ]
-- On error shift to state 3
-- On VOID shift to state 6
-- On THIS shift to state 7
-- On SUPER shift to state 8
-- On STRLIT shift to state 9
-- On SHORT shift to state 10
-- On RPAR shift to state 365
-- On PLUS shift to state 11
-- On NULLLIT shift to state 12
-- On NOT shift to state 13
-- On NEW shift to state 14
-- On MINUS shift to state 26
-- On LPAR shift to state 27
-- On LONG shift to state 15
-- On INTLIT shift to state 28
-- On INT shift to state 16
-- On INCREMENT shift to state 29
-- On IDENTIFIER shift to state 17
-- On FLOATLIT shift to state 31
-- On FLOAT shift to state 18
-- On DOUBLELIT shift to state 32
-- On DOUBLE shift to state 19
-- On DECREMENT shift to state 33
-- On CHARLIT shift to state 34
-- On CHAR shift to state 20
-- On BYTE shift to state 21
-- On BOOLEANLIT shift to state 35
-- On BOOLEAN shift to state 22
-- On BNOT shift to state 36
-- On unaryExpression shift to state 44
-- On specialName shift to state 38
-- On shiftExpression shift to state 58
-- On relationalExpression shift to state 79
-- On realPostfixExpression shift to state 39
-- On qualifiedName shift to state 42
-- On primitiveType shift to state 61
-- On primaryExpression shift to state 64
-- On postfixExpression shift to state 65
-- On plainNewAllocationExpression shift to state 68
-- On notJustName shift to state 69
-- On newAllocationExpression shift to state 72
-- On multiplicativeExpression shift to state 73
-- On methodCall shift to state 75
-- On methodAccess shift to state 76
-- On logicalUnaryOperator shift to state 83
-- On logicalUnaryExpression shift to state 85
-- On inclusiveOrExpression shift to state 90
-- On forIncr shift to state 367
-- On fieldAccess shift to state 86
-- On expressionStmts shift to state 370
-- On expressionStmt shift to state 373
-- On expression shift to state 357
-- On exclusiveOrExpression shift to state 111
-- On equalityExpression shift to state 94
-- On conditionalOrExpression shift to state 112
-- On conditionalExpression shift to state 151
-- On conditionalAndExpression shift to state 117
-- On complexPrimaryNoParenthesis shift to state 87
-- On complexPrimary shift to state 88
-- On classAllocationExpression shift to state 100
-- On castExpression shift to state 103
-- On assignmentExpression shift to state 152
-- On arrayAllocationExpression shift to state 104
-- On arrayAccess shift to state 120
-- On arithmeticUnaryOperator shift to state 121
-- On andExpression shift to state 123
-- On additiveExpression shift to state 140

State 365:
iterStmt -> FOR LPAR forInit forExpr RPAR . statement [ WHILE ELSE ]
-- On error shift to state 3
-- On WHILE shift to state 275
-- On VOID shift to state 6
-- On TRY shift to state 279
-- On THROW shift to state 296
-- On THIS shift to state 7
-- On SYNCHRONIZED shift to state 299
-- On SWITCH shift to state 303
-- On SUPER shift to state 8
-- On STRLIT shift to state 9
-- On SHORT shift to state 10
-- On SEMI shift to state 312
-- On RETURN shift to state 313
-- On PLUS shift to state 11
-- On NULLLIT shift to state 12
-- On NOT shift to state 13
-- On NEW shift to state 14
-- On MINUS shift to state 26
-- On LPAR shift to state 27
-- On LONG shift to state 15
-- On LCURL shift to state 209
-- On INTLIT shift to state 28
-- On INT shift to state 16
-- On INCREMENT shift to state 29
-- On IF shift to state 317
-- On IDENTIFIER shift to state 321
-- On FOR shift to state 323
-- On FLOATLIT shift to state 31
-- On FLOAT shift to state 18
-- On DOUBLELIT shift to state 32
-- On DOUBLE shift to state 19
-- On DO shift to state 329
-- On DECREMENT shift to state 33
-- On CONTINUE shift to state 330
-- On CHARLIT shift to state 34
-- On CHAR shift to state 20
-- On BYTE shift to state 21
-- On BREAK shift to state 334
-- On BOOLEANLIT shift to state 35
-- On BOOLEAN shift to state 22
-- On BNOT shift to state 36
-- On ASSERT shift to state 338
-- On unaryExpression shift to state 44
-- On statement shift to state 366
-- On specialName shift to state 38
-- On shiftExpression shift to state 58
-- On selectStmt shift to state 350
-- On relationalExpression shift to state 79
-- On realPostfixExpression shift to state 39
-- On qualifiedName shift to state 42
-- On primitiveType shift to state 61
-- On primaryExpression shift to state 64
-- On postfixExpression shift to state 65
-- On plainNewAllocationExpression shift to state 68
-- On notJustName shift to state 69
-- On newAllocationExpression shift to state 72
-- On multiplicativeExpression shift to state 73
-- On methodCall shift to state 75
-- On methodAccess shift to state 76
-- On logicalUnaryOperator shift to state 83
-- On logicalUnaryExpression shift to state 85
-- On labelStmt shift to state 351
-- On jumpStmt shift to state 352
-- On iterStmt shift to state 353
-- On inclusiveOrExpression shift to state 90
-- On guardingStmt shift to state 354
-- On fieldAccess shift to state 86
-- On expressionStmt shift to state 355
-- On expression shift to state 357
-- On exclusiveOrExpression shift to state 111
-- On equalityExpression shift to state 94
-- On emptyStmt shift to state 358
-- On conditionalOrExpression shift to state 112
-- On conditionalExpression shift to state 151
-- On conditionalAndExpression shift to state 117
-- On complexPrimaryNoParenthesis shift to state 87
-- On complexPrimary shift to state 88
-- On classAllocationExpression shift to state 100
-- On castExpression shift to state 103
-- On block shift to state 359
-- On assignmentExpression shift to state 152
-- On assertStmt shift to state 360
-- On arrayAllocationExpression shift to state 104
-- On arrayAccess shift to state 120
-- On arithmeticUnaryOperator shift to state 121
-- On andExpression shift to state 123
-- On additiveExpression shift to state 140

State 366:
iterStmt -> FOR LPAR forInit forExpr RPAR statement . [ WHILE ELSE ]
-- On WHILE reduce production iterStmt -> FOR LPAR forInit forExpr RPAR statement 
-- On ELSE reduce production iterStmt -> FOR LPAR forInit forExpr RPAR statement 

State 367:
iterStmt -> FOR LPAR forInit forExpr forIncr . RPAR statement [ WHILE ELSE ]
-- On RPAR shift to state 368

State 368:
iterStmt -> FOR LPAR forInit forExpr forIncr RPAR . statement [ WHILE ELSE ]
-- On error shift to state 3
-- On WHILE shift to state 275
-- On VOID shift to state 6
-- On TRY shift to state 279
-- On THROW shift to state 296
-- On THIS shift to state 7
-- On SYNCHRONIZED shift to state 299
-- On SWITCH shift to state 303
-- On SUPER shift to state 8
-- On STRLIT shift to state 9
-- On SHORT shift to state 10
-- On SEMI shift to state 312
-- On RETURN shift to state 313
-- On PLUS shift to state 11
-- On NULLLIT shift to state 12
-- On NOT shift to state 13
-- On NEW shift to state 14
-- On MINUS shift to state 26
-- On LPAR shift to state 27
-- On LONG shift to state 15
-- On LCURL shift to state 209
-- On INTLIT shift to state 28
-- On INT shift to state 16
-- On INCREMENT shift to state 29
-- On IF shift to state 317
-- On IDENTIFIER shift to state 321
-- On FOR shift to state 323
-- On FLOATLIT shift to state 31
-- On FLOAT shift to state 18
-- On DOUBLELIT shift to state 32
-- On DOUBLE shift to state 19
-- On DO shift to state 329
-- On DECREMENT shift to state 33
-- On CONTINUE shift to state 330
-- On CHARLIT shift to state 34
-- On CHAR shift to state 20
-- On BYTE shift to state 21
-- On BREAK shift to state 334
-- On BOOLEANLIT shift to state 35
-- On BOOLEAN shift to state 22
-- On BNOT shift to state 36
-- On ASSERT shift to state 338
-- On unaryExpression shift to state 44
-- On statement shift to state 369
-- On specialName shift to state 38
-- On shiftExpression shift to state 58
-- On selectStmt shift to state 350
-- On relationalExpression shift to state 79
-- On realPostfixExpression shift to state 39
-- On qualifiedName shift to state 42
-- On primitiveType shift to state 61
-- On primaryExpression shift to state 64
-- On postfixExpression shift to state 65
-- On plainNewAllocationExpression shift to state 68
-- On notJustName shift to state 69
-- On newAllocationExpression shift to state 72
-- On multiplicativeExpression shift to state 73
-- On methodCall shift to state 75
-- On methodAccess shift to state 76
-- On logicalUnaryOperator shift to state 83
-- On logicalUnaryExpression shift to state 85
-- On labelStmt shift to state 351
-- On jumpStmt shift to state 352
-- On iterStmt shift to state 353
-- On inclusiveOrExpression shift to state 90
-- On guardingStmt shift to state 354
-- On fieldAccess shift to state 86
-- On expressionStmt shift to state 355
-- On expression shift to state 357
-- On exclusiveOrExpression shift to state 111
-- On equalityExpression shift to state 94
-- On emptyStmt shift to state 358
-- On conditionalOrExpression shift to state 112
-- On conditionalExpression shift to state 151
-- On conditionalAndExpression shift to state 117
-- On complexPrimaryNoParenthesis shift to state 87
-- On complexPrimary shift to state 88
-- On classAllocationExpression shift to state 100
-- On castExpression shift to state 103
-- On block shift to state 359
-- On assignmentExpression shift to state 152
-- On assertStmt shift to state 360
-- On arrayAllocationExpression shift to state 104
-- On arrayAccess shift to state 120
-- On arithmeticUnaryOperator shift to state 121
-- On andExpression shift to state 123
-- On additiveExpression shift to state 140

State 369:
iterStmt -> FOR LPAR forInit forExpr forIncr RPAR statement . [ WHILE ELSE ]
-- On WHILE reduce production iterStmt -> FOR LPAR forInit forExpr forIncr RPAR statement 
-- On ELSE reduce production iterStmt -> FOR LPAR forInit forExpr forIncr RPAR statement 

State 370:
expressionStmts -> expressionStmts . COMM expressionStmt [ RPAR COMM ]
forIncr -> expressionStmts . [ RPAR ]
-- On COMM shift to state 371
-- On RPAR reduce production forIncr -> expressionStmts 

State 371:
expressionStmts -> expressionStmts COMM . expressionStmt [ RPAR COMM ]
-- On error shift to state 3
-- On VOID shift to state 6
-- On THIS shift to state 7
-- On SUPER shift to state 8
-- On STRLIT shift to state 9
-- On SHORT shift to state 10
-- On PLUS shift to state 11
-- On NULLLIT shift to state 12
-- On NOT shift to state 13
-- On NEW shift to state 14
-- On MINUS shift to state 26
-- On LPAR shift to state 27
-- On LONG shift to state 15
-- On INTLIT shift to state 28
-- On INT shift to state 16
-- On INCREMENT shift to state 29
-- On IDENTIFIER shift to state 17
-- On FLOATLIT shift to state 31
-- On FLOAT shift to state 18
-- On DOUBLELIT shift to state 32
-- On DOUBLE shift to state 19
-- On DECREMENT shift to state 33
-- On CHARLIT shift to state 34
-- On CHAR shift to state 20
-- On BYTE shift to state 21
-- On BOOLEANLIT shift to state 35
-- On BOOLEAN shift to state 22
-- On BNOT shift to state 36
-- On unaryExpression shift to state 44
-- On specialName shift to state 38
-- On shiftExpression shift to state 58
-- On relationalExpression shift to state 79
-- On realPostfixExpression shift to state 39
-- On qualifiedName shift to state 42
-- On primitiveType shift to state 61
-- On primaryExpression shift to state 64
-- On postfixExpression shift to state 65
-- On plainNewAllocationExpression shift to state 68
-- On notJustName shift to state 69
-- On newAllocationExpression shift to state 72
-- On multiplicativeExpression shift to state 73
-- On methodCall shift to state 75
-- On methodAccess shift to state 76
-- On logicalUnaryOperator shift to state 83
-- On logicalUnaryExpression shift to state 85
-- On inclusiveOrExpression shift to state 90
-- On fieldAccess shift to state 86
-- On expressionStmt shift to state 372
-- On expression shift to state 357
-- On exclusiveOrExpression shift to state 111
-- On equalityExpression shift to state 94
-- On conditionalOrExpression shift to state 112
-- On conditionalExpression shift to state 151
-- On conditionalAndExpression shift to state 117
-- On complexPrimaryNoParenthesis shift to state 87
-- On complexPrimary shift to state 88
-- On classAllocationExpression shift to state 100
-- On castExpression shift to state 103
-- On assignmentExpression shift to state 152
-- On arrayAllocationExpression shift to state 104
-- On arrayAccess shift to state 120
-- On arithmeticUnaryOperator shift to state 121
-- On andExpression shift to state 123
-- On additiveExpression shift to state 140

State 372:
expressionStmts -> expressionStmts COMM expressionStmt . [ RPAR COMM ]
-- On RPAR reduce production expressionStmts -> expressionStmts COMM expressionStmt 
-- On COMM reduce production expressionStmts -> expressionStmts COMM expressionStmt 

State 373:
expressionStmts -> expressionStmt . [ RPAR COMM ]
-- On RPAR reduce production expressionStmts -> expressionStmt 
-- On COMM reduce production expressionStmts -> expressionStmt 

State 374:
forExpr -> expression . SEMI [ error VOID THIS SUPER STRLIT SHORT RPAR PLUS NULLLIT NOT NEW MINUS LPAR LONG INTLIT INT INCREMENT IDENTIFIER FLOATLIT FLOAT DOUBLELIT DOUBLE DECREMENT CHARLIT CHAR BYTE BOOLEANLIT BOOLEAN BNOT ]
-- On SEMI shift to state 375

State 375:
forExpr -> expression SEMI . [ error VOID THIS SUPER STRLIT SHORT RPAR PLUS NULLLIT NOT NEW MINUS LPAR LONG INTLIT INT INCREMENT IDENTIFIER FLOATLIT FLOAT DOUBLELIT DOUBLE DECREMENT CHARLIT CHAR BYTE BOOLEANLIT BOOLEAN BNOT ]
-- On error reduce production forExpr -> expression SEMI 
-- On VOID reduce production forExpr -> expression SEMI 
-- On THIS reduce production forExpr -> expression SEMI 
-- On SUPER reduce production forExpr -> expression SEMI 
-- On STRLIT reduce production forExpr -> expression SEMI 
-- On SHORT reduce production forExpr -> expression SEMI 
-- On RPAR reduce production forExpr -> expression SEMI 
-- On PLUS reduce production forExpr -> expression SEMI 
-- On NULLLIT reduce production forExpr -> expression SEMI 
-- On NOT reduce production forExpr -> expression SEMI 
-- On NEW reduce production forExpr -> expression SEMI 
-- On MINUS reduce production forExpr -> expression SEMI 
-- On LPAR reduce production forExpr -> expression SEMI 
-- On LONG reduce production forExpr -> expression SEMI 
-- On INTLIT reduce production forExpr -> expression SEMI 
-- On INT reduce production forExpr -> expression SEMI 
-- On INCREMENT reduce production forExpr -> expression SEMI 
-- On IDENTIFIER reduce production forExpr -> expression SEMI 
-- On FLOATLIT reduce production forExpr -> expression SEMI 
-- On FLOAT reduce production forExpr -> expression SEMI 
-- On DOUBLELIT reduce production forExpr -> expression SEMI 
-- On DOUBLE reduce production forExpr -> expression SEMI 
-- On DECREMENT reduce production forExpr -> expression SEMI 
-- On CHARLIT reduce production forExpr -> expression SEMI 
-- On CHAR reduce production forExpr -> expression SEMI 
-- On BYTE reduce production forExpr -> expression SEMI 
-- On BOOLEANLIT reduce production forExpr -> expression SEMI 
-- On BOOLEAN reduce production forExpr -> expression SEMI 
-- On BNOT reduce production forExpr -> expression SEMI 

State 376:
selectStmt -> IF LPAR expression RPAR statement . [ WHILE ELSE ]
selectStmt -> IF LPAR expression RPAR statement . ELSE statement [ WHILE ELSE ]
-- On ELSE shift to state 377
-- On WHILE reduce production selectStmt -> IF LPAR expression RPAR statement 

State 377:
selectStmt -> IF LPAR expression RPAR statement ELSE . statement [ WHILE ELSE ]
-- On error shift to state 3
-- On WHILE shift to state 275
-- On VOID shift to state 6
-- On TRY shift to state 279
-- On THROW shift to state 296
-- On THIS shift to state 7
-- On SYNCHRONIZED shift to state 299
-- On SWITCH shift to state 303
-- On SUPER shift to state 8
-- On STRLIT shift to state 9
-- On SHORT shift to state 10
-- On SEMI shift to state 312
-- On RETURN shift to state 313
-- On PLUS shift to state 11
-- On NULLLIT shift to state 12
-- On NOT shift to state 13
-- On NEW shift to state 14
-- On MINUS shift to state 26
-- On LPAR shift to state 27
-- On LONG shift to state 15
-- On LCURL shift to state 209
-- On INTLIT shift to state 28
-- On INT shift to state 16
-- On INCREMENT shift to state 29
-- On IF shift to state 317
-- On IDENTIFIER shift to state 321
-- On FOR shift to state 323
-- On FLOATLIT shift to state 31
-- On FLOAT shift to state 18
-- On DOUBLELIT shift to state 32
-- On DOUBLE shift to state 19
-- On DO shift to state 329
-- On DECREMENT shift to state 33
-- On CONTINUE shift to state 330
-- On CHARLIT shift to state 34
-- On CHAR shift to state 20
-- On BYTE shift to state 21
-- On BREAK shift to state 334
-- On BOOLEANLIT shift to state 35
-- On BOOLEAN shift to state 22
-- On BNOT shift to state 36
-- On ASSERT shift to state 338
-- On unaryExpression shift to state 44
-- On statement shift to state 378
-- On specialName shift to state 38
-- On shiftExpression shift to state 58
-- On selectStmt shift to state 350
-- On relationalExpression shift to state 79
-- On realPostfixExpression shift to state 39
-- On qualifiedName shift to state 42
-- On primitiveType shift to state 61
-- On primaryExpression shift to state 64
-- On postfixExpression shift to state 65
-- On plainNewAllocationExpression shift to state 68
-- On notJustName shift to state 69
-- On newAllocationExpression shift to state 72
-- On multiplicativeExpression shift to state 73
-- On methodCall shift to state 75
-- On methodAccess shift to state 76
-- On logicalUnaryOperator shift to state 83
-- On logicalUnaryExpression shift to state 85
-- On labelStmt shift to state 351
-- On jumpStmt shift to state 352
-- On iterStmt shift to state 353
-- On inclusiveOrExpression shift to state 90
-- On guardingStmt shift to state 354
-- On fieldAccess shift to state 86
-- On expressionStmt shift to state 355
-- On expression shift to state 357
-- On exclusiveOrExpression shift to state 111
-- On equalityExpression shift to state 94
-- On emptyStmt shift to state 358
-- On conditionalOrExpression shift to state 112
-- On conditionalExpression shift to state 151
-- On conditionalAndExpression shift to state 117
-- On complexPrimaryNoParenthesis shift to state 87
-- On complexPrimary shift to state 88
-- On classAllocationExpression shift to state 100
-- On castExpression shift to state 103
-- On block shift to state 359
-- On assignmentExpression shift to state 152
-- On assertStmt shift to state 360
-- On arrayAllocationExpression shift to state 104
-- On arrayAccess shift to state 120
-- On arithmeticUnaryOperator shift to state 121
-- On andExpression shift to state 123
-- On additiveExpression shift to state 140

State 378:
selectStmt -> IF LPAR expression RPAR statement ELSE statement . [ WHILE ELSE ]
-- On WHILE reduce production selectStmt -> IF LPAR expression RPAR statement ELSE statement 
-- On ELSE reduce production selectStmt -> IF LPAR expression RPAR statement ELSE statement 

State 379:
guardingStmt -> SYNCHRONIZED LPAR expression RPAR statement . [ WHILE ELSE ]
-- On WHILE reduce production guardingStmt -> SYNCHRONIZED LPAR expression RPAR statement 
-- On ELSE reduce production guardingStmt -> SYNCHRONIZED LPAR expression RPAR statement 

State 380:
iterStmt -> WHILE LPAR expression RPAR statement . [ WHILE ELSE ]
-- On WHILE reduce production iterStmt -> WHILE LPAR expression RPAR statement 
-- On ELSE reduce production iterStmt -> WHILE LPAR expression RPAR statement 

State 381:
iterStmt -> DO statement . WHILE LPAR expression RPAR SEMI [ error WHILE VOID TRY THROW THIS SYNCHRONIZED SWITCH SUPER STRLIT SHORT SEMI RETURN RCURL PLUS NULLLIT NOT NEW MINUS LPAR LONG LCURL INTLIT INT INCREMENT IF IDENTIFIER FOR FLOATLIT FLOAT FINAL ELSE DOUBLELIT DOUBLE DO DECREMENT CONTINUE CHARLIT CHAR BYTE BREAK BOOLEANLIT BOOLEAN BNOT ASSERT ]
-- On WHILE shift to state 382

State 382:
iterStmt -> DO statement WHILE . LPAR expression RPAR SEMI [ error WHILE VOID TRY THROW THIS SYNCHRONIZED SWITCH SUPER STRLIT SHORT SEMI RETURN RCURL PLUS NULLLIT NOT NEW MINUS LPAR LONG LCURL INTLIT INT INCREMENT IF IDENTIFIER FOR FLOATLIT FLOAT FINAL ELSE DOUBLELIT DOUBLE DO DECREMENT CONTINUE CHARLIT CHAR BYTE BREAK BOOLEANLIT BOOLEAN BNOT ASSERT ]
-- On LPAR shift to state 383

State 383:
iterStmt -> DO statement WHILE LPAR . expression RPAR SEMI [ error WHILE VOID TRY THROW THIS SYNCHRONIZED SWITCH SUPER STRLIT SHORT SEMI RETURN RCURL PLUS NULLLIT NOT NEW MINUS LPAR LONG LCURL INTLIT INT INCREMENT IF IDENTIFIER FOR FLOATLIT FLOAT FINAL ELSE DOUBLELIT DOUBLE DO DECREMENT CONTINUE CHARLIT CHAR BYTE BREAK BOOLEANLIT BOOLEAN BNOT ASSERT ]
-- On error shift to state 3
-- On VOID shift to state 6
-- On THIS shift to state 7
-- On SUPER shift to state 8
-- On STRLIT shift to state 9
-- On SHORT shift to state 10
-- On PLUS shift to state 11
-- On NULLLIT shift to state 12
-- On NOT shift to state 13
-- On NEW shift to state 14
-- On MINUS shift to state 26
-- On LPAR shift to state 27
-- On LONG shift to state 15
-- On INTLIT shift to state 28
-- On INT shift to state 16
-- On INCREMENT shift to state 29
-- On IDENTIFIER shift to state 17
-- On FLOATLIT shift to state 31
-- On FLOAT shift to state 18
-- On DOUBLELIT shift to state 32
-- On DOUBLE shift to state 19
-- On DECREMENT shift to state 33
-- On CHARLIT shift to state 34
-- On CHAR shift to state 20
-- On BYTE shift to state 21
-- On BOOLEANLIT shift to state 35
-- On BOOLEAN shift to state 22
-- On BNOT shift to state 36
-- On unaryExpression shift to state 44
-- On specialName shift to state 38
-- On shiftExpression shift to state 58
-- On relationalExpression shift to state 79
-- On realPostfixExpression shift to state 39
-- On qualifiedName shift to state 42
-- On primitiveType shift to state 61
-- On primaryExpression shift to state 64
-- On postfixExpression shift to state 65
-- On plainNewAllocationExpression shift to state 68
-- On notJustName shift to state 69
-- On newAllocationExpression shift to state 72
-- On multiplicativeExpression shift to state 73
-- On methodCall shift to state 75
-- On methodAccess shift to state 76
-- On logicalUnaryOperator shift to state 83
-- On logicalUnaryExpression shift to state 85
-- On inclusiveOrExpression shift to state 90
-- On fieldAccess shift to state 86
-- On expression shift to state 384
-- On exclusiveOrExpression shift to state 111
-- On equalityExpression shift to state 94
-- On conditionalOrExpression shift to state 112
-- On conditionalExpression shift to state 151
-- On conditionalAndExpression shift to state 117
-- On complexPrimaryNoParenthesis shift to state 87
-- On complexPrimary shift to state 88
-- On classAllocationExpression shift to state 100
-- On castExpression shift to state 103
-- On assignmentExpression shift to state 152
-- On arrayAllocationExpression shift to state 104
-- On arrayAccess shift to state 120
-- On arithmeticUnaryOperator shift to state 121
-- On andExpression shift to state 123
-- On additiveExpression shift to state 140

State 384:
iterStmt -> DO statement WHILE LPAR expression . RPAR SEMI [ error WHILE VOID TRY THROW THIS SYNCHRONIZED SWITCH SUPER STRLIT SHORT SEMI RETURN RCURL PLUS NULLLIT NOT NEW MINUS LPAR LONG LCURL INTLIT INT INCREMENT IF IDENTIFIER FOR FLOATLIT FLOAT FINAL ELSE DOUBLELIT DOUBLE DO DECREMENT CONTINUE CHARLIT CHAR BYTE BREAK BOOLEANLIT BOOLEAN BNOT ASSERT ]
-- On RPAR shift to state 385

State 385:
iterStmt -> DO statement WHILE LPAR expression RPAR . SEMI [ error WHILE VOID TRY THROW THIS SYNCHRONIZED SWITCH SUPER STRLIT SHORT SEMI RETURN RCURL PLUS NULLLIT NOT NEW MINUS LPAR LONG LCURL INTLIT INT INCREMENT IF IDENTIFIER FOR FLOATLIT FLOAT FINAL ELSE DOUBLELIT DOUBLE DO DECREMENT CONTINUE CHARLIT CHAR BYTE BREAK BOOLEANLIT BOOLEAN BNOT ASSERT ]
-- On SEMI shift to state 386

State 386:
iterStmt -> DO statement WHILE LPAR expression RPAR SEMI . [ error WHILE VOID TRY THROW THIS SYNCHRONIZED SWITCH SUPER STRLIT SHORT SEMI RETURN RCURL PLUS NULLLIT NOT NEW MINUS LPAR LONG LCURL INTLIT INT INCREMENT IF IDENTIFIER FOR FLOATLIT FLOAT FINAL ELSE DOUBLELIT DOUBLE DO DECREMENT CONTINUE CHARLIT CHAR BYTE BREAK BOOLEANLIT BOOLEAN BNOT ASSERT ]
-- On error reduce production iterStmt -> DO statement WHILE LPAR expression RPAR SEMI 
-- On WHILE reduce production iterStmt -> DO statement WHILE LPAR expression RPAR SEMI 
-- On VOID reduce production iterStmt -> DO statement WHILE LPAR expression RPAR SEMI 
-- On TRY reduce production iterStmt -> DO statement WHILE LPAR expression RPAR SEMI 
-- On THROW reduce production iterStmt -> DO statement WHILE LPAR expression RPAR SEMI 
-- On THIS reduce production iterStmt -> DO statement WHILE LPAR expression RPAR SEMI 
-- On SYNCHRONIZED reduce production iterStmt -> DO statement WHILE LPAR expression RPAR SEMI 
-- On SWITCH reduce production iterStmt -> DO statement WHILE LPAR expression RPAR SEMI 
-- On SUPER reduce production iterStmt -> DO statement WHILE LPAR expression RPAR SEMI 
-- On STRLIT reduce production iterStmt -> DO statement WHILE LPAR expression RPAR SEMI 
-- On SHORT reduce production iterStmt -> DO statement WHILE LPAR expression RPAR SEMI 
-- On SEMI reduce production iterStmt -> DO statement WHILE LPAR expression RPAR SEMI 
-- On RETURN reduce production iterStmt -> DO statement WHILE LPAR expression RPAR SEMI 
-- On RCURL reduce production iterStmt -> DO statement WHILE LPAR expression RPAR SEMI 
-- On PLUS reduce production iterStmt -> DO statement WHILE LPAR expression RPAR SEMI 
-- On NULLLIT reduce production iterStmt -> DO statement WHILE LPAR expression RPAR SEMI 
-- On NOT reduce production iterStmt -> DO statement WHILE LPAR expression RPAR SEMI 
-- On NEW reduce production iterStmt -> DO statement WHILE LPAR expression RPAR SEMI 
-- On MINUS reduce production iterStmt -> DO statement WHILE LPAR expression RPAR SEMI 
-- On LPAR reduce production iterStmt -> DO statement WHILE LPAR expression RPAR SEMI 
-- On LONG reduce production iterStmt -> DO statement WHILE LPAR expression RPAR SEMI 
-- On LCURL reduce production iterStmt -> DO statement WHILE LPAR expression RPAR SEMI 
-- On INTLIT reduce production iterStmt -> DO statement WHILE LPAR expression RPAR SEMI 
-- On INT reduce production iterStmt -> DO statement WHILE LPAR expression RPAR SEMI 
-- On INCREMENT reduce production iterStmt -> DO statement WHILE LPAR expression RPAR SEMI 
-- On IF reduce production iterStmt -> DO statement WHILE LPAR expression RPAR SEMI 
-- On IDENTIFIER reduce production iterStmt -> DO statement WHILE LPAR expression RPAR SEMI 
-- On FOR reduce production iterStmt -> DO statement WHILE LPAR expression RPAR SEMI 
-- On FLOATLIT reduce production iterStmt -> DO statement WHILE LPAR expression RPAR SEMI 
-- On FLOAT reduce production iterStmt -> DO statement WHILE LPAR expression RPAR SEMI 
-- On FINAL reduce production iterStmt -> DO statement WHILE LPAR expression RPAR SEMI 
-- On ELSE reduce production iterStmt -> DO statement WHILE LPAR expression RPAR SEMI 
-- On DOUBLELIT reduce production iterStmt -> DO statement WHILE LPAR expression RPAR SEMI 
-- On DOUBLE reduce production iterStmt -> DO statement WHILE LPAR expression RPAR SEMI 
-- On DO reduce production iterStmt -> DO statement WHILE LPAR expression RPAR SEMI 
-- On DECREMENT reduce production iterStmt -> DO statement WHILE LPAR expression RPAR SEMI 
-- On CONTINUE reduce production iterStmt -> DO statement WHILE LPAR expression RPAR SEMI 
-- On CHARLIT reduce production iterStmt -> DO statement WHILE LPAR expression RPAR SEMI 
-- On CHAR reduce production iterStmt -> DO statement WHILE LPAR expression RPAR SEMI 
-- On BYTE reduce production iterStmt -> DO statement WHILE LPAR expression RPAR SEMI 
-- On BREAK reduce production iterStmt -> DO statement WHILE LPAR expression RPAR SEMI 
-- On BOOLEANLIT reduce production iterStmt -> DO statement WHILE LPAR expression RPAR SEMI 
-- On BOOLEAN reduce production iterStmt -> DO statement WHILE LPAR expression RPAR SEMI 
-- On BNOT reduce production iterStmt -> DO statement WHILE LPAR expression RPAR SEMI 
-- On ASSERT reduce production iterStmt -> DO statement WHILE LPAR expression RPAR SEMI 

State 387:
jumpStmt -> CONTINUE . IDENTIFIER SEMI [ error WHILE VOID TRY THROW THIS SYNCHRONIZED SWITCH SUPER STRLIT SHORT SEMI RETURN RCURL PLUS NULLLIT NOT NEW MINUS LPAR LONG LCURL INTLIT INT INCREMENT IF IDENTIFIER FOR FLOATLIT FLOAT FINAL ELSE DOUBLELIT DOUBLE DO DECREMENT CONTINUE CHARLIT CHAR BYTE BREAK BOOLEANLIT BOOLEAN BNOT ASSERT ]
jumpStmt -> CONTINUE . SEMI [ error WHILE VOID TRY THROW THIS SYNCHRONIZED SWITCH SUPER STRLIT SHORT SEMI RETURN RCURL PLUS NULLLIT NOT NEW MINUS LPAR LONG LCURL INTLIT INT INCREMENT IF IDENTIFIER FOR FLOATLIT FLOAT FINAL ELSE DOUBLELIT DOUBLE DO DECREMENT CONTINUE CHARLIT CHAR BYTE BREAK BOOLEANLIT BOOLEAN BNOT ASSERT ]
-- On SEMI shift to state 388
-- On IDENTIFIER shift to state 389

State 388:
jumpStmt -> CONTINUE SEMI . [ error WHILE VOID TRY THROW THIS SYNCHRONIZED SWITCH SUPER STRLIT SHORT SEMI RETURN RCURL PLUS NULLLIT NOT NEW MINUS LPAR LONG LCURL INTLIT INT INCREMENT IF IDENTIFIER FOR FLOATLIT FLOAT FINAL ELSE DOUBLELIT DOUBLE DO DECREMENT CONTINUE CHARLIT CHAR BYTE BREAK BOOLEANLIT BOOLEAN BNOT ASSERT ]
-- On error reduce production jumpStmt -> CONTINUE SEMI 
-- On WHILE reduce production jumpStmt -> CONTINUE SEMI 
-- On VOID reduce production jumpStmt -> CONTINUE SEMI 
-- On TRY reduce production jumpStmt -> CONTINUE SEMI 
-- On THROW reduce production jumpStmt -> CONTINUE SEMI 
-- On THIS reduce production jumpStmt -> CONTINUE SEMI 
-- On SYNCHRONIZED reduce production jumpStmt -> CONTINUE SEMI 
-- On SWITCH reduce production jumpStmt -> CONTINUE SEMI 
-- On SUPER reduce production jumpStmt -> CONTINUE SEMI 
-- On STRLIT reduce production jumpStmt -> CONTINUE SEMI 
-- On SHORT reduce production jumpStmt -> CONTINUE SEMI 
-- On SEMI reduce production jumpStmt -> CONTINUE SEMI 
-- On RETURN reduce production jumpStmt -> CONTINUE SEMI 
-- On RCURL reduce production jumpStmt -> CONTINUE SEMI 
-- On PLUS reduce production jumpStmt -> CONTINUE SEMI 
-- On NULLLIT reduce production jumpStmt -> CONTINUE SEMI 
-- On NOT reduce production jumpStmt -> CONTINUE SEMI 
-- On NEW reduce production jumpStmt -> CONTINUE SEMI 
-- On MINUS reduce production jumpStmt -> CONTINUE SEMI 
-- On LPAR reduce production jumpStmt -> CONTINUE SEMI 
-- On LONG reduce production jumpStmt -> CONTINUE SEMI 
-- On LCURL reduce production jumpStmt -> CONTINUE SEMI 
-- On INTLIT reduce production jumpStmt -> CONTINUE SEMI 
-- On INT reduce production jumpStmt -> CONTINUE SEMI 
-- On INCREMENT reduce production jumpStmt -> CONTINUE SEMI 
-- On IF reduce production jumpStmt -> CONTINUE SEMI 
-- On IDENTIFIER reduce production jumpStmt -> CONTINUE SEMI 
-- On FOR reduce production jumpStmt -> CONTINUE SEMI 
-- On FLOATLIT reduce production jumpStmt -> CONTINUE SEMI 
-- On FLOAT reduce production jumpStmt -> CONTINUE SEMI 
-- On FINAL reduce production jumpStmt -> CONTINUE SEMI 
-- On ELSE reduce production jumpStmt -> CONTINUE SEMI 
-- On DOUBLELIT reduce production jumpStmt -> CONTINUE SEMI 
-- On DOUBLE reduce production jumpStmt -> CONTINUE SEMI 
-- On DO reduce production jumpStmt -> CONTINUE SEMI 
-- On DECREMENT reduce production jumpStmt -> CONTINUE SEMI 
-- On CONTINUE reduce production jumpStmt -> CONTINUE SEMI 
-- On CHARLIT reduce production jumpStmt -> CONTINUE SEMI 
-- On CHAR reduce production jumpStmt -> CONTINUE SEMI 
-- On BYTE reduce production jumpStmt -> CONTINUE SEMI 
-- On BREAK reduce production jumpStmt -> CONTINUE SEMI 
-- On BOOLEANLIT reduce production jumpStmt -> CONTINUE SEMI 
-- On BOOLEAN reduce production jumpStmt -> CONTINUE SEMI 
-- On BNOT reduce production jumpStmt -> CONTINUE SEMI 
-- On ASSERT reduce production jumpStmt -> CONTINUE SEMI 

State 389:
jumpStmt -> CONTINUE IDENTIFIER . SEMI [ error WHILE VOID TRY THROW THIS SYNCHRONIZED SWITCH SUPER STRLIT SHORT SEMI RETURN RCURL PLUS NULLLIT NOT NEW MINUS LPAR LONG LCURL INTLIT INT INCREMENT IF IDENTIFIER FOR FLOATLIT FLOAT FINAL ELSE DOUBLELIT DOUBLE DO DECREMENT CONTINUE CHARLIT CHAR BYTE BREAK BOOLEANLIT BOOLEAN BNOT ASSERT ]
-- On SEMI shift to state 390

State 390:
jumpStmt -> CONTINUE IDENTIFIER SEMI . [ error WHILE VOID TRY THROW THIS SYNCHRONIZED SWITCH SUPER STRLIT SHORT SEMI RETURN RCURL PLUS NULLLIT NOT NEW MINUS LPAR LONG LCURL INTLIT INT INCREMENT IF IDENTIFIER FOR FLOATLIT FLOAT FINAL ELSE DOUBLELIT DOUBLE DO DECREMENT CONTINUE CHARLIT CHAR BYTE BREAK BOOLEANLIT BOOLEAN BNOT ASSERT ]
-- On error reduce production jumpStmt -> CONTINUE IDENTIFIER SEMI 
-- On WHILE reduce production jumpStmt -> CONTINUE IDENTIFIER SEMI 
-- On VOID reduce production jumpStmt -> CONTINUE IDENTIFIER SEMI 
-- On TRY reduce production jumpStmt -> CONTINUE IDENTIFIER SEMI 
-- On THROW reduce production jumpStmt -> CONTINUE IDENTIFIER SEMI 
-- On THIS reduce production jumpStmt -> CONTINUE IDENTIFIER SEMI 
-- On SYNCHRONIZED reduce production jumpStmt -> CONTINUE IDENTIFIER SEMI 
-- On SWITCH reduce production jumpStmt -> CONTINUE IDENTIFIER SEMI 
-- On SUPER reduce production jumpStmt -> CONTINUE IDENTIFIER SEMI 
-- On STRLIT reduce production jumpStmt -> CONTINUE IDENTIFIER SEMI 
-- On SHORT reduce production jumpStmt -> CONTINUE IDENTIFIER SEMI 
-- On SEMI reduce production jumpStmt -> CONTINUE IDENTIFIER SEMI 
-- On RETURN reduce production jumpStmt -> CONTINUE IDENTIFIER SEMI 
-- On RCURL reduce production jumpStmt -> CONTINUE IDENTIFIER SEMI 
-- On PLUS reduce production jumpStmt -> CONTINUE IDENTIFIER SEMI 
-- On NULLLIT reduce production jumpStmt -> CONTINUE IDENTIFIER SEMI 
-- On NOT reduce production jumpStmt -> CONTINUE IDENTIFIER SEMI 
-- On NEW reduce production jumpStmt -> CONTINUE IDENTIFIER SEMI 
-- On MINUS reduce production jumpStmt -> CONTINUE IDENTIFIER SEMI 
-- On LPAR reduce production jumpStmt -> CONTINUE IDENTIFIER SEMI 
-- On LONG reduce production jumpStmt -> CONTINUE IDENTIFIER SEMI 
-- On LCURL reduce production jumpStmt -> CONTINUE IDENTIFIER SEMI 
-- On INTLIT reduce production jumpStmt -> CONTINUE IDENTIFIER SEMI 
-- On INT reduce production jumpStmt -> CONTINUE IDENTIFIER SEMI 
-- On INCREMENT reduce production jumpStmt -> CONTINUE IDENTIFIER SEMI 
-- On IF reduce production jumpStmt -> CONTINUE IDENTIFIER SEMI 
-- On IDENTIFIER reduce production jumpStmt -> CONTINUE IDENTIFIER SEMI 
-- On FOR reduce production jumpStmt -> CONTINUE IDENTIFIER SEMI 
-- On FLOATLIT reduce production jumpStmt -> CONTINUE IDENTIFIER SEMI 
-- On FLOAT reduce production jumpStmt -> CONTINUE IDENTIFIER SEMI 
-- On FINAL reduce production jumpStmt -> CONTINUE IDENTIFIER SEMI 
-- On ELSE reduce production jumpStmt -> CONTINUE IDENTIFIER SEMI 
-- On DOUBLELIT reduce production jumpStmt -> CONTINUE IDENTIFIER SEMI 
-- On DOUBLE reduce production jumpStmt -> CONTINUE IDENTIFIER SEMI 
-- On DO reduce production jumpStmt -> CONTINUE IDENTIFIER SEMI 
-- On DECREMENT reduce production jumpStmt -> CONTINUE IDENTIFIER SEMI 
-- On CONTINUE reduce production jumpStmt -> CONTINUE IDENTIFIER SEMI 
-- On CHARLIT reduce production jumpStmt -> CONTINUE IDENTIFIER SEMI 
-- On CHAR reduce production jumpStmt -> CONTINUE IDENTIFIER SEMI 
-- On BYTE reduce production jumpStmt -> CONTINUE IDENTIFIER SEMI 
-- On BREAK reduce production jumpStmt -> CONTINUE IDENTIFIER SEMI 
-- On BOOLEANLIT reduce production jumpStmt -> CONTINUE IDENTIFIER SEMI 
-- On BOOLEAN reduce production jumpStmt -> CONTINUE IDENTIFIER SEMI 
-- On BNOT reduce production jumpStmt -> CONTINUE IDENTIFIER SEMI 
-- On ASSERT reduce production jumpStmt -> CONTINUE IDENTIFIER SEMI 

State 391:
jumpStmt -> BREAK . IDENTIFIER SEMI [ error WHILE VOID TRY THROW THIS SYNCHRONIZED SWITCH SUPER STRLIT SHORT SEMI RETURN RCURL PLUS NULLLIT NOT NEW MINUS LPAR LONG LCURL INTLIT INT INCREMENT IF IDENTIFIER FOR FLOATLIT FLOAT FINAL ELSE DOUBLELIT DOUBLE DO DECREMENT CONTINUE CHARLIT CHAR BYTE BREAK BOOLEANLIT BOOLEAN BNOT ASSERT ]
jumpStmt -> BREAK . SEMI [ error WHILE VOID TRY THROW THIS SYNCHRONIZED SWITCH SUPER STRLIT SHORT SEMI RETURN RCURL PLUS NULLLIT NOT NEW MINUS LPAR LONG LCURL INTLIT INT INCREMENT IF IDENTIFIER FOR FLOATLIT FLOAT FINAL ELSE DOUBLELIT DOUBLE DO DECREMENT CONTINUE CHARLIT CHAR BYTE BREAK BOOLEANLIT BOOLEAN BNOT ASSERT ]
-- On SEMI shift to state 392
-- On IDENTIFIER shift to state 393

State 392:
jumpStmt -> BREAK SEMI . [ error WHILE VOID TRY THROW THIS SYNCHRONIZED SWITCH SUPER STRLIT SHORT SEMI RETURN RCURL PLUS NULLLIT NOT NEW MINUS LPAR LONG LCURL INTLIT INT INCREMENT IF IDENTIFIER FOR FLOATLIT FLOAT FINAL ELSE DOUBLELIT DOUBLE DO DECREMENT CONTINUE CHARLIT CHAR BYTE BREAK BOOLEANLIT BOOLEAN BNOT ASSERT ]
-- On error reduce production jumpStmt -> BREAK SEMI 
-- On WHILE reduce production jumpStmt -> BREAK SEMI 
-- On VOID reduce production jumpStmt -> BREAK SEMI 
-- On TRY reduce production jumpStmt -> BREAK SEMI 
-- On THROW reduce production jumpStmt -> BREAK SEMI 
-- On THIS reduce production jumpStmt -> BREAK SEMI 
-- On SYNCHRONIZED reduce production jumpStmt -> BREAK SEMI 
-- On SWITCH reduce production jumpStmt -> BREAK SEMI 
-- On SUPER reduce production jumpStmt -> BREAK SEMI 
-- On STRLIT reduce production jumpStmt -> BREAK SEMI 
-- On SHORT reduce production jumpStmt -> BREAK SEMI 
-- On SEMI reduce production jumpStmt -> BREAK SEMI 
-- On RETURN reduce production jumpStmt -> BREAK SEMI 
-- On RCURL reduce production jumpStmt -> BREAK SEMI 
-- On PLUS reduce production jumpStmt -> BREAK SEMI 
-- On NULLLIT reduce production jumpStmt -> BREAK SEMI 
-- On NOT reduce production jumpStmt -> BREAK SEMI 
-- On NEW reduce production jumpStmt -> BREAK SEMI 
-- On MINUS reduce production jumpStmt -> BREAK SEMI 
-- On LPAR reduce production jumpStmt -> BREAK SEMI 
-- On LONG reduce production jumpStmt -> BREAK SEMI 
-- On LCURL reduce production jumpStmt -> BREAK SEMI 
-- On INTLIT reduce production jumpStmt -> BREAK SEMI 
-- On INT reduce production jumpStmt -> BREAK SEMI 
-- On INCREMENT reduce production jumpStmt -> BREAK SEMI 
-- On IF reduce production jumpStmt -> BREAK SEMI 
-- On IDENTIFIER reduce production jumpStmt -> BREAK SEMI 
-- On FOR reduce production jumpStmt -> BREAK SEMI 
-- On FLOATLIT reduce production jumpStmt -> BREAK SEMI 
-- On FLOAT reduce production jumpStmt -> BREAK SEMI 
-- On FINAL reduce production jumpStmt -> BREAK SEMI 
-- On ELSE reduce production jumpStmt -> BREAK SEMI 
-- On DOUBLELIT reduce production jumpStmt -> BREAK SEMI 
-- On DOUBLE reduce production jumpStmt -> BREAK SEMI 
-- On DO reduce production jumpStmt -> BREAK SEMI 
-- On DECREMENT reduce production jumpStmt -> BREAK SEMI 
-- On CONTINUE reduce production jumpStmt -> BREAK SEMI 
-- On CHARLIT reduce production jumpStmt -> BREAK SEMI 
-- On CHAR reduce production jumpStmt -> BREAK SEMI 
-- On BYTE reduce production jumpStmt -> BREAK SEMI 
-- On BREAK reduce production jumpStmt -> BREAK SEMI 
-- On BOOLEANLIT reduce production jumpStmt -> BREAK SEMI 
-- On BOOLEAN reduce production jumpStmt -> BREAK SEMI 
-- On BNOT reduce production jumpStmt -> BREAK SEMI 
-- On ASSERT reduce production jumpStmt -> BREAK SEMI 

State 393:
jumpStmt -> BREAK IDENTIFIER . SEMI [ error WHILE VOID TRY THROW THIS SYNCHRONIZED SWITCH SUPER STRLIT SHORT SEMI RETURN RCURL PLUS NULLLIT NOT NEW MINUS LPAR LONG LCURL INTLIT INT INCREMENT IF IDENTIFIER FOR FLOATLIT FLOAT FINAL ELSE DOUBLELIT DOUBLE DO DECREMENT CONTINUE CHARLIT CHAR BYTE BREAK BOOLEANLIT BOOLEAN BNOT ASSERT ]
-- On SEMI shift to state 394

State 394:
jumpStmt -> BREAK IDENTIFIER SEMI . [ error WHILE VOID TRY THROW THIS SYNCHRONIZED SWITCH SUPER STRLIT SHORT SEMI RETURN RCURL PLUS NULLLIT NOT NEW MINUS LPAR LONG LCURL INTLIT INT INCREMENT IF IDENTIFIER FOR FLOATLIT FLOAT FINAL ELSE DOUBLELIT DOUBLE DO DECREMENT CONTINUE CHARLIT CHAR BYTE BREAK BOOLEANLIT BOOLEAN BNOT ASSERT ]
-- On error reduce production jumpStmt -> BREAK IDENTIFIER SEMI 
-- On WHILE reduce production jumpStmt -> BREAK IDENTIFIER SEMI 
-- On VOID reduce production jumpStmt -> BREAK IDENTIFIER SEMI 
-- On TRY reduce production jumpStmt -> BREAK IDENTIFIER SEMI 
-- On THROW reduce production jumpStmt -> BREAK IDENTIFIER SEMI 
-- On THIS reduce production jumpStmt -> BREAK IDENTIFIER SEMI 
-- On SYNCHRONIZED reduce production jumpStmt -> BREAK IDENTIFIER SEMI 
-- On SWITCH reduce production jumpStmt -> BREAK IDENTIFIER SEMI 
-- On SUPER reduce production jumpStmt -> BREAK IDENTIFIER SEMI 
-- On STRLIT reduce production jumpStmt -> BREAK IDENTIFIER SEMI 
-- On SHORT reduce production jumpStmt -> BREAK IDENTIFIER SEMI 
-- On SEMI reduce production jumpStmt -> BREAK IDENTIFIER SEMI 
-- On RETURN reduce production jumpStmt -> BREAK IDENTIFIER SEMI 
-- On RCURL reduce production jumpStmt -> BREAK IDENTIFIER SEMI 
-- On PLUS reduce production jumpStmt -> BREAK IDENTIFIER SEMI 
-- On NULLLIT reduce production jumpStmt -> BREAK IDENTIFIER SEMI 
-- On NOT reduce production jumpStmt -> BREAK IDENTIFIER SEMI 
-- On NEW reduce production jumpStmt -> BREAK IDENTIFIER SEMI 
-- On MINUS reduce production jumpStmt -> BREAK IDENTIFIER SEMI 
-- On LPAR reduce production jumpStmt -> BREAK IDENTIFIER SEMI 
-- On LONG reduce production jumpStmt -> BREAK IDENTIFIER SEMI 
-- On LCURL reduce production jumpStmt -> BREAK IDENTIFIER SEMI 
-- On INTLIT reduce production jumpStmt -> BREAK IDENTIFIER SEMI 
-- On INT reduce production jumpStmt -> BREAK IDENTIFIER SEMI 
-- On INCREMENT reduce production jumpStmt -> BREAK IDENTIFIER SEMI 
-- On IF reduce production jumpStmt -> BREAK IDENTIFIER SEMI 
-- On IDENTIFIER reduce production jumpStmt -> BREAK IDENTIFIER SEMI 
-- On FOR reduce production jumpStmt -> BREAK IDENTIFIER SEMI 
-- On FLOATLIT reduce production jumpStmt -> BREAK IDENTIFIER SEMI 
-- On FLOAT reduce production jumpStmt -> BREAK IDENTIFIER SEMI 
-- On FINAL reduce production jumpStmt -> BREAK IDENTIFIER SEMI 
-- On ELSE reduce production jumpStmt -> BREAK IDENTIFIER SEMI 
-- On DOUBLELIT reduce production jumpStmt -> BREAK IDENTIFIER SEMI 
-- On DOUBLE reduce production jumpStmt -> BREAK IDENTIFIER SEMI 
-- On DO reduce production jumpStmt -> BREAK IDENTIFIER SEMI 
-- On DECREMENT reduce production jumpStmt -> BREAK IDENTIFIER SEMI 
-- On CONTINUE reduce production jumpStmt -> BREAK IDENTIFIER SEMI 
-- On CHARLIT reduce production jumpStmt -> BREAK IDENTIFIER SEMI 
-- On CHAR reduce production jumpStmt -> BREAK IDENTIFIER SEMI 
-- On BYTE reduce production jumpStmt -> BREAK IDENTIFIER SEMI 
-- On BREAK reduce production jumpStmt -> BREAK IDENTIFIER SEMI 
-- On BOOLEANLIT reduce production jumpStmt -> BREAK IDENTIFIER SEMI 
-- On BOOLEAN reduce production jumpStmt -> BREAK IDENTIFIER SEMI 
-- On BNOT reduce production jumpStmt -> BREAK IDENTIFIER SEMI 
-- On ASSERT reduce production jumpStmt -> BREAK IDENTIFIER SEMI 

State 395:
assertStmt -> ASSERT . expression SEMI [ error WHILE VOID TRY THROW THIS SYNCHRONIZED SWITCH SUPER STRLIT SHORT SEMI RETURN RCURL PLUS NULLLIT NOT NEW MINUS LPAR LONG LCURL INTLIT INT INCREMENT IF IDENTIFIER FOR FLOATLIT FLOAT FINAL ELSE DOUBLELIT DOUBLE DO DECREMENT CONTINUE CHARLIT CHAR BYTE BREAK BOOLEANLIT BOOLEAN BNOT ASSERT ]
assertStmt -> ASSERT . expression COL expression SEMI [ error WHILE VOID TRY THROW THIS SYNCHRONIZED SWITCH SUPER STRLIT SHORT SEMI RETURN RCURL PLUS NULLLIT NOT NEW MINUS LPAR LONG LCURL INTLIT INT INCREMENT IF IDENTIFIER FOR FLOATLIT FLOAT FINAL ELSE DOUBLELIT DOUBLE DO DECREMENT CONTINUE CHARLIT CHAR BYTE BREAK BOOLEANLIT BOOLEAN BNOT ASSERT ]
-- On error shift to state 3
-- On VOID shift to state 6
-- On THIS shift to state 7
-- On SUPER shift to state 8
-- On STRLIT shift to state 9
-- On SHORT shift to state 10
-- On PLUS shift to state 11
-- On NULLLIT shift to state 12
-- On NOT shift to state 13
-- On NEW shift to state 14
-- On MINUS shift to state 26
-- On LPAR shift to state 27
-- On LONG shift to state 15
-- On INTLIT shift to state 28
-- On INT shift to state 16
-- On INCREMENT shift to state 29
-- On IDENTIFIER shift to state 17
-- On FLOATLIT shift to state 31
-- On FLOAT shift to state 18
-- On DOUBLELIT shift to state 32
-- On DOUBLE shift to state 19
-- On DECREMENT shift to state 33
-- On CHARLIT shift to state 34
-- On CHAR shift to state 20
-- On BYTE shift to state 21
-- On BOOLEANLIT shift to state 35
-- On BOOLEAN shift to state 22
-- On BNOT shift to state 36
-- On unaryExpression shift to state 44
-- On specialName shift to state 38
-- On shiftExpression shift to state 58
-- On relationalExpression shift to state 79
-- On realPostfixExpression shift to state 39
-- On qualifiedName shift to state 42
-- On primitiveType shift to state 61
-- On primaryExpression shift to state 64
-- On postfixExpression shift to state 65
-- On plainNewAllocationExpression shift to state 68
-- On notJustName shift to state 69
-- On newAllocationExpression shift to state 72
-- On multiplicativeExpression shift to state 73
-- On methodCall shift to state 75
-- On methodAccess shift to state 76
-- On logicalUnaryOperator shift to state 83
-- On logicalUnaryExpression shift to state 85
-- On inclusiveOrExpression shift to state 90
-- On fieldAccess shift to state 86
-- On expression shift to state 396
-- On exclusiveOrExpression shift to state 111
-- On equalityExpression shift to state 94
-- On conditionalOrExpression shift to state 112
-- On conditionalExpression shift to state 151
-- On conditionalAndExpression shift to state 117
-- On complexPrimaryNoParenthesis shift to state 87
-- On complexPrimary shift to state 88
-- On classAllocationExpression shift to state 100
-- On castExpression shift to state 103
-- On assignmentExpression shift to state 152
-- On arrayAllocationExpression shift to state 104
-- On arrayAccess shift to state 120
-- On arithmeticUnaryOperator shift to state 121
-- On andExpression shift to state 123
-- On additiveExpression shift to state 140

State 396:
assertStmt -> ASSERT expression . SEMI [ error WHILE VOID TRY THROW THIS SYNCHRONIZED SWITCH SUPER STRLIT SHORT SEMI RETURN RCURL PLUS NULLLIT NOT NEW MINUS LPAR LONG LCURL INTLIT INT INCREMENT IF IDENTIFIER FOR FLOATLIT FLOAT FINAL ELSE DOUBLELIT DOUBLE DO DECREMENT CONTINUE CHARLIT CHAR BYTE BREAK BOOLEANLIT BOOLEAN BNOT ASSERT ]
assertStmt -> ASSERT expression . COL expression SEMI [ error WHILE VOID TRY THROW THIS SYNCHRONIZED SWITCH SUPER STRLIT SHORT SEMI RETURN RCURL PLUS NULLLIT NOT NEW MINUS LPAR LONG LCURL INTLIT INT INCREMENT IF IDENTIFIER FOR FLOATLIT FLOAT FINAL ELSE DOUBLELIT DOUBLE DO DECREMENT CONTINUE CHARLIT CHAR BYTE BREAK BOOLEANLIT BOOLEAN BNOT ASSERT ]
-- On SEMI shift to state 397
-- On COL shift to state 398

State 397:
assertStmt -> ASSERT expression SEMI . [ error WHILE VOID TRY THROW THIS SYNCHRONIZED SWITCH SUPER STRLIT SHORT SEMI RETURN RCURL PLUS NULLLIT NOT NEW MINUS LPAR LONG LCURL INTLIT INT INCREMENT IF IDENTIFIER FOR FLOATLIT FLOAT FINAL ELSE DOUBLELIT DOUBLE DO DECREMENT CONTINUE CHARLIT CHAR BYTE BREAK BOOLEANLIT BOOLEAN BNOT ASSERT ]
-- On error reduce production assertStmt -> ASSERT expression SEMI 
-- On WHILE reduce production assertStmt -> ASSERT expression SEMI 
-- On VOID reduce production assertStmt -> ASSERT expression SEMI 
-- On TRY reduce production assertStmt -> ASSERT expression SEMI 
-- On THROW reduce production assertStmt -> ASSERT expression SEMI 
-- On THIS reduce production assertStmt -> ASSERT expression SEMI 
-- On SYNCHRONIZED reduce production assertStmt -> ASSERT expression SEMI 
-- On SWITCH reduce production assertStmt -> ASSERT expression SEMI 
-- On SUPER reduce production assertStmt -> ASSERT expression SEMI 
-- On STRLIT reduce production assertStmt -> ASSERT expression SEMI 
-- On SHORT reduce production assertStmt -> ASSERT expression SEMI 
-- On SEMI reduce production assertStmt -> ASSERT expression SEMI 
-- On RETURN reduce production assertStmt -> ASSERT expression SEMI 
-- On RCURL reduce production assertStmt -> ASSERT expression SEMI 
-- On PLUS reduce production assertStmt -> ASSERT expression SEMI 
-- On NULLLIT reduce production assertStmt -> ASSERT expression SEMI 
-- On NOT reduce production assertStmt -> ASSERT expression SEMI 
-- On NEW reduce production assertStmt -> ASSERT expression SEMI 
-- On MINUS reduce production assertStmt -> ASSERT expression SEMI 
-- On LPAR reduce production assertStmt -> ASSERT expression SEMI 
-- On LONG reduce production assertStmt -> ASSERT expression SEMI 
-- On LCURL reduce production assertStmt -> ASSERT expression SEMI 
-- On INTLIT reduce production assertStmt -> ASSERT expression SEMI 
-- On INT reduce production assertStmt -> ASSERT expression SEMI 
-- On INCREMENT reduce production assertStmt -> ASSERT expression SEMI 
-- On IF reduce production assertStmt -> ASSERT expression SEMI 
-- On IDENTIFIER reduce production assertStmt -> ASSERT expression SEMI 
-- On FOR reduce production assertStmt -> ASSERT expression SEMI 
-- On FLOATLIT reduce production assertStmt -> ASSERT expression SEMI 
-- On FLOAT reduce production assertStmt -> ASSERT expression SEMI 
-- On FINAL reduce production assertStmt -> ASSERT expression SEMI 
-- On ELSE reduce production assertStmt -> ASSERT expression SEMI 
-- On DOUBLELIT reduce production assertStmt -> ASSERT expression SEMI 
-- On DOUBLE reduce production assertStmt -> ASSERT expression SEMI 
-- On DO reduce production assertStmt -> ASSERT expression SEMI 
-- On DECREMENT reduce production assertStmt -> ASSERT expression SEMI 
-- On CONTINUE reduce production assertStmt -> ASSERT expression SEMI 
-- On CHARLIT reduce production assertStmt -> ASSERT expression SEMI 
-- On CHAR reduce production assertStmt -> ASSERT expression SEMI 
-- On BYTE reduce production assertStmt -> ASSERT expression SEMI 
-- On BREAK reduce production assertStmt -> ASSERT expression SEMI 
-- On BOOLEANLIT reduce production assertStmt -> ASSERT expression SEMI 
-- On BOOLEAN reduce production assertStmt -> ASSERT expression SEMI 
-- On BNOT reduce production assertStmt -> ASSERT expression SEMI 
-- On ASSERT reduce production assertStmt -> ASSERT expression SEMI 

State 398:
assertStmt -> ASSERT expression COL . expression SEMI [ error WHILE VOID TRY THROW THIS SYNCHRONIZED SWITCH SUPER STRLIT SHORT SEMI RETURN RCURL PLUS NULLLIT NOT NEW MINUS LPAR LONG LCURL INTLIT INT INCREMENT IF IDENTIFIER FOR FLOATLIT FLOAT FINAL ELSE DOUBLELIT DOUBLE DO DECREMENT CONTINUE CHARLIT CHAR BYTE BREAK BOOLEANLIT BOOLEAN BNOT ASSERT ]
-- On error shift to state 3
-- On VOID shift to state 6
-- On THIS shift to state 7
-- On SUPER shift to state 8
-- On STRLIT shift to state 9
-- On SHORT shift to state 10
-- On PLUS shift to state 11
-- On NULLLIT shift to state 12
-- On NOT shift to state 13
-- On NEW shift to state 14
-- On MINUS shift to state 26
-- On LPAR shift to state 27
-- On LONG shift to state 15
-- On INTLIT shift to state 28
-- On INT shift to state 16
-- On INCREMENT shift to state 29
-- On IDENTIFIER shift to state 17
-- On FLOATLIT shift to state 31
-- On FLOAT shift to state 18
-- On DOUBLELIT shift to state 32
-- On DOUBLE shift to state 19
-- On DECREMENT shift to state 33
-- On CHARLIT shift to state 34
-- On CHAR shift to state 20
-- On BYTE shift to state 21
-- On BOOLEANLIT shift to state 35
-- On BOOLEAN shift to state 22
-- On BNOT shift to state 36
-- On unaryExpression shift to state 44
-- On specialName shift to state 38
-- On shiftExpression shift to state 58
-- On relationalExpression shift to state 79
-- On realPostfixExpression shift to state 39
-- On qualifiedName shift to state 42
-- On primitiveType shift to state 61
-- On primaryExpression shift to state 64
-- On postfixExpression shift to state 65
-- On plainNewAllocationExpression shift to state 68
-- On notJustName shift to state 69
-- On newAllocationExpression shift to state 72
-- On multiplicativeExpression shift to state 73
-- On methodCall shift to state 75
-- On methodAccess shift to state 76
-- On logicalUnaryOperator shift to state 83
-- On logicalUnaryExpression shift to state 85
-- On inclusiveOrExpression shift to state 90
-- On fieldAccess shift to state 86
-- On expression shift to state 399
-- On exclusiveOrExpression shift to state 111
-- On equalityExpression shift to state 94
-- On conditionalOrExpression shift to state 112
-- On conditionalExpression shift to state 151
-- On conditionalAndExpression shift to state 117
-- On complexPrimaryNoParenthesis shift to state 87
-- On complexPrimary shift to state 88
-- On classAllocationExpression shift to state 100
-- On castExpression shift to state 103
-- On assignmentExpression shift to state 152
-- On arrayAllocationExpression shift to state 104
-- On arrayAccess shift to state 120
-- On arithmeticUnaryOperator shift to state 121
-- On andExpression shift to state 123
-- On additiveExpression shift to state 140

State 399:
assertStmt -> ASSERT expression COL expression . SEMI [ error WHILE VOID TRY THROW THIS SYNCHRONIZED SWITCH SUPER STRLIT SHORT SEMI RETURN RCURL PLUS NULLLIT NOT NEW MINUS LPAR LONG LCURL INTLIT INT INCREMENT IF IDENTIFIER FOR FLOATLIT FLOAT FINAL ELSE DOUBLELIT DOUBLE DO DECREMENT CONTINUE CHARLIT CHAR BYTE BREAK BOOLEANLIT BOOLEAN BNOT ASSERT ]
-- On SEMI shift to state 400

State 400:
assertStmt -> ASSERT expression COL expression SEMI . [ error WHILE VOID TRY THROW THIS SYNCHRONIZED SWITCH SUPER STRLIT SHORT SEMI RETURN RCURL PLUS NULLLIT NOT NEW MINUS LPAR LONG LCURL INTLIT INT INCREMENT IF IDENTIFIER FOR FLOATLIT FLOAT FINAL ELSE DOUBLELIT DOUBLE DO DECREMENT CONTINUE CHARLIT CHAR BYTE BREAK BOOLEANLIT BOOLEAN BNOT ASSERT ]
-- On error reduce production assertStmt -> ASSERT expression COL expression SEMI 
-- On WHILE reduce production assertStmt -> ASSERT expression COL expression SEMI 
-- On VOID reduce production assertStmt -> ASSERT expression COL expression SEMI 
-- On TRY reduce production assertStmt -> ASSERT expression COL expression SEMI 
-- On THROW reduce production assertStmt -> ASSERT expression COL expression SEMI 
-- On THIS reduce production assertStmt -> ASSERT expression COL expression SEMI 
-- On SYNCHRONIZED reduce production assertStmt -> ASSERT expression COL expression SEMI 
-- On SWITCH reduce production assertStmt -> ASSERT expression COL expression SEMI 
-- On SUPER reduce production assertStmt -> ASSERT expression COL expression SEMI 
-- On STRLIT reduce production assertStmt -> ASSERT expression COL expression SEMI 
-- On SHORT reduce production assertStmt -> ASSERT expression COL expression SEMI 
-- On SEMI reduce production assertStmt -> ASSERT expression COL expression SEMI 
-- On RETURN reduce production assertStmt -> ASSERT expression COL expression SEMI 
-- On RCURL reduce production assertStmt -> ASSERT expression COL expression SEMI 
-- On PLUS reduce production assertStmt -> ASSERT expression COL expression SEMI 
-- On NULLLIT reduce production assertStmt -> ASSERT expression COL expression SEMI 
-- On NOT reduce production assertStmt -> ASSERT expression COL expression SEMI 
-- On NEW reduce production assertStmt -> ASSERT expression COL expression SEMI 
-- On MINUS reduce production assertStmt -> ASSERT expression COL expression SEMI 
-- On LPAR reduce production assertStmt -> ASSERT expression COL expression SEMI 
-- On LONG reduce production assertStmt -> ASSERT expression COL expression SEMI 
-- On LCURL reduce production assertStmt -> ASSERT expression COL expression SEMI 
-- On INTLIT reduce production assertStmt -> ASSERT expression COL expression SEMI 
-- On INT reduce production assertStmt -> ASSERT expression COL expression SEMI 
-- On INCREMENT reduce production assertStmt -> ASSERT expression COL expression SEMI 
-- On IF reduce production assertStmt -> ASSERT expression COL expression SEMI 
-- On IDENTIFIER reduce production assertStmt -> ASSERT expression COL expression SEMI 
-- On FOR reduce production assertStmt -> ASSERT expression COL expression SEMI 
-- On FLOATLIT reduce production assertStmt -> ASSERT expression COL expression SEMI 
-- On FLOAT reduce production assertStmt -> ASSERT expression COL expression SEMI 
-- On FINAL reduce production assertStmt -> ASSERT expression COL expression SEMI 
-- On ELSE reduce production assertStmt -> ASSERT expression COL expression SEMI 
-- On DOUBLELIT reduce production assertStmt -> ASSERT expression COL expression SEMI 
-- On DOUBLE reduce production assertStmt -> ASSERT expression COL expression SEMI 
-- On DO reduce production assertStmt -> ASSERT expression COL expression SEMI 
-- On DECREMENT reduce production assertStmt -> ASSERT expression COL expression SEMI 
-- On CONTINUE reduce production assertStmt -> ASSERT expression COL expression SEMI 
-- On CHARLIT reduce production assertStmt -> ASSERT expression COL expression SEMI 
-- On CHAR reduce production assertStmt -> ASSERT expression COL expression SEMI 
-- On BYTE reduce production assertStmt -> ASSERT expression COL expression SEMI 
-- On BREAK reduce production assertStmt -> ASSERT expression COL expression SEMI 
-- On BOOLEANLIT reduce production assertStmt -> ASSERT expression COL expression SEMI 
-- On BOOLEAN reduce production assertStmt -> ASSERT expression COL expression SEMI 
-- On BNOT reduce production assertStmt -> ASSERT expression COL expression SEMI 
-- On ASSERT reduce production assertStmt -> ASSERT expression COL expression SEMI 

State 401:
iterStmt -> FOR LPAR forVarOpt COL expression RPAR statement . [ error WHILE VOID TRY THROW THIS SYNCHRONIZED SWITCH SUPER STRLIT SHORT SEMI RETURN RCURL PLUS NULLLIT NOT NEW MINUS LPAR LONG LCURL INTLIT INT INCREMENT IF IDENTIFIER FOR FLOATLIT FLOAT FINAL ELSE DOUBLELIT DOUBLE DO DECREMENT CONTINUE CHARLIT CHAR BYTE BREAK BOOLEANLIT BOOLEAN BNOT ASSERT ]
-- On error reduce production iterStmt -> FOR LPAR forVarOpt COL expression RPAR statement 
-- On WHILE reduce production iterStmt -> FOR LPAR forVarOpt COL expression RPAR statement 
-- On VOID reduce production iterStmt -> FOR LPAR forVarOpt COL expression RPAR statement 
-- On TRY reduce production iterStmt -> FOR LPAR forVarOpt COL expression RPAR statement 
-- On THROW reduce production iterStmt -> FOR LPAR forVarOpt COL expression RPAR statement 
-- On THIS reduce production iterStmt -> FOR LPAR forVarOpt COL expression RPAR statement 
-- On SYNCHRONIZED reduce production iterStmt -> FOR LPAR forVarOpt COL expression RPAR statement 
-- On SWITCH reduce production iterStmt -> FOR LPAR forVarOpt COL expression RPAR statement 
-- On SUPER reduce production iterStmt -> FOR LPAR forVarOpt COL expression RPAR statement 
-- On STRLIT reduce production iterStmt -> FOR LPAR forVarOpt COL expression RPAR statement 
-- On SHORT reduce production iterStmt -> FOR LPAR forVarOpt COL expression RPAR statement 
-- On SEMI reduce production iterStmt -> FOR LPAR forVarOpt COL expression RPAR statement 
-- On RETURN reduce production iterStmt -> FOR LPAR forVarOpt COL expression RPAR statement 
-- On RCURL reduce production iterStmt -> FOR LPAR forVarOpt COL expression RPAR statement 
-- On PLUS reduce production iterStmt -> FOR LPAR forVarOpt COL expression RPAR statement 
-- On NULLLIT reduce production iterStmt -> FOR LPAR forVarOpt COL expression RPAR statement 
-- On NOT reduce production iterStmt -> FOR LPAR forVarOpt COL expression RPAR statement 
-- On NEW reduce production iterStmt -> FOR LPAR forVarOpt COL expression RPAR statement 
-- On MINUS reduce production iterStmt -> FOR LPAR forVarOpt COL expression RPAR statement 
-- On LPAR reduce production iterStmt -> FOR LPAR forVarOpt COL expression RPAR statement 
-- On LONG reduce production iterStmt -> FOR LPAR forVarOpt COL expression RPAR statement 
-- On LCURL reduce production iterStmt -> FOR LPAR forVarOpt COL expression RPAR statement 
-- On INTLIT reduce production iterStmt -> FOR LPAR forVarOpt COL expression RPAR statement 
-- On INT reduce production iterStmt -> FOR LPAR forVarOpt COL expression RPAR statement 
-- On INCREMENT reduce production iterStmt -> FOR LPAR forVarOpt COL expression RPAR statement 
-- On IF reduce production iterStmt -> FOR LPAR forVarOpt COL expression RPAR statement 
-- On IDENTIFIER reduce production iterStmt -> FOR LPAR forVarOpt COL expression RPAR statement 
-- On FOR reduce production iterStmt -> FOR LPAR forVarOpt COL expression RPAR statement 
-- On FLOATLIT reduce production iterStmt -> FOR LPAR forVarOpt COL expression RPAR statement 
-- On FLOAT reduce production iterStmt -> FOR LPAR forVarOpt COL expression RPAR statement 
-- On FINAL reduce production iterStmt -> FOR LPAR forVarOpt COL expression RPAR statement 
-- On ELSE reduce production iterStmt -> FOR LPAR forVarOpt COL expression RPAR statement 
-- On DOUBLELIT reduce production iterStmt -> FOR LPAR forVarOpt COL expression RPAR statement 
-- On DOUBLE reduce production iterStmt -> FOR LPAR forVarOpt COL expression RPAR statement 
-- On DO reduce production iterStmt -> FOR LPAR forVarOpt COL expression RPAR statement 
-- On DECREMENT reduce production iterStmt -> FOR LPAR forVarOpt COL expression RPAR statement 
-- On CONTINUE reduce production iterStmt -> FOR LPAR forVarOpt COL expression RPAR statement 
-- On CHARLIT reduce production iterStmt -> FOR LPAR forVarOpt COL expression RPAR statement 
-- On CHAR reduce production iterStmt -> FOR LPAR forVarOpt COL expression RPAR statement 
-- On BYTE reduce production iterStmt -> FOR LPAR forVarOpt COL expression RPAR statement 
-- On BREAK reduce production iterStmt -> FOR LPAR forVarOpt COL expression RPAR statement 
-- On BOOLEANLIT reduce production iterStmt -> FOR LPAR forVarOpt COL expression RPAR statement 
-- On BOOLEAN reduce production iterStmt -> FOR LPAR forVarOpt COL expression RPAR statement 
-- On BNOT reduce production iterStmt -> FOR LPAR forVarOpt COL expression RPAR statement 
-- On ASSERT reduce production iterStmt -> FOR LPAR forVarOpt COL expression RPAR statement 

State 402:
statement -> selectStmt . [ error WHILE VOID TRY THROW THIS SYNCHRONIZED SWITCH SUPER STRLIT SHORT SEMI RETURN RCURL PLUS NULLLIT NOT NEW MINUS LPAR LONG LCURL INTLIT INT INCREMENT IF IDENTIFIER FOR FLOATLIT FLOAT FINAL ELSE DOUBLELIT DOUBLE DO DECREMENT CONTINUE CHARLIT CHAR BYTE BREAK BOOLEANLIT BOOLEAN BNOT ASSERT ]
-- On error reduce production statement -> selectStmt 
-- On WHILE reduce production statement -> selectStmt 
-- On VOID reduce production statement -> selectStmt 
-- On TRY reduce production statement -> selectStmt 
-- On THROW reduce production statement -> selectStmt 
-- On THIS reduce production statement -> selectStmt 
-- On SYNCHRONIZED reduce production statement -> selectStmt 
-- On SWITCH reduce production statement -> selectStmt 
-- On SUPER reduce production statement -> selectStmt 
-- On STRLIT reduce production statement -> selectStmt 
-- On SHORT reduce production statement -> selectStmt 
-- On SEMI reduce production statement -> selectStmt 
-- On RETURN reduce production statement -> selectStmt 
-- On RCURL reduce production statement -> selectStmt 
-- On PLUS reduce production statement -> selectStmt 
-- On NULLLIT reduce production statement -> selectStmt 
-- On NOT reduce production statement -> selectStmt 
-- On NEW reduce production statement -> selectStmt 
-- On MINUS reduce production statement -> selectStmt 
-- On LPAR reduce production statement -> selectStmt 
-- On LONG reduce production statement -> selectStmt 
-- On LCURL reduce production statement -> selectStmt 
-- On INTLIT reduce production statement -> selectStmt 
-- On INT reduce production statement -> selectStmt 
-- On INCREMENT reduce production statement -> selectStmt 
-- On IF reduce production statement -> selectStmt 
-- On IDENTIFIER reduce production statement -> selectStmt 
-- On FOR reduce production statement -> selectStmt 
-- On FLOATLIT reduce production statement -> selectStmt 
-- On FLOAT reduce production statement -> selectStmt 
-- On FINAL reduce production statement -> selectStmt 
-- On ELSE reduce production statement -> selectStmt 
-- On DOUBLELIT reduce production statement -> selectStmt 
-- On DOUBLE reduce production statement -> selectStmt 
-- On DO reduce production statement -> selectStmt 
-- On DECREMENT reduce production statement -> selectStmt 
-- On CONTINUE reduce production statement -> selectStmt 
-- On CHARLIT reduce production statement -> selectStmt 
-- On CHAR reduce production statement -> selectStmt 
-- On BYTE reduce production statement -> selectStmt 
-- On BREAK reduce production statement -> selectStmt 
-- On BOOLEANLIT reduce production statement -> selectStmt 
-- On BOOLEAN reduce production statement -> selectStmt 
-- On BNOT reduce production statement -> selectStmt 
-- On ASSERT reduce production statement -> selectStmt 

State 403:
statement -> labelStmt . [ error WHILE VOID TRY THROW THIS SYNCHRONIZED SWITCH SUPER STRLIT SHORT SEMI RETURN RCURL PLUS NULLLIT NOT NEW MINUS LPAR LONG LCURL INTLIT INT INCREMENT IF IDENTIFIER FOR FLOATLIT FLOAT FINAL ELSE DOUBLELIT DOUBLE DO DECREMENT CONTINUE CHARLIT CHAR BYTE BREAK BOOLEANLIT BOOLEAN BNOT ASSERT ]
-- On error reduce production statement -> labelStmt 
-- On WHILE reduce production statement -> labelStmt 
-- On VOID reduce production statement -> labelStmt 
-- On TRY reduce production statement -> labelStmt 
-- On THROW reduce production statement -> labelStmt 
-- On THIS reduce production statement -> labelStmt 
-- On SYNCHRONIZED reduce production statement -> labelStmt 
-- On SWITCH reduce production statement -> labelStmt 
-- On SUPER reduce production statement -> labelStmt 
-- On STRLIT reduce production statement -> labelStmt 
-- On SHORT reduce production statement -> labelStmt 
-- On SEMI reduce production statement -> labelStmt 
-- On RETURN reduce production statement -> labelStmt 
-- On RCURL reduce production statement -> labelStmt 
-- On PLUS reduce production statement -> labelStmt 
-- On NULLLIT reduce production statement -> labelStmt 
-- On NOT reduce production statement -> labelStmt 
-- On NEW reduce production statement -> labelStmt 
-- On MINUS reduce production statement -> labelStmt 
-- On LPAR reduce production statement -> labelStmt 
-- On LONG reduce production statement -> labelStmt 
-- On LCURL reduce production statement -> labelStmt 
-- On INTLIT reduce production statement -> labelStmt 
-- On INT reduce production statement -> labelStmt 
-- On INCREMENT reduce production statement -> labelStmt 
-- On IF reduce production statement -> labelStmt 
-- On IDENTIFIER reduce production statement -> labelStmt 
-- On FOR reduce production statement -> labelStmt 
-- On FLOATLIT reduce production statement -> labelStmt 
-- On FLOAT reduce production statement -> labelStmt 
-- On FINAL reduce production statement -> labelStmt 
-- On ELSE reduce production statement -> labelStmt 
-- On DOUBLELIT reduce production statement -> labelStmt 
-- On DOUBLE reduce production statement -> labelStmt 
-- On DO reduce production statement -> labelStmt 
-- On DECREMENT reduce production statement -> labelStmt 
-- On CONTINUE reduce production statement -> labelStmt 
-- On CHARLIT reduce production statement -> labelStmt 
-- On CHAR reduce production statement -> labelStmt 
-- On BYTE reduce production statement -> labelStmt 
-- On BREAK reduce production statement -> labelStmt 
-- On BOOLEANLIT reduce production statement -> labelStmt 
-- On BOOLEAN reduce production statement -> labelStmt 
-- On BNOT reduce production statement -> labelStmt 
-- On ASSERT reduce production statement -> labelStmt 

State 404:
statement -> jumpStmt . [ error WHILE VOID TRY THROW THIS SYNCHRONIZED SWITCH SUPER STRLIT SHORT SEMI RETURN RCURL PLUS NULLLIT NOT NEW MINUS LPAR LONG LCURL INTLIT INT INCREMENT IF IDENTIFIER FOR FLOATLIT FLOAT FINAL ELSE DOUBLELIT DOUBLE DO DECREMENT CONTINUE CHARLIT CHAR BYTE BREAK BOOLEANLIT BOOLEAN BNOT ASSERT ]
-- On error reduce production statement -> jumpStmt 
-- On WHILE reduce production statement -> jumpStmt 
-- On VOID reduce production statement -> jumpStmt 
-- On TRY reduce production statement -> jumpStmt 
-- On THROW reduce production statement -> jumpStmt 
-- On THIS reduce production statement -> jumpStmt 
-- On SYNCHRONIZED reduce production statement -> jumpStmt 
-- On SWITCH reduce production statement -> jumpStmt 
-- On SUPER reduce production statement -> jumpStmt 
-- On STRLIT reduce production statement -> jumpStmt 
-- On SHORT reduce production statement -> jumpStmt 
-- On SEMI reduce production statement -> jumpStmt 
-- On RETURN reduce production statement -> jumpStmt 
-- On RCURL reduce production statement -> jumpStmt 
-- On PLUS reduce production statement -> jumpStmt 
-- On NULLLIT reduce production statement -> jumpStmt 
-- On NOT reduce production statement -> jumpStmt 
-- On NEW reduce production statement -> jumpStmt 
-- On MINUS reduce production statement -> jumpStmt 
-- On LPAR reduce production statement -> jumpStmt 
-- On LONG reduce production statement -> jumpStmt 
-- On LCURL reduce production statement -> jumpStmt 
-- On INTLIT reduce production statement -> jumpStmt 
-- On INT reduce production statement -> jumpStmt 
-- On INCREMENT reduce production statement -> jumpStmt 
-- On IF reduce production statement -> jumpStmt 
-- On IDENTIFIER reduce production statement -> jumpStmt 
-- On FOR reduce production statement -> jumpStmt 
-- On FLOATLIT reduce production statement -> jumpStmt 
-- On FLOAT reduce production statement -> jumpStmt 
-- On FINAL reduce production statement -> jumpStmt 
-- On ELSE reduce production statement -> jumpStmt 
-- On DOUBLELIT reduce production statement -> jumpStmt 
-- On DOUBLE reduce production statement -> jumpStmt 
-- On DO reduce production statement -> jumpStmt 
-- On DECREMENT reduce production statement -> jumpStmt 
-- On CONTINUE reduce production statement -> jumpStmt 
-- On CHARLIT reduce production statement -> jumpStmt 
-- On CHAR reduce production statement -> jumpStmt 
-- On BYTE reduce production statement -> jumpStmt 
-- On BREAK reduce production statement -> jumpStmt 
-- On BOOLEANLIT reduce production statement -> jumpStmt 
-- On BOOLEAN reduce production statement -> jumpStmt 
-- On BNOT reduce production statement -> jumpStmt 
-- On ASSERT reduce production statement -> jumpStmt 

State 405:
statement -> iterStmt . [ error WHILE VOID TRY THROW THIS SYNCHRONIZED SWITCH SUPER STRLIT SHORT SEMI RETURN RCURL PLUS NULLLIT NOT NEW MINUS LPAR LONG LCURL INTLIT INT INCREMENT IF IDENTIFIER FOR FLOATLIT FLOAT FINAL ELSE DOUBLELIT DOUBLE DO DECREMENT CONTINUE CHARLIT CHAR BYTE BREAK BOOLEANLIT BOOLEAN BNOT ASSERT ]
-- On error reduce production statement -> iterStmt 
-- On WHILE reduce production statement -> iterStmt 
-- On VOID reduce production statement -> iterStmt 
-- On TRY reduce production statement -> iterStmt 
-- On THROW reduce production statement -> iterStmt 
-- On THIS reduce production statement -> iterStmt 
-- On SYNCHRONIZED reduce production statement -> iterStmt 
-- On SWITCH reduce production statement -> iterStmt 
-- On SUPER reduce production statement -> iterStmt 
-- On STRLIT reduce production statement -> iterStmt 
-- On SHORT reduce production statement -> iterStmt 
-- On SEMI reduce production statement -> iterStmt 
-- On RETURN reduce production statement -> iterStmt 
-- On RCURL reduce production statement -> iterStmt 
-- On PLUS reduce production statement -> iterStmt 
-- On NULLLIT reduce production statement -> iterStmt 
-- On NOT reduce production statement -> iterStmt 
-- On NEW reduce production statement -> iterStmt 
-- On MINUS reduce production statement -> iterStmt 
-- On LPAR reduce production statement -> iterStmt 
-- On LONG reduce production statement -> iterStmt 
-- On LCURL reduce production statement -> iterStmt 
-- On INTLIT reduce production statement -> iterStmt 
-- On INT reduce production statement -> iterStmt 
-- On INCREMENT reduce production statement -> iterStmt 
-- On IF reduce production statement -> iterStmt 
-- On IDENTIFIER reduce production statement -> iterStmt 
-- On FOR reduce production statement -> iterStmt 
-- On FLOATLIT reduce production statement -> iterStmt 
-- On FLOAT reduce production statement -> iterStmt 
-- On FINAL reduce production statement -> iterStmt 
-- On ELSE reduce production statement -> iterStmt 
-- On DOUBLELIT reduce production statement -> iterStmt 
-- On DOUBLE reduce production statement -> iterStmt 
-- On DO reduce production statement -> iterStmt 
-- On DECREMENT reduce production statement -> iterStmt 
-- On CONTINUE reduce production statement -> iterStmt 
-- On CHARLIT reduce production statement -> iterStmt 
-- On CHAR reduce production statement -> iterStmt 
-- On BYTE reduce production statement -> iterStmt 
-- On BREAK reduce production statement -> iterStmt 
-- On BOOLEANLIT reduce production statement -> iterStmt 
-- On BOOLEAN reduce production statement -> iterStmt 
-- On BNOT reduce production statement -> iterStmt 
-- On ASSERT reduce production statement -> iterStmt 

State 406:
statement -> guardingStmt . [ error WHILE VOID TRY THROW THIS SYNCHRONIZED SWITCH SUPER STRLIT SHORT SEMI RETURN RCURL PLUS NULLLIT NOT NEW MINUS LPAR LONG LCURL INTLIT INT INCREMENT IF IDENTIFIER FOR FLOATLIT FLOAT FINAL ELSE DOUBLELIT DOUBLE DO DECREMENT CONTINUE CHARLIT CHAR BYTE BREAK BOOLEANLIT BOOLEAN BNOT ASSERT ]
-- On error reduce production statement -> guardingStmt 
-- On WHILE reduce production statement -> guardingStmt 
-- On VOID reduce production statement -> guardingStmt 
-- On TRY reduce production statement -> guardingStmt 
-- On THROW reduce production statement -> guardingStmt 
-- On THIS reduce production statement -> guardingStmt 
-- On SYNCHRONIZED reduce production statement -> guardingStmt 
-- On SWITCH reduce production statement -> guardingStmt 
-- On SUPER reduce production statement -> guardingStmt 
-- On STRLIT reduce production statement -> guardingStmt 
-- On SHORT reduce production statement -> guardingStmt 
-- On SEMI reduce production statement -> guardingStmt 
-- On RETURN reduce production statement -> guardingStmt 
-- On RCURL reduce production statement -> guardingStmt 
-- On PLUS reduce production statement -> guardingStmt 
-- On NULLLIT reduce production statement -> guardingStmt 
-- On NOT reduce production statement -> guardingStmt 
-- On NEW reduce production statement -> guardingStmt 
-- On MINUS reduce production statement -> guardingStmt 
-- On LPAR reduce production statement -> guardingStmt 
-- On LONG reduce production statement -> guardingStmt 
-- On LCURL reduce production statement -> guardingStmt 
-- On INTLIT reduce production statement -> guardingStmt 
-- On INT reduce production statement -> guardingStmt 
-- On INCREMENT reduce production statement -> guardingStmt 
-- On IF reduce production statement -> guardingStmt 
-- On IDENTIFIER reduce production statement -> guardingStmt 
-- On FOR reduce production statement -> guardingStmt 
-- On FLOATLIT reduce production statement -> guardingStmt 
-- On FLOAT reduce production statement -> guardingStmt 
-- On FINAL reduce production statement -> guardingStmt 
-- On ELSE reduce production statement -> guardingStmt 
-- On DOUBLELIT reduce production statement -> guardingStmt 
-- On DOUBLE reduce production statement -> guardingStmt 
-- On DO reduce production statement -> guardingStmt 
-- On DECREMENT reduce production statement -> guardingStmt 
-- On CONTINUE reduce production statement -> guardingStmt 
-- On CHARLIT reduce production statement -> guardingStmt 
-- On CHAR reduce production statement -> guardingStmt 
-- On BYTE reduce production statement -> guardingStmt 
-- On BREAK reduce production statement -> guardingStmt 
-- On BOOLEANLIT reduce production statement -> guardingStmt 
-- On BOOLEAN reduce production statement -> guardingStmt 
-- On BNOT reduce production statement -> guardingStmt 
-- On ASSERT reduce production statement -> guardingStmt 

State 407:
statement -> expressionStmt . SEMI [ error WHILE VOID TRY THROW THIS SYNCHRONIZED SWITCH SUPER STRLIT SHORT SEMI RETURN RCURL PLUS NULLLIT NOT NEW MINUS LPAR LONG LCURL INTLIT INT INCREMENT IF IDENTIFIER FOR FLOATLIT FLOAT FINAL ELSE DOUBLELIT DOUBLE DO DECREMENT CONTINUE CHARLIT CHAR BYTE BREAK BOOLEANLIT BOOLEAN BNOT ASSERT ]
-- On SEMI shift to state 408

State 408:
statement -> expressionStmt SEMI . [ error WHILE VOID TRY THROW THIS SYNCHRONIZED SWITCH SUPER STRLIT SHORT SEMI RETURN RCURL PLUS NULLLIT NOT NEW MINUS LPAR LONG LCURL INTLIT INT INCREMENT IF IDENTIFIER FOR FLOATLIT FLOAT FINAL ELSE DOUBLELIT DOUBLE DO DECREMENT CONTINUE CHARLIT CHAR BYTE BREAK BOOLEANLIT BOOLEAN BNOT ASSERT ]
-- On error reduce production statement -> expressionStmt SEMI 
-- On WHILE reduce production statement -> expressionStmt SEMI 
-- On VOID reduce production statement -> expressionStmt SEMI 
-- On TRY reduce production statement -> expressionStmt SEMI 
-- On THROW reduce production statement -> expressionStmt SEMI 
-- On THIS reduce production statement -> expressionStmt SEMI 
-- On SYNCHRONIZED reduce production statement -> expressionStmt SEMI 
-- On SWITCH reduce production statement -> expressionStmt SEMI 
-- On SUPER reduce production statement -> expressionStmt SEMI 
-- On STRLIT reduce production statement -> expressionStmt SEMI 
-- On SHORT reduce production statement -> expressionStmt SEMI 
-- On SEMI reduce production statement -> expressionStmt SEMI 
-- On RETURN reduce production statement -> expressionStmt SEMI 
-- On RCURL reduce production statement -> expressionStmt SEMI 
-- On PLUS reduce production statement -> expressionStmt SEMI 
-- On NULLLIT reduce production statement -> expressionStmt SEMI 
-- On NOT reduce production statement -> expressionStmt SEMI 
-- On NEW reduce production statement -> expressionStmt SEMI 
-- On MINUS reduce production statement -> expressionStmt SEMI 
-- On LPAR reduce production statement -> expressionStmt SEMI 
-- On LONG reduce production statement -> expressionStmt SEMI 
-- On LCURL reduce production statement -> expressionStmt SEMI 
-- On INTLIT reduce production statement -> expressionStmt SEMI 
-- On INT reduce production statement -> expressionStmt SEMI 
-- On INCREMENT reduce production statement -> expressionStmt SEMI 
-- On IF reduce production statement -> expressionStmt SEMI 
-- On IDENTIFIER reduce production statement -> expressionStmt SEMI 
-- On FOR reduce production statement -> expressionStmt SEMI 
-- On FLOATLIT reduce production statement -> expressionStmt SEMI 
-- On FLOAT reduce production statement -> expressionStmt SEMI 
-- On FINAL reduce production statement -> expressionStmt SEMI 
-- On ELSE reduce production statement -> expressionStmt SEMI 
-- On DOUBLELIT reduce production statement -> expressionStmt SEMI 
-- On DOUBLE reduce production statement -> expressionStmt SEMI 
-- On DO reduce production statement -> expressionStmt SEMI 
-- On DECREMENT reduce production statement -> expressionStmt SEMI 
-- On CONTINUE reduce production statement -> expressionStmt SEMI 
-- On CHARLIT reduce production statement -> expressionStmt SEMI 
-- On CHAR reduce production statement -> expressionStmt SEMI 
-- On BYTE reduce production statement -> expressionStmt SEMI 
-- On BREAK reduce production statement -> expressionStmt SEMI 
-- On BOOLEANLIT reduce production statement -> expressionStmt SEMI 
-- On BOOLEAN reduce production statement -> expressionStmt SEMI 
-- On BNOT reduce production statement -> expressionStmt SEMI 
-- On ASSERT reduce production statement -> expressionStmt SEMI 

State 409:
statement -> emptyStmt . [ error WHILE VOID TRY THROW THIS SYNCHRONIZED SWITCH SUPER STRLIT SHORT SEMI RETURN RCURL PLUS NULLLIT NOT NEW MINUS LPAR LONG LCURL INTLIT INT INCREMENT IF IDENTIFIER FOR FLOATLIT FLOAT FINAL ELSE DOUBLELIT DOUBLE DO DECREMENT CONTINUE CHARLIT CHAR BYTE BREAK BOOLEANLIT BOOLEAN BNOT ASSERT ]
-- On error reduce production statement -> emptyStmt 
-- On WHILE reduce production statement -> emptyStmt 
-- On VOID reduce production statement -> emptyStmt 
-- On TRY reduce production statement -> emptyStmt 
-- On THROW reduce production statement -> emptyStmt 
-- On THIS reduce production statement -> emptyStmt 
-- On SYNCHRONIZED reduce production statement -> emptyStmt 
-- On SWITCH reduce production statement -> emptyStmt 
-- On SUPER reduce production statement -> emptyStmt 
-- On STRLIT reduce production statement -> emptyStmt 
-- On SHORT reduce production statement -> emptyStmt 
-- On SEMI reduce production statement -> emptyStmt 
-- On RETURN reduce production statement -> emptyStmt 
-- On RCURL reduce production statement -> emptyStmt 
-- On PLUS reduce production statement -> emptyStmt 
-- On NULLLIT reduce production statement -> emptyStmt 
-- On NOT reduce production statement -> emptyStmt 
-- On NEW reduce production statement -> emptyStmt 
-- On MINUS reduce production statement -> emptyStmt 
-- On LPAR reduce production statement -> emptyStmt 
-- On LONG reduce production statement -> emptyStmt 
-- On LCURL reduce production statement -> emptyStmt 
-- On INTLIT reduce production statement -> emptyStmt 
-- On INT reduce production statement -> emptyStmt 
-- On INCREMENT reduce production statement -> emptyStmt 
-- On IF reduce production statement -> emptyStmt 
-- On IDENTIFIER reduce production statement -> emptyStmt 
-- On FOR reduce production statement -> emptyStmt 
-- On FLOATLIT reduce production statement -> emptyStmt 
-- On FLOAT reduce production statement -> emptyStmt 
-- On FINAL reduce production statement -> emptyStmt 
-- On ELSE reduce production statement -> emptyStmt 
-- On DOUBLELIT reduce production statement -> emptyStmt 
-- On DOUBLE reduce production statement -> emptyStmt 
-- On DO reduce production statement -> emptyStmt 
-- On DECREMENT reduce production statement -> emptyStmt 
-- On CONTINUE reduce production statement -> emptyStmt 
-- On CHARLIT reduce production statement -> emptyStmt 
-- On CHAR reduce production statement -> emptyStmt 
-- On BYTE reduce production statement -> emptyStmt 
-- On BREAK reduce production statement -> emptyStmt 
-- On BOOLEANLIT reduce production statement -> emptyStmt 
-- On BOOLEAN reduce production statement -> emptyStmt 
-- On BNOT reduce production statement -> emptyStmt 
-- On ASSERT reduce production statement -> emptyStmt 

State 410:
statement -> block . [ error WHILE VOID TRY THROW THIS SYNCHRONIZED SWITCH SUPER STRLIT SHORT SEMI RETURN RCURL PLUS NULLLIT NOT NEW MINUS LPAR LONG LCURL INTLIT INT INCREMENT IF IDENTIFIER FOR FLOATLIT FLOAT FINAL ELSE DOUBLELIT DOUBLE DO DECREMENT CONTINUE CHARLIT CHAR BYTE BREAK BOOLEANLIT BOOLEAN BNOT ASSERT ]
-- On error reduce production statement -> block 
-- On WHILE reduce production statement -> block 
-- On VOID reduce production statement -> block 
-- On TRY reduce production statement -> block 
-- On THROW reduce production statement -> block 
-- On THIS reduce production statement -> block 
-- On SYNCHRONIZED reduce production statement -> block 
-- On SWITCH reduce production statement -> block 
-- On SUPER reduce production statement -> block 
-- On STRLIT reduce production statement -> block 
-- On SHORT reduce production statement -> block 
-- On SEMI reduce production statement -> block 
-- On RETURN reduce production statement -> block 
-- On RCURL reduce production statement -> block 
-- On PLUS reduce production statement -> block 
-- On NULLLIT reduce production statement -> block 
-- On NOT reduce production statement -> block 
-- On NEW reduce production statement -> block 
-- On MINUS reduce production statement -> block 
-- On LPAR reduce production statement -> block 
-- On LONG reduce production statement -> block 
-- On LCURL reduce production statement -> block 
-- On INTLIT reduce production statement -> block 
-- On INT reduce production statement -> block 
-- On INCREMENT reduce production statement -> block 
-- On IF reduce production statement -> block 
-- On IDENTIFIER reduce production statement -> block 
-- On FOR reduce production statement -> block 
-- On FLOATLIT reduce production statement -> block 
-- On FLOAT reduce production statement -> block 
-- On FINAL reduce production statement -> block 
-- On ELSE reduce production statement -> block 
-- On DOUBLELIT reduce production statement -> block 
-- On DOUBLE reduce production statement -> block 
-- On DO reduce production statement -> block 
-- On DECREMENT reduce production statement -> block 
-- On CONTINUE reduce production statement -> block 
-- On CHARLIT reduce production statement -> block 
-- On CHAR reduce production statement -> block 
-- On BYTE reduce production statement -> block 
-- On BREAK reduce production statement -> block 
-- On BOOLEANLIT reduce production statement -> block 
-- On BOOLEAN reduce production statement -> block 
-- On BNOT reduce production statement -> block 
-- On ASSERT reduce production statement -> block 

State 411:
statement -> assertStmt . [ error WHILE VOID TRY THROW THIS SYNCHRONIZED SWITCH SUPER STRLIT SHORT SEMI RETURN RCURL PLUS NULLLIT NOT NEW MINUS LPAR LONG LCURL INTLIT INT INCREMENT IF IDENTIFIER FOR FLOATLIT FLOAT FINAL ELSE DOUBLELIT DOUBLE DO DECREMENT CONTINUE CHARLIT CHAR BYTE BREAK BOOLEANLIT BOOLEAN BNOT ASSERT ]
-- On error reduce production statement -> assertStmt 
-- On WHILE reduce production statement -> assertStmt 
-- On VOID reduce production statement -> assertStmt 
-- On TRY reduce production statement -> assertStmt 
-- On THROW reduce production statement -> assertStmt 
-- On THIS reduce production statement -> assertStmt 
-- On SYNCHRONIZED reduce production statement -> assertStmt 
-- On SWITCH reduce production statement -> assertStmt 
-- On SUPER reduce production statement -> assertStmt 
-- On STRLIT reduce production statement -> assertStmt 
-- On SHORT reduce production statement -> assertStmt 
-- On SEMI reduce production statement -> assertStmt 
-- On RETURN reduce production statement -> assertStmt 
-- On RCURL reduce production statement -> assertStmt 
-- On PLUS reduce production statement -> assertStmt 
-- On NULLLIT reduce production statement -> assertStmt 
-- On NOT reduce production statement -> assertStmt 
-- On NEW reduce production statement -> assertStmt 
-- On MINUS reduce production statement -> assertStmt 
-- On LPAR reduce production statement -> assertStmt 
-- On LONG reduce production statement -> assertStmt 
-- On LCURL reduce production statement -> assertStmt 
-- On INTLIT reduce production statement -> assertStmt 
-- On INT reduce production statement -> assertStmt 
-- On INCREMENT reduce production statement -> assertStmt 
-- On IF reduce production statement -> assertStmt 
-- On IDENTIFIER reduce production statement -> assertStmt 
-- On FOR reduce production statement -> assertStmt 
-- On FLOATLIT reduce production statement -> assertStmt 
-- On FLOAT reduce production statement -> assertStmt 
-- On FINAL reduce production statement -> assertStmt 
-- On ELSE reduce production statement -> assertStmt 
-- On DOUBLELIT reduce production statement -> assertStmt 
-- On DOUBLE reduce production statement -> assertStmt 
-- On DO reduce production statement -> assertStmt 
-- On DECREMENT reduce production statement -> assertStmt 
-- On CONTINUE reduce production statement -> assertStmt 
-- On CHARLIT reduce production statement -> assertStmt 
-- On CHAR reduce production statement -> assertStmt 
-- On BYTE reduce production statement -> assertStmt 
-- On BREAK reduce production statement -> assertStmt 
-- On BOOLEANLIT reduce production statement -> assertStmt 
-- On BOOLEAN reduce production statement -> assertStmt 
-- On BNOT reduce production statement -> assertStmt 
-- On ASSERT reduce production statement -> assertStmt 

State 412:
iterStmt -> FOR LPAR forInit . forExpr forIncr RPAR statement [ error WHILE VOID TRY THROW THIS SYNCHRONIZED SWITCH SUPER STRLIT SHORT SEMI RETURN RCURL PLUS NULLLIT NOT NEW MINUS LPAR LONG LCURL INTLIT INT INCREMENT IF IDENTIFIER FOR FLOATLIT FLOAT FINAL ELSE DOUBLELIT DOUBLE DO DECREMENT CONTINUE CHARLIT CHAR BYTE BREAK BOOLEANLIT BOOLEAN BNOT ASSERT ]
iterStmt -> FOR LPAR forInit . forExpr RPAR statement [ error WHILE VOID TRY THROW THIS SYNCHRONIZED SWITCH SUPER STRLIT SHORT SEMI RETURN RCURL PLUS NULLLIT NOT NEW MINUS LPAR LONG LCURL INTLIT INT INCREMENT IF IDENTIFIER FOR FLOATLIT FLOAT FINAL ELSE DOUBLELIT DOUBLE DO DECREMENT CONTINUE CHARLIT CHAR BYTE BREAK BOOLEANLIT BOOLEAN BNOT ASSERT ]
-- On error shift to state 3
-- On VOID shift to state 6
-- On THIS shift to state 7
-- On SUPER shift to state 8
-- On STRLIT shift to state 9
-- On SHORT shift to state 10
-- On SEMI shift to state 363
-- On PLUS shift to state 11
-- On NULLLIT shift to state 12
-- On NOT shift to state 13
-- On NEW shift to state 14
-- On MINUS shift to state 26
-- On LPAR shift to state 27
-- On LONG shift to state 15
-- On INTLIT shift to state 28
-- On INT shift to state 16
-- On INCREMENT shift to state 29
-- On IDENTIFIER shift to state 17
-- On FLOATLIT shift to state 31
-- On FLOAT shift to state 18
-- On DOUBLELIT shift to state 32
-- On DOUBLE shift to state 19
-- On DECREMENT shift to state 33
-- On CHARLIT shift to state 34
-- On CHAR shift to state 20
-- On BYTE shift to state 21
-- On BOOLEANLIT shift to state 35
-- On BOOLEAN shift to state 22
-- On BNOT shift to state 36
-- On unaryExpression shift to state 44
-- On specialName shift to state 38
-- On shiftExpression shift to state 58
-- On relationalExpression shift to state 79
-- On realPostfixExpression shift to state 39
-- On qualifiedName shift to state 42
-- On primitiveType shift to state 61
-- On primaryExpression shift to state 64
-- On postfixExpression shift to state 65
-- On plainNewAllocationExpression shift to state 68
-- On notJustName shift to state 69
-- On newAllocationExpression shift to state 72
-- On multiplicativeExpression shift to state 73
-- On methodCall shift to state 75
-- On methodAccess shift to state 76
-- On logicalUnaryOperator shift to state 83
-- On logicalUnaryExpression shift to state 85
-- On inclusiveOrExpression shift to state 90
-- On forExpr shift to state 413
-- On fieldAccess shift to state 86
-- On expression shift to state 374
-- On exclusiveOrExpression shift to state 111
-- On equalityExpression shift to state 94
-- On conditionalOrExpression shift to state 112
-- On conditionalExpression shift to state 151
-- On conditionalAndExpression shift to state 117
-- On complexPrimaryNoParenthesis shift to state 87
-- On complexPrimary shift to state 88
-- On classAllocationExpression shift to state 100
-- On castExpression shift to state 103
-- On assignmentExpression shift to state 152
-- On arrayAllocationExpression shift to state 104
-- On arrayAccess shift to state 120
-- On arithmeticUnaryOperator shift to state 121
-- On andExpression shift to state 123
-- On additiveExpression shift to state 140

State 413:
iterStmt -> FOR LPAR forInit forExpr . forIncr RPAR statement [ error WHILE VOID TRY THROW THIS SYNCHRONIZED SWITCH SUPER STRLIT SHORT SEMI RETURN RCURL PLUS NULLLIT NOT NEW MINUS LPAR LONG LCURL INTLIT INT INCREMENT IF IDENTIFIER FOR FLOATLIT FLOAT FINAL ELSE DOUBLELIT DOUBLE DO DECREMENT CONTINUE CHARLIT CHAR BYTE BREAK BOOLEANLIT BOOLEAN BNOT ASSERT ]
iterStmt -> FOR LPAR forInit forExpr . RPAR statement [ error WHILE VOID TRY THROW THIS SYNCHRONIZED SWITCH SUPER STRLIT SHORT SEMI RETURN RCURL PLUS NULLLIT NOT NEW MINUS LPAR LONG LCURL INTLIT INT INCREMENT IF IDENTIFIER FOR FLOATLIT FLOAT FINAL ELSE DOUBLELIT DOUBLE DO DECREMENT CONTINUE CHARLIT CHAR BYTE BREAK BOOLEANLIT BOOLEAN BNOT ASSERT ]
-- On error shift to state 3
-- On VOID shift to state 6
-- On THIS shift to state 7
-- On SUPER shift to state 8
-- On STRLIT shift to state 9
-- On SHORT shift to state 10
-- On RPAR shift to state 414
-- On PLUS shift to state 11
-- On NULLLIT shift to state 12
-- On NOT shift to state 13
-- On NEW shift to state 14
-- On MINUS shift to state 26
-- On LPAR shift to state 27
-- On LONG shift to state 15
-- On INTLIT shift to state 28
-- On INT shift to state 16
-- On INCREMENT shift to state 29
-- On IDENTIFIER shift to state 17
-- On FLOATLIT shift to state 31
-- On FLOAT shift to state 18
-- On DOUBLELIT shift to state 32
-- On DOUBLE shift to state 19
-- On DECREMENT shift to state 33
-- On CHARLIT shift to state 34
-- On CHAR shift to state 20
-- On BYTE shift to state 21
-- On BOOLEANLIT shift to state 35
-- On BOOLEAN shift to state 22
-- On BNOT shift to state 36
-- On unaryExpression shift to state 44
-- On specialName shift to state 38
-- On shiftExpression shift to state 58
-- On relationalExpression shift to state 79
-- On realPostfixExpression shift to state 39
-- On qualifiedName shift to state 42
-- On primitiveType shift to state 61
-- On primaryExpression shift to state 64
-- On postfixExpression shift to state 65
-- On plainNewAllocationExpression shift to state 68
-- On notJustName shift to state 69
-- On newAllocationExpression shift to state 72
-- On multiplicativeExpression shift to state 73
-- On methodCall shift to state 75
-- On methodAccess shift to state 76
-- On logicalUnaryOperator shift to state 83
-- On logicalUnaryExpression shift to state 85
-- On inclusiveOrExpression shift to state 90
-- On forIncr shift to state 416
-- On fieldAccess shift to state 86
-- On expressionStmts shift to state 370
-- On expressionStmt shift to state 373
-- On expression shift to state 357
-- On exclusiveOrExpression shift to state 111
-- On equalityExpression shift to state 94
-- On conditionalOrExpression shift to state 112
-- On conditionalExpression shift to state 151
-- On conditionalAndExpression shift to state 117
-- On complexPrimaryNoParenthesis shift to state 87
-- On complexPrimary shift to state 88
-- On classAllocationExpression shift to state 100
-- On castExpression shift to state 103
-- On assignmentExpression shift to state 152
-- On arrayAllocationExpression shift to state 104
-- On arrayAccess shift to state 120
-- On arithmeticUnaryOperator shift to state 121
-- On andExpression shift to state 123
-- On additiveExpression shift to state 140

State 414:
iterStmt -> FOR LPAR forInit forExpr RPAR . statement [ error WHILE VOID TRY THROW THIS SYNCHRONIZED SWITCH SUPER STRLIT SHORT SEMI RETURN RCURL PLUS NULLLIT NOT NEW MINUS LPAR LONG LCURL INTLIT INT INCREMENT IF IDENTIFIER FOR FLOATLIT FLOAT FINAL ELSE DOUBLELIT DOUBLE DO DECREMENT CONTINUE CHARLIT CHAR BYTE BREAK BOOLEANLIT BOOLEAN BNOT ASSERT ]
-- On error shift to state 3
-- On WHILE shift to state 4
-- On VOID shift to state 6
-- On TRY shift to state 208
-- On THROW shift to state 210
-- On THIS shift to state 7
-- On SYNCHRONIZED shift to state 213
-- On SWITCH shift to state 217
-- On SUPER shift to state 8
-- On STRLIT shift to state 9
-- On SHORT shift to state 10
-- On SEMI shift to state 238
-- On RETURN shift to state 239
-- On PLUS shift to state 11
-- On NULLLIT shift to state 12
-- On NOT shift to state 13
-- On NEW shift to state 14
-- On MINUS shift to state 26
-- On LPAR shift to state 27
-- On LONG shift to state 15
-- On LCURL shift to state 243
-- On INTLIT shift to state 28
-- On INT shift to state 16
-- On INCREMENT shift to state 29
-- On IF shift to state 245
-- On IDENTIFIER shift to state 249
-- On FOR shift to state 251
-- On FLOATLIT shift to state 31
-- On FLOAT shift to state 18
-- On DOUBLELIT shift to state 32
-- On DOUBLE shift to state 19
-- On DO shift to state 274
-- On DECREMENT shift to state 33
-- On CONTINUE shift to state 387
-- On CHARLIT shift to state 34
-- On CHAR shift to state 20
-- On BYTE shift to state 21
-- On BREAK shift to state 391
-- On BOOLEANLIT shift to state 35
-- On BOOLEAN shift to state 22
-- On BNOT shift to state 36
-- On ASSERT shift to state 395
-- On unaryExpression shift to state 44
-- On statement shift to state 415
-- On specialName shift to state 38
-- On shiftExpression shift to state 58
-- On selectStmt shift to state 402
-- On relationalExpression shift to state 79
-- On realPostfixExpression shift to state 39
-- On qualifiedName shift to state 42
-- On primitiveType shift to state 61
-- On primaryExpression shift to state 64
-- On postfixExpression shift to state 65
-- On plainNewAllocationExpression shift to state 68
-- On notJustName shift to state 69
-- On newAllocationExpression shift to state 72
-- On multiplicativeExpression shift to state 73
-- On methodCall shift to state 75
-- On methodAccess shift to state 76
-- On logicalUnaryOperator shift to state 83
-- On logicalUnaryExpression shift to state 85
-- On labelStmt shift to state 403
-- On jumpStmt shift to state 404
-- On iterStmt shift to state 405
-- On inclusiveOrExpression shift to state 90
-- On guardingStmt shift to state 406
-- On fieldAccess shift to state 86
-- On expressionStmt shift to state 407
-- On expression shift to state 357
-- On exclusiveOrExpression shift to state 111
-- On equalityExpression shift to state 94
-- On emptyStmt shift to state 409
-- On conditionalOrExpression shift to state 112
-- On conditionalExpression shift to state 151
-- On conditionalAndExpression shift to state 117
-- On complexPrimaryNoParenthesis shift to state 87
-- On complexPrimary shift to state 88
-- On classAllocationExpression shift to state 100
-- On castExpression shift to state 103
-- On block shift to state 410
-- On assignmentExpression shift to state 152
-- On assertStmt shift to state 411
-- On arrayAllocationExpression shift to state 104
-- On arrayAccess shift to state 120
-- On arithmeticUnaryOperator shift to state 121
-- On andExpression shift to state 123
-- On additiveExpression shift to state 140

State 415:
iterStmt -> FOR LPAR forInit forExpr RPAR statement . [ error WHILE VOID TRY THROW THIS SYNCHRONIZED SWITCH SUPER STRLIT SHORT SEMI RETURN RCURL PLUS NULLLIT NOT NEW MINUS LPAR LONG LCURL INTLIT INT INCREMENT IF IDENTIFIER FOR FLOATLIT FLOAT FINAL ELSE DOUBLELIT DOUBLE DO DECREMENT CONTINUE CHARLIT CHAR BYTE BREAK BOOLEANLIT BOOLEAN BNOT ASSERT ]
-- On error reduce production iterStmt -> FOR LPAR forInit forExpr RPAR statement 
-- On WHILE reduce production iterStmt -> FOR LPAR forInit forExpr RPAR statement 
-- On VOID reduce production iterStmt -> FOR LPAR forInit forExpr RPAR statement 
-- On TRY reduce production iterStmt -> FOR LPAR forInit forExpr RPAR statement 
-- On THROW reduce production iterStmt -> FOR LPAR forInit forExpr RPAR statement 
-- On THIS reduce production iterStmt -> FOR LPAR forInit forExpr RPAR statement 
-- On SYNCHRONIZED reduce production iterStmt -> FOR LPAR forInit forExpr RPAR statement 
-- On SWITCH reduce production iterStmt -> FOR LPAR forInit forExpr RPAR statement 
-- On SUPER reduce production iterStmt -> FOR LPAR forInit forExpr RPAR statement 
-- On STRLIT reduce production iterStmt -> FOR LPAR forInit forExpr RPAR statement 
-- On SHORT reduce production iterStmt -> FOR LPAR forInit forExpr RPAR statement 
-- On SEMI reduce production iterStmt -> FOR LPAR forInit forExpr RPAR statement 
-- On RETURN reduce production iterStmt -> FOR LPAR forInit forExpr RPAR statement 
-- On RCURL reduce production iterStmt -> FOR LPAR forInit forExpr RPAR statement 
-- On PLUS reduce production iterStmt -> FOR LPAR forInit forExpr RPAR statement 
-- On NULLLIT reduce production iterStmt -> FOR LPAR forInit forExpr RPAR statement 
-- On NOT reduce production iterStmt -> FOR LPAR forInit forExpr RPAR statement 
-- On NEW reduce production iterStmt -> FOR LPAR forInit forExpr RPAR statement 
-- On MINUS reduce production iterStmt -> FOR LPAR forInit forExpr RPAR statement 
-- On LPAR reduce production iterStmt -> FOR LPAR forInit forExpr RPAR statement 
-- On LONG reduce production iterStmt -> FOR LPAR forInit forExpr RPAR statement 
-- On LCURL reduce production iterStmt -> FOR LPAR forInit forExpr RPAR statement 
-- On INTLIT reduce production iterStmt -> FOR LPAR forInit forExpr RPAR statement 
-- On INT reduce production iterStmt -> FOR LPAR forInit forExpr RPAR statement 
-- On INCREMENT reduce production iterStmt -> FOR LPAR forInit forExpr RPAR statement 
-- On IF reduce production iterStmt -> FOR LPAR forInit forExpr RPAR statement 
-- On IDENTIFIER reduce production iterStmt -> FOR LPAR forInit forExpr RPAR statement 
-- On FOR reduce production iterStmt -> FOR LPAR forInit forExpr RPAR statement 
-- On FLOATLIT reduce production iterStmt -> FOR LPAR forInit forExpr RPAR statement 
-- On FLOAT reduce production iterStmt -> FOR LPAR forInit forExpr RPAR statement 
-- On FINAL reduce production iterStmt -> FOR LPAR forInit forExpr RPAR statement 
-- On ELSE reduce production iterStmt -> FOR LPAR forInit forExpr RPAR statement 
-- On DOUBLELIT reduce production iterStmt -> FOR LPAR forInit forExpr RPAR statement 
-- On DOUBLE reduce production iterStmt -> FOR LPAR forInit forExpr RPAR statement 
-- On DO reduce production iterStmt -> FOR LPAR forInit forExpr RPAR statement 
-- On DECREMENT reduce production iterStmt -> FOR LPAR forInit forExpr RPAR statement 
-- On CONTINUE reduce production iterStmt -> FOR LPAR forInit forExpr RPAR statement 
-- On CHARLIT reduce production iterStmt -> FOR LPAR forInit forExpr RPAR statement 
-- On CHAR reduce production iterStmt -> FOR LPAR forInit forExpr RPAR statement 
-- On BYTE reduce production iterStmt -> FOR LPAR forInit forExpr RPAR statement 
-- On BREAK reduce production iterStmt -> FOR LPAR forInit forExpr RPAR statement 
-- On BOOLEANLIT reduce production iterStmt -> FOR LPAR forInit forExpr RPAR statement 
-- On BOOLEAN reduce production iterStmt -> FOR LPAR forInit forExpr RPAR statement 
-- On BNOT reduce production iterStmt -> FOR LPAR forInit forExpr RPAR statement 
-- On ASSERT reduce production iterStmt -> FOR LPAR forInit forExpr RPAR statement 

State 416:
iterStmt -> FOR LPAR forInit forExpr forIncr . RPAR statement [ error WHILE VOID TRY THROW THIS SYNCHRONIZED SWITCH SUPER STRLIT SHORT SEMI RETURN RCURL PLUS NULLLIT NOT NEW MINUS LPAR LONG LCURL INTLIT INT INCREMENT IF IDENTIFIER FOR FLOATLIT FLOAT FINAL ELSE DOUBLELIT DOUBLE DO DECREMENT CONTINUE CHARLIT CHAR BYTE BREAK BOOLEANLIT BOOLEAN BNOT ASSERT ]
-- On RPAR shift to state 417

State 417:
iterStmt -> FOR LPAR forInit forExpr forIncr RPAR . statement [ error WHILE VOID TRY THROW THIS SYNCHRONIZED SWITCH SUPER STRLIT SHORT SEMI RETURN RCURL PLUS NULLLIT NOT NEW MINUS LPAR LONG LCURL INTLIT INT INCREMENT IF IDENTIFIER FOR FLOATLIT FLOAT FINAL ELSE DOUBLELIT DOUBLE DO DECREMENT CONTINUE CHARLIT CHAR BYTE BREAK BOOLEANLIT BOOLEAN BNOT ASSERT ]
-- On error shift to state 3
-- On WHILE shift to state 4
-- On VOID shift to state 6
-- On TRY shift to state 208
-- On THROW shift to state 210
-- On THIS shift to state 7
-- On SYNCHRONIZED shift to state 213
-- On SWITCH shift to state 217
-- On SUPER shift to state 8
-- On STRLIT shift to state 9
-- On SHORT shift to state 10
-- On SEMI shift to state 238
-- On RETURN shift to state 239
-- On PLUS shift to state 11
-- On NULLLIT shift to state 12
-- On NOT shift to state 13
-- On NEW shift to state 14
-- On MINUS shift to state 26
-- On LPAR shift to state 27
-- On LONG shift to state 15
-- On LCURL shift to state 243
-- On INTLIT shift to state 28
-- On INT shift to state 16
-- On INCREMENT shift to state 29
-- On IF shift to state 245
-- On IDENTIFIER shift to state 249
-- On FOR shift to state 251
-- On FLOATLIT shift to state 31
-- On FLOAT shift to state 18
-- On DOUBLELIT shift to state 32
-- On DOUBLE shift to state 19
-- On DO shift to state 274
-- On DECREMENT shift to state 33
-- On CONTINUE shift to state 387
-- On CHARLIT shift to state 34
-- On CHAR shift to state 20
-- On BYTE shift to state 21
-- On BREAK shift to state 391
-- On BOOLEANLIT shift to state 35
-- On BOOLEAN shift to state 22
-- On BNOT shift to state 36
-- On ASSERT shift to state 395
-- On unaryExpression shift to state 44
-- On statement shift to state 418
-- On specialName shift to state 38
-- On shiftExpression shift to state 58
-- On selectStmt shift to state 402
-- On relationalExpression shift to state 79
-- On realPostfixExpression shift to state 39
-- On qualifiedName shift to state 42
-- On primitiveType shift to state 61
-- On primaryExpression shift to state 64
-- On postfixExpression shift to state 65
-- On plainNewAllocationExpression shift to state 68
-- On notJustName shift to state 69
-- On newAllocationExpression shift to state 72
-- On multiplicativeExpression shift to state 73
-- On methodCall shift to state 75
-- On methodAccess shift to state 76
-- On logicalUnaryOperator shift to state 83
-- On logicalUnaryExpression shift to state 85
-- On labelStmt shift to state 403
-- On jumpStmt shift to state 404
-- On iterStmt shift to state 405
-- On inclusiveOrExpression shift to state 90
-- On guardingStmt shift to state 406
-- On fieldAccess shift to state 86
-- On expressionStmt shift to state 407
-- On expression shift to state 357
-- On exclusiveOrExpression shift to state 111
-- On equalityExpression shift to state 94
-- On emptyStmt shift to state 409
-- On conditionalOrExpression shift to state 112
-- On conditionalExpression shift to state 151
-- On conditionalAndExpression shift to state 117
-- On complexPrimaryNoParenthesis shift to state 87
-- On complexPrimary shift to state 88
-- On classAllocationExpression shift to state 100
-- On castExpression shift to state 103
-- On block shift to state 410
-- On assignmentExpression shift to state 152
-- On assertStmt shift to state 411
-- On arrayAllocationExpression shift to state 104
-- On arrayAccess shift to state 120
-- On arithmeticUnaryOperator shift to state 121
-- On andExpression shift to state 123
-- On additiveExpression shift to state 140

State 418:
iterStmt -> FOR LPAR forInit forExpr forIncr RPAR statement . [ error WHILE VOID TRY THROW THIS SYNCHRONIZED SWITCH SUPER STRLIT SHORT SEMI RETURN RCURL PLUS NULLLIT NOT NEW MINUS LPAR LONG LCURL INTLIT INT INCREMENT IF IDENTIFIER FOR FLOATLIT FLOAT FINAL ELSE DOUBLELIT DOUBLE DO DECREMENT CONTINUE CHARLIT CHAR BYTE BREAK BOOLEANLIT BOOLEAN BNOT ASSERT ]
-- On error reduce production iterStmt -> FOR LPAR forInit forExpr forIncr RPAR statement 
-- On WHILE reduce production iterStmt -> FOR LPAR forInit forExpr forIncr RPAR statement 
-- On VOID reduce production iterStmt -> FOR LPAR forInit forExpr forIncr RPAR statement 
-- On TRY reduce production iterStmt -> FOR LPAR forInit forExpr forIncr RPAR statement 
-- On THROW reduce production iterStmt -> FOR LPAR forInit forExpr forIncr RPAR statement 
-- On THIS reduce production iterStmt -> FOR LPAR forInit forExpr forIncr RPAR statement 
-- On SYNCHRONIZED reduce production iterStmt -> FOR LPAR forInit forExpr forIncr RPAR statement 
-- On SWITCH reduce production iterStmt -> FOR LPAR forInit forExpr forIncr RPAR statement 
-- On SUPER reduce production iterStmt -> FOR LPAR forInit forExpr forIncr RPAR statement 
-- On STRLIT reduce production iterStmt -> FOR LPAR forInit forExpr forIncr RPAR statement 
-- On SHORT reduce production iterStmt -> FOR LPAR forInit forExpr forIncr RPAR statement 
-- On SEMI reduce production iterStmt -> FOR LPAR forInit forExpr forIncr RPAR statement 
-- On RETURN reduce production iterStmt -> FOR LPAR forInit forExpr forIncr RPAR statement 
-- On RCURL reduce production iterStmt -> FOR LPAR forInit forExpr forIncr RPAR statement 
-- On PLUS reduce production iterStmt -> FOR LPAR forInit forExpr forIncr RPAR statement 
-- On NULLLIT reduce production iterStmt -> FOR LPAR forInit forExpr forIncr RPAR statement 
-- On NOT reduce production iterStmt -> FOR LPAR forInit forExpr forIncr RPAR statement 
-- On NEW reduce production iterStmt -> FOR LPAR forInit forExpr forIncr RPAR statement 
-- On MINUS reduce production iterStmt -> FOR LPAR forInit forExpr forIncr RPAR statement 
-- On LPAR reduce production iterStmt -> FOR LPAR forInit forExpr forIncr RPAR statement 
-- On LONG reduce production iterStmt -> FOR LPAR forInit forExpr forIncr RPAR statement 
-- On LCURL reduce production iterStmt -> FOR LPAR forInit forExpr forIncr RPAR statement 
-- On INTLIT reduce production iterStmt -> FOR LPAR forInit forExpr forIncr RPAR statement 
-- On INT reduce production iterStmt -> FOR LPAR forInit forExpr forIncr RPAR statement 
-- On INCREMENT reduce production iterStmt -> FOR LPAR forInit forExpr forIncr RPAR statement 
-- On IF reduce production iterStmt -> FOR LPAR forInit forExpr forIncr RPAR statement 
-- On IDENTIFIER reduce production iterStmt -> FOR LPAR forInit forExpr forIncr RPAR statement 
-- On FOR reduce production iterStmt -> FOR LPAR forInit forExpr forIncr RPAR statement 
-- On FLOATLIT reduce production iterStmt -> FOR LPAR forInit forExpr forIncr RPAR statement 
-- On FLOAT reduce production iterStmt -> FOR LPAR forInit forExpr forIncr RPAR statement 
-- On FINAL reduce production iterStmt -> FOR LPAR forInit forExpr forIncr RPAR statement 
-- On ELSE reduce production iterStmt -> FOR LPAR forInit forExpr forIncr RPAR statement 
-- On DOUBLELIT reduce production iterStmt -> FOR LPAR forInit forExpr forIncr RPAR statement 
-- On DOUBLE reduce production iterStmt -> FOR LPAR forInit forExpr forIncr RPAR statement 
-- On DO reduce production iterStmt -> FOR LPAR forInit forExpr forIncr RPAR statement 
-- On DECREMENT reduce production iterStmt -> FOR LPAR forInit forExpr forIncr RPAR statement 
-- On CONTINUE reduce production iterStmt -> FOR LPAR forInit forExpr forIncr RPAR statement 
-- On CHARLIT reduce production iterStmt -> FOR LPAR forInit forExpr forIncr RPAR statement 
-- On CHAR reduce production iterStmt -> FOR LPAR forInit forExpr forIncr RPAR statement 
-- On BYTE reduce production iterStmt -> FOR LPAR forInit forExpr forIncr RPAR statement 
-- On BREAK reduce production iterStmt -> FOR LPAR forInit forExpr forIncr RPAR statement 
-- On BOOLEANLIT reduce production iterStmt -> FOR LPAR forInit forExpr forIncr RPAR statement 
-- On BOOLEAN reduce production iterStmt -> FOR LPAR forInit forExpr forIncr RPAR statement 
-- On BNOT reduce production iterStmt -> FOR LPAR forInit forExpr forIncr RPAR statement 
-- On ASSERT reduce production iterStmt -> FOR LPAR forInit forExpr forIncr RPAR statement 

State 419:
selectStmt -> IF LPAR expression RPAR statement . [ error WHILE VOID TRY THROW THIS SYNCHRONIZED SWITCH SUPER STRLIT SHORT SEMI RETURN RCURL PLUS NULLLIT NOT NEW MINUS LPAR LONG LCURL INTLIT INT INCREMENT IF IDENTIFIER FOR FLOATLIT FLOAT FINAL ELSE DOUBLELIT DOUBLE DO DECREMENT CONTINUE CHARLIT CHAR BYTE BREAK BOOLEANLIT BOOLEAN BNOT ASSERT ]
selectStmt -> IF LPAR expression RPAR statement . ELSE statement [ error WHILE VOID TRY THROW THIS SYNCHRONIZED SWITCH SUPER STRLIT SHORT SEMI RETURN RCURL PLUS NULLLIT NOT NEW MINUS LPAR LONG LCURL INTLIT INT INCREMENT IF IDENTIFIER FOR FLOATLIT FLOAT FINAL ELSE DOUBLELIT DOUBLE DO DECREMENT CONTINUE CHARLIT CHAR BYTE BREAK BOOLEANLIT BOOLEAN BNOT ASSERT ]
-- On ELSE shift to state 420
-- On error reduce production selectStmt -> IF LPAR expression RPAR statement 
-- On WHILE reduce production selectStmt -> IF LPAR expression RPAR statement 
-- On VOID reduce production selectStmt -> IF LPAR expression RPAR statement 
-- On TRY reduce production selectStmt -> IF LPAR expression RPAR statement 
-- On THROW reduce production selectStmt -> IF LPAR expression RPAR statement 
-- On THIS reduce production selectStmt -> IF LPAR expression RPAR statement 
-- On SYNCHRONIZED reduce production selectStmt -> IF LPAR expression RPAR statement 
-- On SWITCH reduce production selectStmt -> IF LPAR expression RPAR statement 
-- On SUPER reduce production selectStmt -> IF LPAR expression RPAR statement 
-- On STRLIT reduce production selectStmt -> IF LPAR expression RPAR statement 
-- On SHORT reduce production selectStmt -> IF LPAR expression RPAR statement 
-- On SEMI reduce production selectStmt -> IF LPAR expression RPAR statement 
-- On RETURN reduce production selectStmt -> IF LPAR expression RPAR statement 
-- On RCURL reduce production selectStmt -> IF LPAR expression RPAR statement 
-- On PLUS reduce production selectStmt -> IF LPAR expression RPAR statement 
-- On NULLLIT reduce production selectStmt -> IF LPAR expression RPAR statement 
-- On NOT reduce production selectStmt -> IF LPAR expression RPAR statement 
-- On NEW reduce production selectStmt -> IF LPAR expression RPAR statement 
-- On MINUS reduce production selectStmt -> IF LPAR expression RPAR statement 
-- On LPAR reduce production selectStmt -> IF LPAR expression RPAR statement 
-- On LONG reduce production selectStmt -> IF LPAR expression RPAR statement 
-- On LCURL reduce production selectStmt -> IF LPAR expression RPAR statement 
-- On INTLIT reduce production selectStmt -> IF LPAR expression RPAR statement 
-- On INT reduce production selectStmt -> IF LPAR expression RPAR statement 
-- On INCREMENT reduce production selectStmt -> IF LPAR expression RPAR statement 
-- On IF reduce production selectStmt -> IF LPAR expression RPAR statement 
-- On IDENTIFIER reduce production selectStmt -> IF LPAR expression RPAR statement 
-- On FOR reduce production selectStmt -> IF LPAR expression RPAR statement 
-- On FLOATLIT reduce production selectStmt -> IF LPAR expression RPAR statement 
-- On FLOAT reduce production selectStmt -> IF LPAR expression RPAR statement 
-- On FINAL reduce production selectStmt -> IF LPAR expression RPAR statement 
-- On DOUBLELIT reduce production selectStmt -> IF LPAR expression RPAR statement 
-- On DOUBLE reduce production selectStmt -> IF LPAR expression RPAR statement 
-- On DO reduce production selectStmt -> IF LPAR expression RPAR statement 
-- On DECREMENT reduce production selectStmt -> IF LPAR expression RPAR statement 
-- On CONTINUE reduce production selectStmt -> IF LPAR expression RPAR statement 
-- On CHARLIT reduce production selectStmt -> IF LPAR expression RPAR statement 
-- On CHAR reduce production selectStmt -> IF LPAR expression RPAR statement 
-- On BYTE reduce production selectStmt -> IF LPAR expression RPAR statement 
-- On BREAK reduce production selectStmt -> IF LPAR expression RPAR statement 
-- On BOOLEANLIT reduce production selectStmt -> IF LPAR expression RPAR statement 
-- On BOOLEAN reduce production selectStmt -> IF LPAR expression RPAR statement 
-- On BNOT reduce production selectStmt -> IF LPAR expression RPAR statement 
-- On ASSERT reduce production selectStmt -> IF LPAR expression RPAR statement 

State 420:
selectStmt -> IF LPAR expression RPAR statement ELSE . statement [ error WHILE VOID TRY THROW THIS SYNCHRONIZED SWITCH SUPER STRLIT SHORT SEMI RETURN RCURL PLUS NULLLIT NOT NEW MINUS LPAR LONG LCURL INTLIT INT INCREMENT IF IDENTIFIER FOR FLOATLIT FLOAT FINAL ELSE DOUBLELIT DOUBLE DO DECREMENT CONTINUE CHARLIT CHAR BYTE BREAK BOOLEANLIT BOOLEAN BNOT ASSERT ]
-- On error shift to state 3
-- On WHILE shift to state 4
-- On VOID shift to state 6
-- On TRY shift to state 208
-- On THROW shift to state 210
-- On THIS shift to state 7
-- On SYNCHRONIZED shift to state 213
-- On SWITCH shift to state 217
-- On SUPER shift to state 8
-- On STRLIT shift to state 9
-- On SHORT shift to state 10
-- On SEMI shift to state 238
-- On RETURN shift to state 239
-- On PLUS shift to state 11
-- On NULLLIT shift to state 12
-- On NOT shift to state 13
-- On NEW shift to state 14
-- On MINUS shift to state 26
-- On LPAR shift to state 27
-- On LONG shift to state 15
-- On LCURL shift to state 243
-- On INTLIT shift to state 28
-- On INT shift to state 16
-- On INCREMENT shift to state 29
-- On IF shift to state 245
-- On IDENTIFIER shift to state 249
-- On FOR shift to state 251
-- On FLOATLIT shift to state 31
-- On FLOAT shift to state 18
-- On DOUBLELIT shift to state 32
-- On DOUBLE shift to state 19
-- On DO shift to state 274
-- On DECREMENT shift to state 33
-- On CONTINUE shift to state 387
-- On CHARLIT shift to state 34
-- On CHAR shift to state 20
-- On BYTE shift to state 21
-- On BREAK shift to state 391
-- On BOOLEANLIT shift to state 35
-- On BOOLEAN shift to state 22
-- On BNOT shift to state 36
-- On ASSERT shift to state 395
-- On unaryExpression shift to state 44
-- On statement shift to state 421
-- On specialName shift to state 38
-- On shiftExpression shift to state 58
-- On selectStmt shift to state 402
-- On relationalExpression shift to state 79
-- On realPostfixExpression shift to state 39
-- On qualifiedName shift to state 42
-- On primitiveType shift to state 61
-- On primaryExpression shift to state 64
-- On postfixExpression shift to state 65
-- On plainNewAllocationExpression shift to state 68
-- On notJustName shift to state 69
-- On newAllocationExpression shift to state 72
-- On multiplicativeExpression shift to state 73
-- On methodCall shift to state 75
-- On methodAccess shift to state 76
-- On logicalUnaryOperator shift to state 83
-- On logicalUnaryExpression shift to state 85
-- On labelStmt shift to state 403
-- On jumpStmt shift to state 404
-- On iterStmt shift to state 405
-- On inclusiveOrExpression shift to state 90
-- On guardingStmt shift to state 406
-- On fieldAccess shift to state 86
-- On expressionStmt shift to state 407
-- On expression shift to state 357
-- On exclusiveOrExpression shift to state 111
-- On equalityExpression shift to state 94
-- On emptyStmt shift to state 409
-- On conditionalOrExpression shift to state 112
-- On conditionalExpression shift to state 151
-- On conditionalAndExpression shift to state 117
-- On complexPrimaryNoParenthesis shift to state 87
-- On complexPrimary shift to state 88
-- On classAllocationExpression shift to state 100
-- On castExpression shift to state 103
-- On block shift to state 410
-- On assignmentExpression shift to state 152
-- On assertStmt shift to state 411
-- On arrayAllocationExpression shift to state 104
-- On arrayAccess shift to state 120
-- On arithmeticUnaryOperator shift to state 121
-- On andExpression shift to state 123
-- On additiveExpression shift to state 140

State 421:
selectStmt -> IF LPAR expression RPAR statement ELSE statement . [ error WHILE VOID TRY THROW THIS SYNCHRONIZED SWITCH SUPER STRLIT SHORT SEMI RETURN RCURL PLUS NULLLIT NOT NEW MINUS LPAR LONG LCURL INTLIT INT INCREMENT IF IDENTIFIER FOR FLOATLIT FLOAT FINAL ELSE DOUBLELIT DOUBLE DO DECREMENT CONTINUE CHARLIT CHAR BYTE BREAK BOOLEANLIT BOOLEAN BNOT ASSERT ]
-- On error reduce production selectStmt -> IF LPAR expression RPAR statement ELSE statement 
-- On WHILE reduce production selectStmt -> IF LPAR expression RPAR statement ELSE statement 
-- On VOID reduce production selectStmt -> IF LPAR expression RPAR statement ELSE statement 
-- On TRY reduce production selectStmt -> IF LPAR expression RPAR statement ELSE statement 
-- On THROW reduce production selectStmt -> IF LPAR expression RPAR statement ELSE statement 
-- On THIS reduce production selectStmt -> IF LPAR expression RPAR statement ELSE statement 
-- On SYNCHRONIZED reduce production selectStmt -> IF LPAR expression RPAR statement ELSE statement 
-- On SWITCH reduce production selectStmt -> IF LPAR expression RPAR statement ELSE statement 
-- On SUPER reduce production selectStmt -> IF LPAR expression RPAR statement ELSE statement 
-- On STRLIT reduce production selectStmt -> IF LPAR expression RPAR statement ELSE statement 
-- On SHORT reduce production selectStmt -> IF LPAR expression RPAR statement ELSE statement 
-- On SEMI reduce production selectStmt -> IF LPAR expression RPAR statement ELSE statement 
-- On RETURN reduce production selectStmt -> IF LPAR expression RPAR statement ELSE statement 
-- On RCURL reduce production selectStmt -> IF LPAR expression RPAR statement ELSE statement 
-- On PLUS reduce production selectStmt -> IF LPAR expression RPAR statement ELSE statement 
-- On NULLLIT reduce production selectStmt -> IF LPAR expression RPAR statement ELSE statement 
-- On NOT reduce production selectStmt -> IF LPAR expression RPAR statement ELSE statement 
-- On NEW reduce production selectStmt -> IF LPAR expression RPAR statement ELSE statement 
-- On MINUS reduce production selectStmt -> IF LPAR expression RPAR statement ELSE statement 
-- On LPAR reduce production selectStmt -> IF LPAR expression RPAR statement ELSE statement 
-- On LONG reduce production selectStmt -> IF LPAR expression RPAR statement ELSE statement 
-- On LCURL reduce production selectStmt -> IF LPAR expression RPAR statement ELSE statement 
-- On INTLIT reduce production selectStmt -> IF LPAR expression RPAR statement ELSE statement 
-- On INT reduce production selectStmt -> IF LPAR expression RPAR statement ELSE statement 
-- On INCREMENT reduce production selectStmt -> IF LPAR expression RPAR statement ELSE statement 
-- On IF reduce production selectStmt -> IF LPAR expression RPAR statement ELSE statement 
-- On IDENTIFIER reduce production selectStmt -> IF LPAR expression RPAR statement ELSE statement 
-- On FOR reduce production selectStmt -> IF LPAR expression RPAR statement ELSE statement 
-- On FLOATLIT reduce production selectStmt -> IF LPAR expression RPAR statement ELSE statement 
-- On FLOAT reduce production selectStmt -> IF LPAR expression RPAR statement ELSE statement 
-- On FINAL reduce production selectStmt -> IF LPAR expression RPAR statement ELSE statement 
-- On ELSE reduce production selectStmt -> IF LPAR expression RPAR statement ELSE statement 
-- On DOUBLELIT reduce production selectStmt -> IF LPAR expression RPAR statement ELSE statement 
-- On DOUBLE reduce production selectStmt -> IF LPAR expression RPAR statement ELSE statement 
-- On DO reduce production selectStmt -> IF LPAR expression RPAR statement ELSE statement 
-- On DECREMENT reduce production selectStmt -> IF LPAR expression RPAR statement ELSE statement 
-- On CONTINUE reduce production selectStmt -> IF LPAR expression RPAR statement ELSE statement 
-- On CHARLIT reduce production selectStmt -> IF LPAR expression RPAR statement ELSE statement 
-- On CHAR reduce production selectStmt -> IF LPAR expression RPAR statement ELSE statement 
-- On BYTE reduce production selectStmt -> IF LPAR expression RPAR statement ELSE statement 
-- On BREAK reduce production selectStmt -> IF LPAR expression RPAR statement ELSE statement 
-- On BOOLEANLIT reduce production selectStmt -> IF LPAR expression RPAR statement ELSE statement 
-- On BOOLEAN reduce production selectStmt -> IF LPAR expression RPAR statement ELSE statement 
-- On BNOT reduce production selectStmt -> IF LPAR expression RPAR statement ELSE statement 
-- On ASSERT reduce production selectStmt -> IF LPAR expression RPAR statement ELSE statement 

State 422:
localVariableDeclStmt -> typeSpecifier . variableDeclarators SEMI [ error WHILE VOID TRY THROW THIS SYNCHRONIZED SWITCH SUPER STRLIT SHORT SEMI RETURN RCURL PLUS NULLLIT NOT NEW MINUS LPAR LONG LCURL INTLIT INT INCREMENT IF IDENTIFIER FOR FLOATLIT FLOAT FINAL DOUBLELIT DOUBLE DO DECREMENT CONTINUE CHARLIT CHAR BYTE BREAK BOOLEANLIT BOOLEAN BNOT ASSERT ]
-- On IDENTIFIER shift to state 256
-- On variableDeclarators shift to state 267
-- On variableDeclarator shift to state 264
-- On declaratorName shift to state 261

State 423:
localVariableDeclOrStmt -> statement . [ error WHILE VOID TRY THROW THIS SYNCHRONIZED SWITCH SUPER STRLIT SHORT SEMI RETURN RCURL PLUS NULLLIT NOT NEW MINUS LPAR LONG LCURL INTLIT INT INCREMENT IF IDENTIFIER FOR FLOATLIT FLOAT FINAL DOUBLELIT DOUBLE DO DECREMENT CONTINUE CHARLIT CHAR BYTE BREAK BOOLEANLIT BOOLEAN BNOT ASSERT ]
-- On error reduce production localVariableDeclOrStmt -> statement 
-- On WHILE reduce production localVariableDeclOrStmt -> statement 
-- On VOID reduce production localVariableDeclOrStmt -> statement 
-- On TRY reduce production localVariableDeclOrStmt -> statement 
-- On THROW reduce production localVariableDeclOrStmt -> statement 
-- On THIS reduce production localVariableDeclOrStmt -> statement 
-- On SYNCHRONIZED reduce production localVariableDeclOrStmt -> statement 
-- On SWITCH reduce production localVariableDeclOrStmt -> statement 
-- On SUPER reduce production localVariableDeclOrStmt -> statement 
-- On STRLIT reduce production localVariableDeclOrStmt -> statement 
-- On SHORT reduce production localVariableDeclOrStmt -> statement 
-- On SEMI reduce production localVariableDeclOrStmt -> statement 
-- On RETURN reduce production localVariableDeclOrStmt -> statement 
-- On RCURL reduce production localVariableDeclOrStmt -> statement 
-- On PLUS reduce production localVariableDeclOrStmt -> statement 
-- On NULLLIT reduce production localVariableDeclOrStmt -> statement 
-- On NOT reduce production localVariableDeclOrStmt -> statement 
-- On NEW reduce production localVariableDeclOrStmt -> statement 
-- On MINUS reduce production localVariableDeclOrStmt -> statement 
-- On LPAR reduce production localVariableDeclOrStmt -> statement 
-- On LONG reduce production localVariableDeclOrStmt -> statement 
-- On LCURL reduce production localVariableDeclOrStmt -> statement 
-- On INTLIT reduce production localVariableDeclOrStmt -> statement 
-- On INT reduce production localVariableDeclOrStmt -> statement 
-- On INCREMENT reduce production localVariableDeclOrStmt -> statement 
-- On IF reduce production localVariableDeclOrStmt -> statement 
-- On IDENTIFIER reduce production localVariableDeclOrStmt -> statement 
-- On FOR reduce production localVariableDeclOrStmt -> statement 
-- On FLOATLIT reduce production localVariableDeclOrStmt -> statement 
-- On FLOAT reduce production localVariableDeclOrStmt -> statement 
-- On FINAL reduce production localVariableDeclOrStmt -> statement 
-- On DOUBLELIT reduce production localVariableDeclOrStmt -> statement 
-- On DOUBLE reduce production localVariableDeclOrStmt -> statement 
-- On DO reduce production localVariableDeclOrStmt -> statement 
-- On DECREMENT reduce production localVariableDeclOrStmt -> statement 
-- On CONTINUE reduce production localVariableDeclOrStmt -> statement 
-- On CHARLIT reduce production localVariableDeclOrStmt -> statement 
-- On CHAR reduce production localVariableDeclOrStmt -> statement 
-- On BYTE reduce production localVariableDeclOrStmt -> statement 
-- On BREAK reduce production localVariableDeclOrStmt -> statement 
-- On BOOLEANLIT reduce production localVariableDeclOrStmt -> statement 
-- On BOOLEAN reduce production localVariableDeclOrStmt -> statement 
-- On BNOT reduce production localVariableDeclOrStmt -> statement 
-- On ASSERT reduce production localVariableDeclOrStmt -> statement 

State 424:
arrayAccess -> qualifiedName . LBRAC expression RBRAC [ XOREQUAL XOR SEMI RSHIFTEQUAL RSHIFT QM PLUS PEQUAL OREQUAL OR NEQUAL MULEQUAL MUL MODEQUAL MOD MINUSEQUAL MINUS LTHAN LSHIFTEQUAL LSHIFT LPAR LOGSHIFTEQUAL LOGSHIFT LETHAN LBRAC INSTANCEOF INCREMENT GTHAN GETHAN EQUAL DOT DIVEQUAL DIV DECREMENT BOR BAND ASSIGN ANDEQUAL AND ]
fieldAccess -> qualifiedName . DOT THIS [ XOREQUAL XOR SEMI RSHIFTEQUAL RSHIFT QM PLUS PEQUAL OREQUAL OR NEQUAL MULEQUAL MUL MODEQUAL MOD MINUSEQUAL MINUS LTHAN LSHIFTEQUAL LSHIFT LPAR LOGSHIFTEQUAL LOGSHIFT LETHAN LBRAC INSTANCEOF INCREMENT GTHAN GETHAN EQUAL DOT DIVEQUAL DIV DECREMENT BOR BAND ASSIGN ANDEQUAL AND ]
fieldAccess -> qualifiedName . DOT CLASS [ XOREQUAL XOR SEMI RSHIFTEQUAL RSHIFT QM PLUS PEQUAL OREQUAL OR NEQUAL MULEQUAL MUL MODEQUAL MOD MINUSEQUAL MINUS LTHAN LSHIFTEQUAL LSHIFT LPAR LOGSHIFTEQUAL LOGSHIFT LETHAN LBRAC INSTANCEOF INCREMENT GTHAN GETHAN EQUAL DOT DIVEQUAL DIV DECREMENT BOR BAND ASSIGN ANDEQUAL AND ]
methodAccess -> qualifiedName . [ LPAR ]
newAllocationExpression -> qualifiedName . DOT plainNewAllocationExpression [ XOREQUAL XOR SEMI RSHIFTEQUAL RSHIFT QM PLUS PEQUAL OREQUAL OR NEQUAL MULEQUAL MUL MODEQUAL MOD MINUSEQUAL MINUS LTHAN LSHIFTEQUAL LSHIFT LOGSHIFTEQUAL LOGSHIFT LETHAN INSTANCEOF INCREMENT GTHAN GETHAN EQUAL DOT DIVEQUAL DIV DECREMENT BOR BAND ASSIGN ANDEQUAL AND ]
primaryExpression -> qualifiedName . [ XOREQUAL XOR SEMI RSHIFTEQUAL RSHIFT QM PLUS PEQUAL OREQUAL OR NEQUAL MULEQUAL MUL MODEQUAL MOD MINUSEQUAL MINUS LTHAN LSHIFTEQUAL LSHIFT LOGSHIFTEQUAL LOGSHIFT LETHAN INSTANCEOF INCREMENT GTHAN GETHAN EQUAL DIVEQUAL DIV DECREMENT BOR BAND ASSIGN ANDEQUAL AND ]
qualifiedName -> qualifiedName . DOT IDENTIFIER [ XOREQUAL XOR SEMI RSHIFTEQUAL RSHIFT QM PLUS PEQUAL OREQUAL OR NEQUAL MULEQUAL MUL MODEQUAL MOD MINUSEQUAL MINUS LTHAN LSHIFTEQUAL LSHIFT LPAR LOGSHIFTEQUAL LOGSHIFT LETHAN LBRAC INSTANCEOF INCREMENT IDENTIFIER GTHAN GETHAN EQUAL DOT DIVEQUAL DIV DIM DECREMENT BOR BAND ASSIGN ANDEQUAL AND ]
typeName -> qualifiedName . [ IDENTIFIER DIM ]
-- On LBRAC shift to state 43
-- On DOT shift to state 176
-- On XOREQUAL reduce production primaryExpression -> qualifiedName 
-- On XOR reduce production primaryExpression -> qualifiedName 
-- On SEMI reduce production primaryExpression -> qualifiedName 
-- On RSHIFTEQUAL reduce production primaryExpression -> qualifiedName 
-- On RSHIFT reduce production primaryExpression -> qualifiedName 
-- On QM reduce production primaryExpression -> qualifiedName 
-- On PLUS reduce production primaryExpression -> qualifiedName 
-- On PEQUAL reduce production primaryExpression -> qualifiedName 
-- On OREQUAL reduce production primaryExpression -> qualifiedName 
-- On OR reduce production primaryExpression -> qualifiedName 
-- On NEQUAL reduce production primaryExpression -> qualifiedName 
-- On MULEQUAL reduce production primaryExpression -> qualifiedName 
-- On MUL reduce production primaryExpression -> qualifiedName 
-- On MODEQUAL reduce production primaryExpression -> qualifiedName 
-- On MOD reduce production primaryExpression -> qualifiedName 
-- On MINUSEQUAL reduce production primaryExpression -> qualifiedName 
-- On MINUS reduce production primaryExpression -> qualifiedName 
-- On LTHAN reduce production primaryExpression -> qualifiedName 
-- On LSHIFTEQUAL reduce production primaryExpression -> qualifiedName 
-- On LSHIFT reduce production primaryExpression -> qualifiedName 
-- On LPAR reduce production methodAccess -> qualifiedName 
-- On LOGSHIFTEQUAL reduce production primaryExpression -> qualifiedName 
-- On LOGSHIFT reduce production primaryExpression -> qualifiedName 
-- On LETHAN reduce production primaryExpression -> qualifiedName 
-- On INSTANCEOF reduce production primaryExpression -> qualifiedName 
-- On INCREMENT reduce production primaryExpression -> qualifiedName 
-- On IDENTIFIER reduce production typeName -> qualifiedName 
-- On GTHAN reduce production primaryExpression -> qualifiedName 
-- On GETHAN reduce production primaryExpression -> qualifiedName 
-- On EQUAL reduce production primaryExpression -> qualifiedName 
-- On DIVEQUAL reduce production primaryExpression -> qualifiedName 
-- On DIV reduce production primaryExpression -> qualifiedName 
-- On DIM reduce production typeName -> qualifiedName 
-- On DECREMENT reduce production primaryExpression -> qualifiedName 
-- On BOR reduce production primaryExpression -> qualifiedName 
-- On BAND reduce production primaryExpression -> qualifiedName 
-- On ASSIGN reduce production primaryExpression -> qualifiedName 
-- On ANDEQUAL reduce production primaryExpression -> qualifiedName 
-- On AND reduce production primaryExpression -> qualifiedName 

State 425:
fieldAccess -> primitiveType . DOT CLASS [ XOREQUAL XOR SEMI RSHIFTEQUAL RSHIFT QM PLUS PEQUAL OREQUAL OR NEQUAL MULEQUAL MUL MODEQUAL MOD MINUSEQUAL MINUS LTHAN LSHIFTEQUAL LSHIFT LPAR LOGSHIFTEQUAL LOGSHIFT LETHAN LBRAC INSTANCEOF INCREMENT GTHAN GETHAN EQUAL DOT DIVEQUAL DIV DECREMENT BOR BAND ASSIGN ANDEQUAL AND ]
typeName -> primitiveType . [ IDENTIFIER DIM ]
-- On DOT shift to state 62
-- On IDENTIFIER reduce production typeName -> primitiveType 
-- On DIM reduce production typeName -> primitiveType 

State 426:
localVariableDeclOrStmt -> localVariableDeclStmt . [ error WHILE VOID TRY THROW THIS SYNCHRONIZED SWITCH SUPER STRLIT SHORT SEMI RETURN RCURL PLUS NULLLIT NOT NEW MINUS LPAR LONG LCURL INTLIT INT INCREMENT IF IDENTIFIER FOR FLOATLIT FLOAT FINAL DOUBLELIT DOUBLE DO DECREMENT CONTINUE CHARLIT CHAR BYTE BREAK BOOLEANLIT BOOLEAN BNOT ASSERT ]
-- On error reduce production localVariableDeclOrStmt -> localVariableDeclStmt 
-- On WHILE reduce production localVariableDeclOrStmt -> localVariableDeclStmt 
-- On VOID reduce production localVariableDeclOrStmt -> localVariableDeclStmt 
-- On TRY reduce production localVariableDeclOrStmt -> localVariableDeclStmt 
-- On THROW reduce production localVariableDeclOrStmt -> localVariableDeclStmt 
-- On THIS reduce production localVariableDeclOrStmt -> localVariableDeclStmt 
-- On SYNCHRONIZED reduce production localVariableDeclOrStmt -> localVariableDeclStmt 
-- On SWITCH reduce production localVariableDeclOrStmt -> localVariableDeclStmt 
-- On SUPER reduce production localVariableDeclOrStmt -> localVariableDeclStmt 
-- On STRLIT reduce production localVariableDeclOrStmt -> localVariableDeclStmt 
-- On SHORT reduce production localVariableDeclOrStmt -> localVariableDeclStmt 
-- On SEMI reduce production localVariableDeclOrStmt -> localVariableDeclStmt 
-- On RETURN reduce production localVariableDeclOrStmt -> localVariableDeclStmt 
-- On RCURL reduce production localVariableDeclOrStmt -> localVariableDeclStmt 
-- On PLUS reduce production localVariableDeclOrStmt -> localVariableDeclStmt 
-- On NULLLIT reduce production localVariableDeclOrStmt -> localVariableDeclStmt 
-- On NOT reduce production localVariableDeclOrStmt -> localVariableDeclStmt 
-- On NEW reduce production localVariableDeclOrStmt -> localVariableDeclStmt 
-- On MINUS reduce production localVariableDeclOrStmt -> localVariableDeclStmt 
-- On LPAR reduce production localVariableDeclOrStmt -> localVariableDeclStmt 
-- On LONG reduce production localVariableDeclOrStmt -> localVariableDeclStmt 
-- On LCURL reduce production localVariableDeclOrStmt -> localVariableDeclStmt 
-- On INTLIT reduce production localVariableDeclOrStmt -> localVariableDeclStmt 
-- On INT reduce production localVariableDeclOrStmt -> localVariableDeclStmt 
-- On INCREMENT reduce production localVariableDeclOrStmt -> localVariableDeclStmt 
-- On IF reduce production localVariableDeclOrStmt -> localVariableDeclStmt 
-- On IDENTIFIER reduce production localVariableDeclOrStmt -> localVariableDeclStmt 
-- On FOR reduce production localVariableDeclOrStmt -> localVariableDeclStmt 
-- On FLOATLIT reduce production localVariableDeclOrStmt -> localVariableDeclStmt 
-- On FLOAT reduce production localVariableDeclOrStmt -> localVariableDeclStmt 
-- On FINAL reduce production localVariableDeclOrStmt -> localVariableDeclStmt 
-- On DOUBLELIT reduce production localVariableDeclOrStmt -> localVariableDeclStmt 
-- On DOUBLE reduce production localVariableDeclOrStmt -> localVariableDeclStmt 
-- On DO reduce production localVariableDeclOrStmt -> localVariableDeclStmt 
-- On DECREMENT reduce production localVariableDeclOrStmt -> localVariableDeclStmt 
-- On CONTINUE reduce production localVariableDeclOrStmt -> localVariableDeclStmt 
-- On CHARLIT reduce production localVariableDeclOrStmt -> localVariableDeclStmt 
-- On CHAR reduce production localVariableDeclOrStmt -> localVariableDeclStmt 
-- On BYTE reduce production localVariableDeclOrStmt -> localVariableDeclStmt 
-- On BREAK reduce production localVariableDeclOrStmt -> localVariableDeclStmt 
-- On BOOLEANLIT reduce production localVariableDeclOrStmt -> localVariableDeclStmt 
-- On BOOLEAN reduce production localVariableDeclOrStmt -> localVariableDeclStmt 
-- On BNOT reduce production localVariableDeclOrStmt -> localVariableDeclStmt 
-- On ASSERT reduce production localVariableDeclOrStmt -> localVariableDeclStmt 

State 427:
localVariableDeclAndStmts -> localVariableDeclOrStmt . [ error WHILE VOID TRY THROW THIS SYNCHRONIZED SWITCH SUPER STRLIT SHORT SEMI RETURN RCURL PLUS NULLLIT NOT NEW MINUS LPAR LONG LCURL INTLIT INT INCREMENT IF IDENTIFIER FOR FLOATLIT FLOAT FINAL DOUBLELIT DOUBLE DO DECREMENT CONTINUE CHARLIT CHAR BYTE BREAK BOOLEANLIT BOOLEAN BNOT ASSERT ]
-- On error reduce production localVariableDeclAndStmts -> localVariableDeclOrStmt 
-- On WHILE reduce production localVariableDeclAndStmts -> localVariableDeclOrStmt 
-- On VOID reduce production localVariableDeclAndStmts -> localVariableDeclOrStmt 
-- On TRY reduce production localVariableDeclAndStmts -> localVariableDeclOrStmt 
-- On THROW reduce production localVariableDeclAndStmts -> localVariableDeclOrStmt 
-- On THIS reduce production localVariableDeclAndStmts -> localVariableDeclOrStmt 
-- On SYNCHRONIZED reduce production localVariableDeclAndStmts -> localVariableDeclOrStmt 
-- On SWITCH reduce production localVariableDeclAndStmts -> localVariableDeclOrStmt 
-- On SUPER reduce production localVariableDeclAndStmts -> localVariableDeclOrStmt 
-- On STRLIT reduce production localVariableDeclAndStmts -> localVariableDeclOrStmt 
-- On SHORT reduce production localVariableDeclAndStmts -> localVariableDeclOrStmt 
-- On SEMI reduce production localVariableDeclAndStmts -> localVariableDeclOrStmt 
-- On RETURN reduce production localVariableDeclAndStmts -> localVariableDeclOrStmt 
-- On RCURL reduce production localVariableDeclAndStmts -> localVariableDeclOrStmt 
-- On PLUS reduce production localVariableDeclAndStmts -> localVariableDeclOrStmt 
-- On NULLLIT reduce production localVariableDeclAndStmts -> localVariableDeclOrStmt 
-- On NOT reduce production localVariableDeclAndStmts -> localVariableDeclOrStmt 
-- On NEW reduce production localVariableDeclAndStmts -> localVariableDeclOrStmt 
-- On MINUS reduce production localVariableDeclAndStmts -> localVariableDeclOrStmt 
-- On LPAR reduce production localVariableDeclAndStmts -> localVariableDeclOrStmt 
-- On LONG reduce production localVariableDeclAndStmts -> localVariableDeclOrStmt 
-- On LCURL reduce production localVariableDeclAndStmts -> localVariableDeclOrStmt 
-- On INTLIT reduce production localVariableDeclAndStmts -> localVariableDeclOrStmt 
-- On INT reduce production localVariableDeclAndStmts -> localVariableDeclOrStmt 
-- On INCREMENT reduce production localVariableDeclAndStmts -> localVariableDeclOrStmt 
-- On IF reduce production localVariableDeclAndStmts -> localVariableDeclOrStmt 
-- On IDENTIFIER reduce production localVariableDeclAndStmts -> localVariableDeclOrStmt 
-- On FOR reduce production localVariableDeclAndStmts -> localVariableDeclOrStmt 
-- On FLOATLIT reduce production localVariableDeclAndStmts -> localVariableDeclOrStmt 
-- On FLOAT reduce production localVariableDeclAndStmts -> localVariableDeclOrStmt 
-- On FINAL reduce production localVariableDeclAndStmts -> localVariableDeclOrStmt 
-- On DOUBLELIT reduce production localVariableDeclAndStmts -> localVariableDeclOrStmt 
-- On DOUBLE reduce production localVariableDeclAndStmts -> localVariableDeclOrStmt 
-- On DO reduce production localVariableDeclAndStmts -> localVariableDeclOrStmt 
-- On DECREMENT reduce production localVariableDeclAndStmts -> localVariableDeclOrStmt 
-- On CONTINUE reduce production localVariableDeclAndStmts -> localVariableDeclOrStmt 
-- On CHARLIT reduce production localVariableDeclAndStmts -> localVariableDeclOrStmt 
-- On CHAR reduce production localVariableDeclAndStmts -> localVariableDeclOrStmt 
-- On BYTE reduce production localVariableDeclAndStmts -> localVariableDeclOrStmt 
-- On BREAK reduce production localVariableDeclAndStmts -> localVariableDeclOrStmt 
-- On BOOLEANLIT reduce production localVariableDeclAndStmts -> localVariableDeclOrStmt 
-- On BOOLEAN reduce production localVariableDeclAndStmts -> localVariableDeclOrStmt 
-- On BNOT reduce production localVariableDeclAndStmts -> localVariableDeclOrStmt 
-- On ASSERT reduce production localVariableDeclAndStmts -> localVariableDeclOrStmt 

State 428:
block -> LCURL localVariableDeclAndStmts . RCURL [ error WHILE VOID TRY THROW THIS SYNCHRONIZED SWITCH SUPER STRLIT SHORT SEMI RETURN RCURL PLUS NULLLIT NOT NEW MINUS LPAR LONG LCURL INTLIT INT INCREMENT IF IDENTIFIER FOR FLOATLIT FLOAT FINALLY FINAL ELSE DOUBLELIT DOUBLE DO DECREMENT CONTINUE CHARLIT CHAR CATCH BYTE BREAK BOOLEANLIT BOOLEAN BNOT ASSERT ]
localVariableDeclAndStmts -> localVariableDeclAndStmts . localVariableDeclOrStmt [ error WHILE VOID TRY THROW THIS SYNCHRONIZED SWITCH SUPER STRLIT SHORT SEMI RETURN RCURL PLUS NULLLIT NOT NEW MINUS LPAR LONG LCURL INTLIT INT INCREMENT IF IDENTIFIER FOR FLOATLIT FLOAT FINAL DOUBLELIT DOUBLE DO DECREMENT CONTINUE CHARLIT CHAR BYTE BREAK BOOLEANLIT BOOLEAN BNOT ASSERT ]
-- On error shift to state 3
-- On WHILE shift to state 4
-- On VOID shift to state 6
-- On TRY shift to state 208
-- On THROW shift to state 210
-- On THIS shift to state 7
-- On SYNCHRONIZED shift to state 213
-- On SWITCH shift to state 217
-- On SUPER shift to state 8
-- On STRLIT shift to state 9
-- On SHORT shift to state 10
-- On SEMI shift to state 238
-- On RETURN shift to state 239
-- On RCURL shift to state 429
-- On PLUS shift to state 11
-- On NULLLIT shift to state 12
-- On NOT shift to state 13
-- On NEW shift to state 14
-- On MINUS shift to state 26
-- On LPAR shift to state 27
-- On LONG shift to state 15
-- On LCURL shift to state 243
-- On INTLIT shift to state 28
-- On INT shift to state 16
-- On INCREMENT shift to state 29
-- On IF shift to state 245
-- On IDENTIFIER shift to state 249
-- On FOR shift to state 251
-- On FLOATLIT shift to state 31
-- On FLOAT shift to state 18
-- On FINAL shift to state 254
-- On DOUBLELIT shift to state 32
-- On DOUBLE shift to state 19
-- On DO shift to state 274
-- On DECREMENT shift to state 33
-- On CONTINUE shift to state 387
-- On CHARLIT shift to state 34
-- On CHAR shift to state 20
-- On BYTE shift to state 21
-- On BREAK shift to state 391
-- On BOOLEANLIT shift to state 35
-- On BOOLEAN shift to state 22
-- On BNOT shift to state 36
-- On ASSERT shift to state 395
-- On unaryExpression shift to state 44
-- On typeSpecifier shift to state 422
-- On typeName shift to state 130
-- On statement shift to state 423
-- On specialName shift to state 38
-- On shiftExpression shift to state 58
-- On selectStmt shift to state 402
-- On relationalExpression shift to state 79
-- On realPostfixExpression shift to state 39
-- On qualifiedName shift to state 424
-- On primitiveType shift to state 425
-- On primaryExpression shift to state 64
-- On postfixExpression shift to state 65
-- On plainNewAllocationExpression shift to state 68
-- On notJustName shift to state 69
-- On newAllocationExpression shift to state 72
-- On multiplicativeExpression shift to state 73
-- On methodCall shift to state 75
-- On methodAccess shift to state 76
-- On logicalUnaryOperator shift to state 83
-- On logicalUnaryExpression shift to state 85
-- On localVariableDeclStmt shift to state 426
-- On localVariableDeclOrStmt shift to state 430
-- On labelStmt shift to state 403
-- On jumpStmt shift to state 404
-- On iterStmt shift to state 405
-- On inclusiveOrExpression shift to state 90
-- On guardingStmt shift to state 406
-- On fieldAccess shift to state 86
-- On expressionStmt shift to state 407
-- On expression shift to state 357
-- On exclusiveOrExpression shift to state 111
-- On equalityExpression shift to state 94
-- On emptyStmt shift to state 409
-- On conditionalOrExpression shift to state 112
-- On conditionalExpression shift to state 151
-- On conditionalAndExpression shift to state 117
-- On complexPrimaryNoParenthesis shift to state 87
-- On complexPrimary shift to state 88
-- On classAllocationExpression shift to state 100
-- On castExpression shift to state 103
-- On block shift to state 410
-- On assignmentExpression shift to state 152
-- On assertStmt shift to state 411
-- On arrayAllocationExpression shift to state 104
-- On arrayAccess shift to state 120
-- On arithmeticUnaryOperator shift to state 121
-- On andExpression shift to state 123
-- On additiveExpression shift to state 140

State 429:
block -> LCURL localVariableDeclAndStmts RCURL . [ error WHILE VOID TRY THROW THIS SYNCHRONIZED SWITCH SUPER STRLIT SHORT SEMI RETURN RCURL PLUS NULLLIT NOT NEW MINUS LPAR LONG LCURL INTLIT INT INCREMENT IF IDENTIFIER FOR FLOATLIT FLOAT FINALLY FINAL ELSE DOUBLELIT DOUBLE DO DECREMENT CONTINUE CHARLIT CHAR CATCH BYTE BREAK BOOLEANLIT BOOLEAN BNOT ASSERT ]
-- On error reduce production block -> LCURL localVariableDeclAndStmts RCURL 
-- On WHILE reduce production block -> LCURL localVariableDeclAndStmts RCURL 
-- On VOID reduce production block -> LCURL localVariableDeclAndStmts RCURL 
-- On TRY reduce production block -> LCURL localVariableDeclAndStmts RCURL 
-- On THROW reduce production block -> LCURL localVariableDeclAndStmts RCURL 
-- On THIS reduce production block -> LCURL localVariableDeclAndStmts RCURL 
-- On SYNCHRONIZED reduce production block -> LCURL localVariableDeclAndStmts RCURL 
-- On SWITCH reduce production block -> LCURL localVariableDeclAndStmts RCURL 
-- On SUPER reduce production block -> LCURL localVariableDeclAndStmts RCURL 
-- On STRLIT reduce production block -> LCURL localVariableDeclAndStmts RCURL 
-- On SHORT reduce production block -> LCURL localVariableDeclAndStmts RCURL 
-- On SEMI reduce production block -> LCURL localVariableDeclAndStmts RCURL 
-- On RETURN reduce production block -> LCURL localVariableDeclAndStmts RCURL 
-- On RCURL reduce production block -> LCURL localVariableDeclAndStmts RCURL 
-- On PLUS reduce production block -> LCURL localVariableDeclAndStmts RCURL 
-- On NULLLIT reduce production block -> LCURL localVariableDeclAndStmts RCURL 
-- On NOT reduce production block -> LCURL localVariableDeclAndStmts RCURL 
-- On NEW reduce production block -> LCURL localVariableDeclAndStmts RCURL 
-- On MINUS reduce production block -> LCURL localVariableDeclAndStmts RCURL 
-- On LPAR reduce production block -> LCURL localVariableDeclAndStmts RCURL 
-- On LONG reduce production block -> LCURL localVariableDeclAndStmts RCURL 
-- On LCURL reduce production block -> LCURL localVariableDeclAndStmts RCURL 
-- On INTLIT reduce production block -> LCURL localVariableDeclAndStmts RCURL 
-- On INT reduce production block -> LCURL localVariableDeclAndStmts RCURL 
-- On INCREMENT reduce production block -> LCURL localVariableDeclAndStmts RCURL 
-- On IF reduce production block -> LCURL localVariableDeclAndStmts RCURL 
-- On IDENTIFIER reduce production block -> LCURL localVariableDeclAndStmts RCURL 
-- On FOR reduce production block -> LCURL localVariableDeclAndStmts RCURL 
-- On FLOATLIT reduce production block -> LCURL localVariableDeclAndStmts RCURL 
-- On FLOAT reduce production block -> LCURL localVariableDeclAndStmts RCURL 
-- On FINALLY reduce production block -> LCURL localVariableDeclAndStmts RCURL 
-- On FINAL reduce production block -> LCURL localVariableDeclAndStmts RCURL 
-- On ELSE reduce production block -> LCURL localVariableDeclAndStmts RCURL 
-- On DOUBLELIT reduce production block -> LCURL localVariableDeclAndStmts RCURL 
-- On DOUBLE reduce production block -> LCURL localVariableDeclAndStmts RCURL 
-- On DO reduce production block -> LCURL localVariableDeclAndStmts RCURL 
-- On DECREMENT reduce production block -> LCURL localVariableDeclAndStmts RCURL 
-- On CONTINUE reduce production block -> LCURL localVariableDeclAndStmts RCURL 
-- On CHARLIT reduce production block -> LCURL localVariableDeclAndStmts RCURL 
-- On CHAR reduce production block -> LCURL localVariableDeclAndStmts RCURL 
-- On CATCH reduce production block -> LCURL localVariableDeclAndStmts RCURL 
-- On BYTE reduce production block -> LCURL localVariableDeclAndStmts RCURL 
-- On BREAK reduce production block -> LCURL localVariableDeclAndStmts RCURL 
-- On BOOLEANLIT reduce production block -> LCURL localVariableDeclAndStmts RCURL 
-- On BOOLEAN reduce production block -> LCURL localVariableDeclAndStmts RCURL 
-- On BNOT reduce production block -> LCURL localVariableDeclAndStmts RCURL 
-- On ASSERT reduce production block -> LCURL localVariableDeclAndStmts RCURL 

State 430:
localVariableDeclAndStmts -> localVariableDeclAndStmts localVariableDeclOrStmt . [ error WHILE VOID TRY THROW THIS SYNCHRONIZED SWITCH SUPER STRLIT SHORT SEMI RETURN RCURL PLUS NULLLIT NOT NEW MINUS LPAR LONG LCURL INTLIT INT INCREMENT IF IDENTIFIER FOR FLOATLIT FLOAT FINAL DOUBLELIT DOUBLE DO DECREMENT CONTINUE CHARLIT CHAR BYTE BREAK BOOLEANLIT BOOLEAN BNOT ASSERT ]
-- On error reduce production localVariableDeclAndStmts -> localVariableDeclAndStmts localVariableDeclOrStmt 
-- On WHILE reduce production localVariableDeclAndStmts -> localVariableDeclAndStmts localVariableDeclOrStmt 
-- On VOID reduce production localVariableDeclAndStmts -> localVariableDeclAndStmts localVariableDeclOrStmt 
-- On TRY reduce production localVariableDeclAndStmts -> localVariableDeclAndStmts localVariableDeclOrStmt 
-- On THROW reduce production localVariableDeclAndStmts -> localVariableDeclAndStmts localVariableDeclOrStmt 
-- On THIS reduce production localVariableDeclAndStmts -> localVariableDeclAndStmts localVariableDeclOrStmt 
-- On SYNCHRONIZED reduce production localVariableDeclAndStmts -> localVariableDeclAndStmts localVariableDeclOrStmt 
-- On SWITCH reduce production localVariableDeclAndStmts -> localVariableDeclAndStmts localVariableDeclOrStmt 
-- On SUPER reduce production localVariableDeclAndStmts -> localVariableDeclAndStmts localVariableDeclOrStmt 
-- On STRLIT reduce production localVariableDeclAndStmts -> localVariableDeclAndStmts localVariableDeclOrStmt 
-- On SHORT reduce production localVariableDeclAndStmts -> localVariableDeclAndStmts localVariableDeclOrStmt 
-- On SEMI reduce production localVariableDeclAndStmts -> localVariableDeclAndStmts localVariableDeclOrStmt 
-- On RETURN reduce production localVariableDeclAndStmts -> localVariableDeclAndStmts localVariableDeclOrStmt 
-- On RCURL reduce production localVariableDeclAndStmts -> localVariableDeclAndStmts localVariableDeclOrStmt 
-- On PLUS reduce production localVariableDeclAndStmts -> localVariableDeclAndStmts localVariableDeclOrStmt 
-- On NULLLIT reduce production localVariableDeclAndStmts -> localVariableDeclAndStmts localVariableDeclOrStmt 
-- On NOT reduce production localVariableDeclAndStmts -> localVariableDeclAndStmts localVariableDeclOrStmt 
-- On NEW reduce production localVariableDeclAndStmts -> localVariableDeclAndStmts localVariableDeclOrStmt 
-- On MINUS reduce production localVariableDeclAndStmts -> localVariableDeclAndStmts localVariableDeclOrStmt 
-- On LPAR reduce production localVariableDeclAndStmts -> localVariableDeclAndStmts localVariableDeclOrStmt 
-- On LONG reduce production localVariableDeclAndStmts -> localVariableDeclAndStmts localVariableDeclOrStmt 
-- On LCURL reduce production localVariableDeclAndStmts -> localVariableDeclAndStmts localVariableDeclOrStmt 
-- On INTLIT reduce production localVariableDeclAndStmts -> localVariableDeclAndStmts localVariableDeclOrStmt 
-- On INT reduce production localVariableDeclAndStmts -> localVariableDeclAndStmts localVariableDeclOrStmt 
-- On INCREMENT reduce production localVariableDeclAndStmts -> localVariableDeclAndStmts localVariableDeclOrStmt 
-- On IF reduce production localVariableDeclAndStmts -> localVariableDeclAndStmts localVariableDeclOrStmt 
-- On IDENTIFIER reduce production localVariableDeclAndStmts -> localVariableDeclAndStmts localVariableDeclOrStmt 
-- On FOR reduce production localVariableDeclAndStmts -> localVariableDeclAndStmts localVariableDeclOrStmt 
-- On FLOATLIT reduce production localVariableDeclAndStmts -> localVariableDeclAndStmts localVariableDeclOrStmt 
-- On FLOAT reduce production localVariableDeclAndStmts -> localVariableDeclAndStmts localVariableDeclOrStmt 
-- On FINAL reduce production localVariableDeclAndStmts -> localVariableDeclAndStmts localVariableDeclOrStmt 
-- On DOUBLELIT reduce production localVariableDeclAndStmts -> localVariableDeclAndStmts localVariableDeclOrStmt 
-- On DOUBLE reduce production localVariableDeclAndStmts -> localVariableDeclAndStmts localVariableDeclOrStmt 
-- On DO reduce production localVariableDeclAndStmts -> localVariableDeclAndStmts localVariableDeclOrStmt 
-- On DECREMENT reduce production localVariableDeclAndStmts -> localVariableDeclAndStmts localVariableDeclOrStmt 
-- On CONTINUE reduce production localVariableDeclAndStmts -> localVariableDeclAndStmts localVariableDeclOrStmt 
-- On CHARLIT reduce production localVariableDeclAndStmts -> localVariableDeclAndStmts localVariableDeclOrStmt 
-- On CHAR reduce production localVariableDeclAndStmts -> localVariableDeclAndStmts localVariableDeclOrStmt 
-- On BYTE reduce production localVariableDeclAndStmts -> localVariableDeclAndStmts localVariableDeclOrStmt 
-- On BREAK reduce production localVariableDeclAndStmts -> localVariableDeclAndStmts localVariableDeclOrStmt 
-- On BOOLEANLIT reduce production localVariableDeclAndStmts -> localVariableDeclAndStmts localVariableDeclOrStmt 
-- On BOOLEAN reduce production localVariableDeclAndStmts -> localVariableDeclAndStmts localVariableDeclOrStmt 
-- On BNOT reduce production localVariableDeclAndStmts -> localVariableDeclAndStmts localVariableDeclOrStmt 
-- On ASSERT reduce production localVariableDeclAndStmts -> localVariableDeclAndStmts localVariableDeclOrStmt 

State 431:
guardingStmt -> SYNCHRONIZED LPAR expression RPAR statement . [ error WHILE VOID TRY THROW THIS SYNCHRONIZED SWITCH SUPER STRLIT SHORT SEMI RETURN RCURL PLUS NULLLIT NOT NEW MINUS LPAR LONG LCURL INTLIT INT INCREMENT IF IDENTIFIER FOR FLOATLIT FLOAT FINAL ELSE DOUBLELIT DOUBLE DO DECREMENT CONTINUE CHARLIT CHAR BYTE BREAK BOOLEANLIT BOOLEAN BNOT ASSERT ]
-- On error reduce production guardingStmt -> SYNCHRONIZED LPAR expression RPAR statement 
-- On WHILE reduce production guardingStmt -> SYNCHRONIZED LPAR expression RPAR statement 
-- On VOID reduce production guardingStmt -> SYNCHRONIZED LPAR expression RPAR statement 
-- On TRY reduce production guardingStmt -> SYNCHRONIZED LPAR expression RPAR statement 
-- On THROW reduce production guardingStmt -> SYNCHRONIZED LPAR expression RPAR statement 
-- On THIS reduce production guardingStmt -> SYNCHRONIZED LPAR expression RPAR statement 
-- On SYNCHRONIZED reduce production guardingStmt -> SYNCHRONIZED LPAR expression RPAR statement 
-- On SWITCH reduce production guardingStmt -> SYNCHRONIZED LPAR expression RPAR statement 
-- On SUPER reduce production guardingStmt -> SYNCHRONIZED LPAR expression RPAR statement 
-- On STRLIT reduce production guardingStmt -> SYNCHRONIZED LPAR expression RPAR statement 
-- On SHORT reduce production guardingStmt -> SYNCHRONIZED LPAR expression RPAR statement 
-- On SEMI reduce production guardingStmt -> SYNCHRONIZED LPAR expression RPAR statement 
-- On RETURN reduce production guardingStmt -> SYNCHRONIZED LPAR expression RPAR statement 
-- On RCURL reduce production guardingStmt -> SYNCHRONIZED LPAR expression RPAR statement 
-- On PLUS reduce production guardingStmt -> SYNCHRONIZED LPAR expression RPAR statement 
-- On NULLLIT reduce production guardingStmt -> SYNCHRONIZED LPAR expression RPAR statement 
-- On NOT reduce production guardingStmt -> SYNCHRONIZED LPAR expression RPAR statement 
-- On NEW reduce production guardingStmt -> SYNCHRONIZED LPAR expression RPAR statement 
-- On MINUS reduce production guardingStmt -> SYNCHRONIZED LPAR expression RPAR statement 
-- On LPAR reduce production guardingStmt -> SYNCHRONIZED LPAR expression RPAR statement 
-- On LONG reduce production guardingStmt -> SYNCHRONIZED LPAR expression RPAR statement 
-- On LCURL reduce production guardingStmt -> SYNCHRONIZED LPAR expression RPAR statement 
-- On INTLIT reduce production guardingStmt -> SYNCHRONIZED LPAR expression RPAR statement 
-- On INT reduce production guardingStmt -> SYNCHRONIZED LPAR expression RPAR statement 
-- On INCREMENT reduce production guardingStmt -> SYNCHRONIZED LPAR expression RPAR statement 
-- On IF reduce production guardingStmt -> SYNCHRONIZED LPAR expression RPAR statement 
-- On IDENTIFIER reduce production guardingStmt -> SYNCHRONIZED LPAR expression RPAR statement 
-- On FOR reduce production guardingStmt -> SYNCHRONIZED LPAR expression RPAR statement 
-- On FLOATLIT reduce production guardingStmt -> SYNCHRONIZED LPAR expression RPAR statement 
-- On FLOAT reduce production guardingStmt -> SYNCHRONIZED LPAR expression RPAR statement 
-- On FINAL reduce production guardingStmt -> SYNCHRONIZED LPAR expression RPAR statement 
-- On ELSE reduce production guardingStmt -> SYNCHRONIZED LPAR expression RPAR statement 
-- On DOUBLELIT reduce production guardingStmt -> SYNCHRONIZED LPAR expression RPAR statement 
-- On DOUBLE reduce production guardingStmt -> SYNCHRONIZED LPAR expression RPAR statement 
-- On DO reduce production guardingStmt -> SYNCHRONIZED LPAR expression RPAR statement 
-- On DECREMENT reduce production guardingStmt -> SYNCHRONIZED LPAR expression RPAR statement 
-- On CONTINUE reduce production guardingStmt -> SYNCHRONIZED LPAR expression RPAR statement 
-- On CHARLIT reduce production guardingStmt -> SYNCHRONIZED LPAR expression RPAR statement 
-- On CHAR reduce production guardingStmt -> SYNCHRONIZED LPAR expression RPAR statement 
-- On BYTE reduce production guardingStmt -> SYNCHRONIZED LPAR expression RPAR statement 
-- On BREAK reduce production guardingStmt -> SYNCHRONIZED LPAR expression RPAR statement 
-- On BOOLEANLIT reduce production guardingStmt -> SYNCHRONIZED LPAR expression RPAR statement 
-- On BOOLEAN reduce production guardingStmt -> SYNCHRONIZED LPAR expression RPAR statement 
-- On BNOT reduce production guardingStmt -> SYNCHRONIZED LPAR expression RPAR statement 
-- On ASSERT reduce production guardingStmt -> SYNCHRONIZED LPAR expression RPAR statement 

State 432:
block -> LCURL RCURL . [ WHILE RCURL FINALLY ELSE DEFAULT CATCH CASE ]
-- On WHILE reduce production block -> LCURL RCURL 
-- On RCURL reduce production block -> LCURL RCURL 
-- On FINALLY reduce production block -> LCURL RCURL 
-- On ELSE reduce production block -> LCURL RCURL 
-- On DEFAULT reduce production block -> LCURL RCURL 
-- On CATCH reduce production block -> LCURL RCURL 
-- On CASE reduce production block -> LCURL RCURL 

State 433:
block -> LCURL localVariableDeclAndStmts . RCURL [ WHILE RCURL FINALLY ELSE DEFAULT CATCH CASE ]
localVariableDeclAndStmts -> localVariableDeclAndStmts . localVariableDeclOrStmt [ error WHILE VOID TRY THROW THIS SYNCHRONIZED SWITCH SUPER STRLIT SHORT SEMI RETURN RCURL PLUS NULLLIT NOT NEW MINUS LPAR LONG LCURL INTLIT INT INCREMENT IF IDENTIFIER FOR FLOATLIT FLOAT FINAL DOUBLELIT DOUBLE DO DECREMENT CONTINUE CHARLIT CHAR BYTE BREAK BOOLEANLIT BOOLEAN BNOT ASSERT ]
-- On error shift to state 3
-- On WHILE shift to state 4
-- On VOID shift to state 6
-- On TRY shift to state 208
-- On THROW shift to state 210
-- On THIS shift to state 7
-- On SYNCHRONIZED shift to state 213
-- On SWITCH shift to state 217
-- On SUPER shift to state 8
-- On STRLIT shift to state 9
-- On SHORT shift to state 10
-- On SEMI shift to state 238
-- On RETURN shift to state 239
-- On RCURL shift to state 434
-- On PLUS shift to state 11
-- On NULLLIT shift to state 12
-- On NOT shift to state 13
-- On NEW shift to state 14
-- On MINUS shift to state 26
-- On LPAR shift to state 27
-- On LONG shift to state 15
-- On LCURL shift to state 243
-- On INTLIT shift to state 28
-- On INT shift to state 16
-- On INCREMENT shift to state 29
-- On IF shift to state 245
-- On IDENTIFIER shift to state 249
-- On FOR shift to state 251
-- On FLOATLIT shift to state 31
-- On FLOAT shift to state 18
-- On FINAL shift to state 254
-- On DOUBLELIT shift to state 32
-- On DOUBLE shift to state 19
-- On DO shift to state 274
-- On DECREMENT shift to state 33
-- On CONTINUE shift to state 387
-- On CHARLIT shift to state 34
-- On CHAR shift to state 20
-- On BYTE shift to state 21
-- On BREAK shift to state 391
-- On BOOLEANLIT shift to state 35
-- On BOOLEAN shift to state 22
-- On BNOT shift to state 36
-- On ASSERT shift to state 395
-- On unaryExpression shift to state 44
-- On typeSpecifier shift to state 422
-- On typeName shift to state 130
-- On statement shift to state 423
-- On specialName shift to state 38
-- On shiftExpression shift to state 58
-- On selectStmt shift to state 402
-- On relationalExpression shift to state 79
-- On realPostfixExpression shift to state 39
-- On qualifiedName shift to state 424
-- On primitiveType shift to state 425
-- On primaryExpression shift to state 64
-- On postfixExpression shift to state 65
-- On plainNewAllocationExpression shift to state 68
-- On notJustName shift to state 69
-- On newAllocationExpression shift to state 72
-- On multiplicativeExpression shift to state 73
-- On methodCall shift to state 75
-- On methodAccess shift to state 76
-- On logicalUnaryOperator shift to state 83
-- On logicalUnaryExpression shift to state 85
-- On localVariableDeclStmt shift to state 426
-- On localVariableDeclOrStmt shift to state 430
-- On labelStmt shift to state 403
-- On jumpStmt shift to state 404
-- On iterStmt shift to state 405
-- On inclusiveOrExpression shift to state 90
-- On guardingStmt shift to state 406
-- On fieldAccess shift to state 86
-- On expressionStmt shift to state 407
-- On expression shift to state 357
-- On exclusiveOrExpression shift to state 111
-- On equalityExpression shift to state 94
-- On emptyStmt shift to state 409
-- On conditionalOrExpression shift to state 112
-- On conditionalExpression shift to state 151
-- On conditionalAndExpression shift to state 117
-- On complexPrimaryNoParenthesis shift to state 87
-- On complexPrimary shift to state 88
-- On classAllocationExpression shift to state 100
-- On castExpression shift to state 103
-- On block shift to state 410
-- On assignmentExpression shift to state 152
-- On assertStmt shift to state 411
-- On arrayAllocationExpression shift to state 104
-- On arrayAccess shift to state 120
-- On arithmeticUnaryOperator shift to state 121
-- On andExpression shift to state 123
-- On additiveExpression shift to state 140

State 434:
block -> LCURL localVariableDeclAndStmts RCURL . [ WHILE RCURL FINALLY ELSE DEFAULT CATCH CASE ]
-- On WHILE reduce production block -> LCURL localVariableDeclAndStmts RCURL 
-- On RCURL reduce production block -> LCURL localVariableDeclAndStmts RCURL 
-- On FINALLY reduce production block -> LCURL localVariableDeclAndStmts RCURL 
-- On ELSE reduce production block -> LCURL localVariableDeclAndStmts RCURL 
-- On DEFAULT reduce production block -> LCURL localVariableDeclAndStmts RCURL 
-- On CATCH reduce production block -> LCURL localVariableDeclAndStmts RCURL 
-- On CASE reduce production block -> LCURL localVariableDeclAndStmts RCURL 

State 435:
guardingStmt -> TRY block . finally [ error WHILE VOID TRY THROW THIS SYNCHRONIZED SWITCH SUPER STRLIT SHORT SEMI RETURN RCURL PLUS NULLLIT NOT NEW MINUS LPAR LONG LCURL INTLIT INT INCREMENT IF IDENTIFIER FOR FLOATLIT FLOAT FINAL ELSE DOUBLELIT DOUBLE DO DECREMENT CONTINUE CHARLIT CHAR BYTE BREAK BOOLEANLIT BOOLEAN BNOT ASSERT ]
guardingStmt -> TRY block . catches [ error WHILE VOID TRY THROW THIS SYNCHRONIZED SWITCH SUPER STRLIT SHORT SEMI RETURN RCURL PLUS NULLLIT NOT NEW MINUS LPAR LONG LCURL INTLIT INT INCREMENT IF IDENTIFIER FOR FLOATLIT FLOAT FINAL ELSE DOUBLELIT DOUBLE DO DECREMENT CONTINUE CHARLIT CHAR BYTE BREAK BOOLEANLIT BOOLEAN BNOT ASSERT ]
guardingStmt -> TRY block . catches finally [ error WHILE VOID TRY THROW THIS SYNCHRONIZED SWITCH SUPER STRLIT SHORT SEMI RETURN RCURL PLUS NULLLIT NOT NEW MINUS LPAR LONG LCURL INTLIT INT INCREMENT IF IDENTIFIER FOR FLOATLIT FLOAT FINAL ELSE DOUBLELIT DOUBLE DO DECREMENT CONTINUE CHARLIT CHAR BYTE BREAK BOOLEANLIT BOOLEAN BNOT ASSERT ]
-- On FINALLY shift to state 436
-- On CATCH shift to state 283
-- On finally shift to state 438
-- On catches shift to state 439
-- On catchHeader shift to state 441
-- On catch shift to state 444

State 436:
finally -> FINALLY . block [ error WHILE VOID TRY THROW THIS SYNCHRONIZED SWITCH SUPER STRLIT SHORT SEMI RETURN RCURL PLUS NULLLIT NOT NEW MINUS LPAR LONG LCURL INTLIT INT INCREMENT IF IDENTIFIER FOR FLOATLIT FLOAT FINAL ELSE DOUBLELIT DOUBLE DO DECREMENT CONTINUE CHARLIT CHAR BYTE BREAK BOOLEANLIT BOOLEAN BNOT ASSERT ]
-- On LCURL shift to state 243
-- On block shift to state 437

State 437:
finally -> FINALLY block . [ error WHILE VOID TRY THROW THIS SYNCHRONIZED SWITCH SUPER STRLIT SHORT SEMI RETURN RCURL PLUS NULLLIT NOT NEW MINUS LPAR LONG LCURL INTLIT INT INCREMENT IF IDENTIFIER FOR FLOATLIT FLOAT FINAL ELSE DOUBLELIT DOUBLE DO DECREMENT CONTINUE CHARLIT CHAR BYTE BREAK BOOLEANLIT BOOLEAN BNOT ASSERT ]
-- On error reduce production finally -> FINALLY block 
-- On WHILE reduce production finally -> FINALLY block 
-- On VOID reduce production finally -> FINALLY block 
-- On TRY reduce production finally -> FINALLY block 
-- On THROW reduce production finally -> FINALLY block 
-- On THIS reduce production finally -> FINALLY block 
-- On SYNCHRONIZED reduce production finally -> FINALLY block 
-- On SWITCH reduce production finally -> FINALLY block 
-- On SUPER reduce production finally -> FINALLY block 
-- On STRLIT reduce production finally -> FINALLY block 
-- On SHORT reduce production finally -> FINALLY block 
-- On SEMI reduce production finally -> FINALLY block 
-- On RETURN reduce production finally -> FINALLY block 
-- On RCURL reduce production finally -> FINALLY block 
-- On PLUS reduce production finally -> FINALLY block 
-- On NULLLIT reduce production finally -> FINALLY block 
-- On NOT reduce production finally -> FINALLY block 
-- On NEW reduce production finally -> FINALLY block 
-- On MINUS reduce production finally -> FINALLY block 
-- On LPAR reduce production finally -> FINALLY block 
-- On LONG reduce production finally -> FINALLY block 
-- On LCURL reduce production finally -> FINALLY block 
-- On INTLIT reduce production finally -> FINALLY block 
-- On INT reduce production finally -> FINALLY block 
-- On INCREMENT reduce production finally -> FINALLY block 
-- On IF reduce production finally -> FINALLY block 
-- On IDENTIFIER reduce production finally -> FINALLY block 
-- On FOR reduce production finally -> FINALLY block 
-- On FLOATLIT reduce production finally -> FINALLY block 
-- On FLOAT reduce production finally -> FINALLY block 
-- On FINAL reduce production finally -> FINALLY block 
-- On ELSE reduce production finally -> FINALLY block 
-- On DOUBLELIT reduce production finally -> FINALLY block 
-- On DOUBLE reduce production finally -> FINALLY block 
-- On DO reduce production finally -> FINALLY block 
-- On DECREMENT reduce production finally -> FINALLY block 
-- On CONTINUE reduce production finally -> FINALLY block 
-- On CHARLIT reduce production finally -> FINALLY block 
-- On CHAR reduce production finally -> FINALLY block 
-- On BYTE reduce production finally -> FINALLY block 
-- On BREAK reduce production finally -> FINALLY block 
-- On BOOLEANLIT reduce production finally -> FINALLY block 
-- On BOOLEAN reduce production finally -> FINALLY block 
-- On BNOT reduce production finally -> FINALLY block 
-- On ASSERT reduce production finally -> FINALLY block 

State 438:
guardingStmt -> TRY block finally . [ error WHILE VOID TRY THROW THIS SYNCHRONIZED SWITCH SUPER STRLIT SHORT SEMI RETURN RCURL PLUS NULLLIT NOT NEW MINUS LPAR LONG LCURL INTLIT INT INCREMENT IF IDENTIFIER FOR FLOATLIT FLOAT FINAL ELSE DOUBLELIT DOUBLE DO DECREMENT CONTINUE CHARLIT CHAR BYTE BREAK BOOLEANLIT BOOLEAN BNOT ASSERT ]
-- On error reduce production guardingStmt -> TRY block finally 
-- On WHILE reduce production guardingStmt -> TRY block finally 
-- On VOID reduce production guardingStmt -> TRY block finally 
-- On TRY reduce production guardingStmt -> TRY block finally 
-- On THROW reduce production guardingStmt -> TRY block finally 
-- On THIS reduce production guardingStmt -> TRY block finally 
-- On SYNCHRONIZED reduce production guardingStmt -> TRY block finally 
-- On SWITCH reduce production guardingStmt -> TRY block finally 
-- On SUPER reduce production guardingStmt -> TRY block finally 
-- On STRLIT reduce production guardingStmt -> TRY block finally 
-- On SHORT reduce production guardingStmt -> TRY block finally 
-- On SEMI reduce production guardingStmt -> TRY block finally 
-- On RETURN reduce production guardingStmt -> TRY block finally 
-- On RCURL reduce production guardingStmt -> TRY block finally 
-- On PLUS reduce production guardingStmt -> TRY block finally 
-- On NULLLIT reduce production guardingStmt -> TRY block finally 
-- On NOT reduce production guardingStmt -> TRY block finally 
-- On NEW reduce production guardingStmt -> TRY block finally 
-- On MINUS reduce production guardingStmt -> TRY block finally 
-- On LPAR reduce production guardingStmt -> TRY block finally 
-- On LONG reduce production guardingStmt -> TRY block finally 
-- On LCURL reduce production guardingStmt -> TRY block finally 
-- On INTLIT reduce production guardingStmt -> TRY block finally 
-- On INT reduce production guardingStmt -> TRY block finally 
-- On INCREMENT reduce production guardingStmt -> TRY block finally 
-- On IF reduce production guardingStmt -> TRY block finally 
-- On IDENTIFIER reduce production guardingStmt -> TRY block finally 
-- On FOR reduce production guardingStmt -> TRY block finally 
-- On FLOATLIT reduce production guardingStmt -> TRY block finally 
-- On FLOAT reduce production guardingStmt -> TRY block finally 
-- On FINAL reduce production guardingStmt -> TRY block finally 
-- On ELSE reduce production guardingStmt -> TRY block finally 
-- On DOUBLELIT reduce production guardingStmt -> TRY block finally 
-- On DOUBLE reduce production guardingStmt -> TRY block finally 
-- On DO reduce production guardingStmt -> TRY block finally 
-- On DECREMENT reduce production guardingStmt -> TRY block finally 
-- On CONTINUE reduce production guardingStmt -> TRY block finally 
-- On CHARLIT reduce production guardingStmt -> TRY block finally 
-- On CHAR reduce production guardingStmt -> TRY block finally 
-- On BYTE reduce production guardingStmt -> TRY block finally 
-- On BREAK reduce production guardingStmt -> TRY block finally 
-- On BOOLEANLIT reduce production guardingStmt -> TRY block finally 
-- On BOOLEAN reduce production guardingStmt -> TRY block finally 
-- On BNOT reduce production guardingStmt -> TRY block finally 
-- On ASSERT reduce production guardingStmt -> TRY block finally 

State 439:
catches -> catches . catch [ error WHILE VOID TRY THROW THIS SYNCHRONIZED SWITCH SUPER STRLIT SHORT SEMI RETURN RCURL PLUS NULLLIT NOT NEW MINUS LPAR LONG LCURL INTLIT INT INCREMENT IF IDENTIFIER FOR FLOATLIT FLOAT FINALLY FINAL ELSE DOUBLELIT DOUBLE DO DECREMENT CONTINUE CHARLIT CHAR CATCH BYTE BREAK BOOLEANLIT BOOLEAN BNOT ASSERT ]
guardingStmt -> TRY block catches . [ error WHILE VOID TRY THROW THIS SYNCHRONIZED SWITCH SUPER STRLIT SHORT SEMI RETURN RCURL PLUS NULLLIT NOT NEW MINUS LPAR LONG LCURL INTLIT INT INCREMENT IF IDENTIFIER FOR FLOATLIT FLOAT FINAL ELSE DOUBLELIT DOUBLE DO DECREMENT CONTINUE CHARLIT CHAR BYTE BREAK BOOLEANLIT BOOLEAN BNOT ASSERT ]
guardingStmt -> TRY block catches . finally [ error WHILE VOID TRY THROW THIS SYNCHRONIZED SWITCH SUPER STRLIT SHORT SEMI RETURN RCURL PLUS NULLLIT NOT NEW MINUS LPAR LONG LCURL INTLIT INT INCREMENT IF IDENTIFIER FOR FLOATLIT FLOAT FINAL ELSE DOUBLELIT DOUBLE DO DECREMENT CONTINUE CHARLIT CHAR BYTE BREAK BOOLEANLIT BOOLEAN BNOT ASSERT ]
-- On FINALLY shift to state 436
-- On CATCH shift to state 283
-- On finally shift to state 440
-- On catchHeader shift to state 441
-- On catch shift to state 443
-- On error reduce production guardingStmt -> TRY block catches 
-- On WHILE reduce production guardingStmt -> TRY block catches 
-- On VOID reduce production guardingStmt -> TRY block catches 
-- On TRY reduce production guardingStmt -> TRY block catches 
-- On THROW reduce production guardingStmt -> TRY block catches 
-- On THIS reduce production guardingStmt -> TRY block catches 
-- On SYNCHRONIZED reduce production guardingStmt -> TRY block catches 
-- On SWITCH reduce production guardingStmt -> TRY block catches 
-- On SUPER reduce production guardingStmt -> TRY block catches 
-- On STRLIT reduce production guardingStmt -> TRY block catches 
-- On SHORT reduce production guardingStmt -> TRY block catches 
-- On SEMI reduce production guardingStmt -> TRY block catches 
-- On RETURN reduce production guardingStmt -> TRY block catches 
-- On RCURL reduce production guardingStmt -> TRY block catches 
-- On PLUS reduce production guardingStmt -> TRY block catches 
-- On NULLLIT reduce production guardingStmt -> TRY block catches 
-- On NOT reduce production guardingStmt -> TRY block catches 
-- On NEW reduce production guardingStmt -> TRY block catches 
-- On MINUS reduce production guardingStmt -> TRY block catches 
-- On LPAR reduce production guardingStmt -> TRY block catches 
-- On LONG reduce production guardingStmt -> TRY block catches 
-- On LCURL reduce production guardingStmt -> TRY block catches 
-- On INTLIT reduce production guardingStmt -> TRY block catches 
-- On INT reduce production guardingStmt -> TRY block catches 
-- On INCREMENT reduce production guardingStmt -> TRY block catches 
-- On IF reduce production guardingStmt -> TRY block catches 
-- On IDENTIFIER reduce production guardingStmt -> TRY block catches 
-- On FOR reduce production guardingStmt -> TRY block catches 
-- On FLOATLIT reduce production guardingStmt -> TRY block catches 
-- On FLOAT reduce production guardingStmt -> TRY block catches 
-- On FINAL reduce production guardingStmt -> TRY block catches 
-- On ELSE reduce production guardingStmt -> TRY block catches 
-- On DOUBLELIT reduce production guardingStmt -> TRY block catches 
-- On DOUBLE reduce production guardingStmt -> TRY block catches 
-- On DO reduce production guardingStmt -> TRY block catches 
-- On DECREMENT reduce production guardingStmt -> TRY block catches 
-- On CONTINUE reduce production guardingStmt -> TRY block catches 
-- On CHARLIT reduce production guardingStmt -> TRY block catches 
-- On CHAR reduce production guardingStmt -> TRY block catches 
-- On BYTE reduce production guardingStmt -> TRY block catches 
-- On BREAK reduce production guardingStmt -> TRY block catches 
-- On BOOLEANLIT reduce production guardingStmt -> TRY block catches 
-- On BOOLEAN reduce production guardingStmt -> TRY block catches 
-- On BNOT reduce production guardingStmt -> TRY block catches 
-- On ASSERT reduce production guardingStmt -> TRY block catches 

State 440:
guardingStmt -> TRY block catches finally . [ error WHILE VOID TRY THROW THIS SYNCHRONIZED SWITCH SUPER STRLIT SHORT SEMI RETURN RCURL PLUS NULLLIT NOT NEW MINUS LPAR LONG LCURL INTLIT INT INCREMENT IF IDENTIFIER FOR FLOATLIT FLOAT FINAL ELSE DOUBLELIT DOUBLE DO DECREMENT CONTINUE CHARLIT CHAR BYTE BREAK BOOLEANLIT BOOLEAN BNOT ASSERT ]
-- On error reduce production guardingStmt -> TRY block catches finally 
-- On WHILE reduce production guardingStmt -> TRY block catches finally 
-- On VOID reduce production guardingStmt -> TRY block catches finally 
-- On TRY reduce production guardingStmt -> TRY block catches finally 
-- On THROW reduce production guardingStmt -> TRY block catches finally 
-- On THIS reduce production guardingStmt -> TRY block catches finally 
-- On SYNCHRONIZED reduce production guardingStmt -> TRY block catches finally 
-- On SWITCH reduce production guardingStmt -> TRY block catches finally 
-- On SUPER reduce production guardingStmt -> TRY block catches finally 
-- On STRLIT reduce production guardingStmt -> TRY block catches finally 
-- On SHORT reduce production guardingStmt -> TRY block catches finally 
-- On SEMI reduce production guardingStmt -> TRY block catches finally 
-- On RETURN reduce production guardingStmt -> TRY block catches finally 
-- On RCURL reduce production guardingStmt -> TRY block catches finally 
-- On PLUS reduce production guardingStmt -> TRY block catches finally 
-- On NULLLIT reduce production guardingStmt -> TRY block catches finally 
-- On NOT reduce production guardingStmt -> TRY block catches finally 
-- On NEW reduce production guardingStmt -> TRY block catches finally 
-- On MINUS reduce production guardingStmt -> TRY block catches finally 
-- On LPAR reduce production guardingStmt -> TRY block catches finally 
-- On LONG reduce production guardingStmt -> TRY block catches finally 
-- On LCURL reduce production guardingStmt -> TRY block catches finally 
-- On INTLIT reduce production guardingStmt -> TRY block catches finally 
-- On INT reduce production guardingStmt -> TRY block catches finally 
-- On INCREMENT reduce production guardingStmt -> TRY block catches finally 
-- On IF reduce production guardingStmt -> TRY block catches finally 
-- On IDENTIFIER reduce production guardingStmt -> TRY block catches finally 
-- On FOR reduce production guardingStmt -> TRY block catches finally 
-- On FLOATLIT reduce production guardingStmt -> TRY block catches finally 
-- On FLOAT reduce production guardingStmt -> TRY block catches finally 
-- On FINAL reduce production guardingStmt -> TRY block catches finally 
-- On ELSE reduce production guardingStmt -> TRY block catches finally 
-- On DOUBLELIT reduce production guardingStmt -> TRY block catches finally 
-- On DOUBLE reduce production guardingStmt -> TRY block catches finally 
-- On DO reduce production guardingStmt -> TRY block catches finally 
-- On DECREMENT reduce production guardingStmt -> TRY block catches finally 
-- On CONTINUE reduce production guardingStmt -> TRY block catches finally 
-- On CHARLIT reduce production guardingStmt -> TRY block catches finally 
-- On CHAR reduce production guardingStmt -> TRY block catches finally 
-- On BYTE reduce production guardingStmt -> TRY block catches finally 
-- On BREAK reduce production guardingStmt -> TRY block catches finally 
-- On BOOLEANLIT reduce production guardingStmt -> TRY block catches finally 
-- On BOOLEAN reduce production guardingStmt -> TRY block catches finally 
-- On BNOT reduce production guardingStmt -> TRY block catches finally 
-- On ASSERT reduce production guardingStmt -> TRY block catches finally 

State 441:
catch -> catchHeader . block [ error WHILE VOID TRY THROW THIS SYNCHRONIZED SWITCH SUPER STRLIT SHORT SEMI RETURN RCURL PLUS NULLLIT NOT NEW MINUS LPAR LONG LCURL INTLIT INT INCREMENT IF IDENTIFIER FOR FLOATLIT FLOAT FINALLY FINAL ELSE DOUBLELIT DOUBLE DO DECREMENT CONTINUE CHARLIT CHAR CATCH BYTE BREAK BOOLEANLIT BOOLEAN BNOT ASSERT ]
-- On LCURL shift to state 243
-- On block shift to state 442

State 442:
catch -> catchHeader block . [ error WHILE VOID TRY THROW THIS SYNCHRONIZED SWITCH SUPER STRLIT SHORT SEMI RETURN RCURL PLUS NULLLIT NOT NEW MINUS LPAR LONG LCURL INTLIT INT INCREMENT IF IDENTIFIER FOR FLOATLIT FLOAT FINALLY FINAL ELSE DOUBLELIT DOUBLE DO DECREMENT CONTINUE CHARLIT CHAR CATCH BYTE BREAK BOOLEANLIT BOOLEAN BNOT ASSERT ]
-- On error reduce production catch -> catchHeader block 
-- On WHILE reduce production catch -> catchHeader block 
-- On VOID reduce production catch -> catchHeader block 
-- On TRY reduce production catch -> catchHeader block 
-- On THROW reduce production catch -> catchHeader block 
-- On THIS reduce production catch -> catchHeader block 
-- On SYNCHRONIZED reduce production catch -> catchHeader block 
-- On SWITCH reduce production catch -> catchHeader block 
-- On SUPER reduce production catch -> catchHeader block 
-- On STRLIT reduce production catch -> catchHeader block 
-- On SHORT reduce production catch -> catchHeader block 
-- On SEMI reduce production catch -> catchHeader block 
-- On RETURN reduce production catch -> catchHeader block 
-- On RCURL reduce production catch -> catchHeader block 
-- On PLUS reduce production catch -> catchHeader block 
-- On NULLLIT reduce production catch -> catchHeader block 
-- On NOT reduce production catch -> catchHeader block 
-- On NEW reduce production catch -> catchHeader block 
-- On MINUS reduce production catch -> catchHeader block 
-- On LPAR reduce production catch -> catchHeader block 
-- On LONG reduce production catch -> catchHeader block 
-- On LCURL reduce production catch -> catchHeader block 
-- On INTLIT reduce production catch -> catchHeader block 
-- On INT reduce production catch -> catchHeader block 
-- On INCREMENT reduce production catch -> catchHeader block 
-- On IF reduce production catch -> catchHeader block 
-- On IDENTIFIER reduce production catch -> catchHeader block 
-- On FOR reduce production catch -> catchHeader block 
-- On FLOATLIT reduce production catch -> catchHeader block 
-- On FLOAT reduce production catch -> catchHeader block 
-- On FINALLY reduce production catch -> catchHeader block 
-- On FINAL reduce production catch -> catchHeader block 
-- On ELSE reduce production catch -> catchHeader block 
-- On DOUBLELIT reduce production catch -> catchHeader block 
-- On DOUBLE reduce production catch -> catchHeader block 
-- On DO reduce production catch -> catchHeader block 
-- On DECREMENT reduce production catch -> catchHeader block 
-- On CONTINUE reduce production catch -> catchHeader block 
-- On CHARLIT reduce production catch -> catchHeader block 
-- On CHAR reduce production catch -> catchHeader block 
-- On CATCH reduce production catch -> catchHeader block 
-- On BYTE reduce production catch -> catchHeader block 
-- On BREAK reduce production catch -> catchHeader block 
-- On BOOLEANLIT reduce production catch -> catchHeader block 
-- On BOOLEAN reduce production catch -> catchHeader block 
-- On BNOT reduce production catch -> catchHeader block 
-- On ASSERT reduce production catch -> catchHeader block 

State 443:
catches -> catches catch . [ error WHILE VOID TRY THROW THIS SYNCHRONIZED SWITCH SUPER STRLIT SHORT SEMI RETURN RCURL PLUS NULLLIT NOT NEW MINUS LPAR LONG LCURL INTLIT INT INCREMENT IF IDENTIFIER FOR FLOATLIT FLOAT FINALLY FINAL ELSE DOUBLELIT DOUBLE DO DECREMENT CONTINUE CHARLIT CHAR CATCH BYTE BREAK BOOLEANLIT BOOLEAN BNOT ASSERT ]
-- On error reduce production catches -> catches catch 
-- On WHILE reduce production catches -> catches catch 
-- On VOID reduce production catches -> catches catch 
-- On TRY reduce production catches -> catches catch 
-- On THROW reduce production catches -> catches catch 
-- On THIS reduce production catches -> catches catch 
-- On SYNCHRONIZED reduce production catches -> catches catch 
-- On SWITCH reduce production catches -> catches catch 
-- On SUPER reduce production catches -> catches catch 
-- On STRLIT reduce production catches -> catches catch 
-- On SHORT reduce production catches -> catches catch 
-- On SEMI reduce production catches -> catches catch 
-- On RETURN reduce production catches -> catches catch 
-- On RCURL reduce production catches -> catches catch 
-- On PLUS reduce production catches -> catches catch 
-- On NULLLIT reduce production catches -> catches catch 
-- On NOT reduce production catches -> catches catch 
-- On NEW reduce production catches -> catches catch 
-- On MINUS reduce production catches -> catches catch 
-- On LPAR reduce production catches -> catches catch 
-- On LONG reduce production catches -> catches catch 
-- On LCURL reduce production catches -> catches catch 
-- On INTLIT reduce production catches -> catches catch 
-- On INT reduce production catches -> catches catch 
-- On INCREMENT reduce production catches -> catches catch 
-- On IF reduce production catches -> catches catch 
-- On IDENTIFIER reduce production catches -> catches catch 
-- On FOR reduce production catches -> catches catch 
-- On FLOATLIT reduce production catches -> catches catch 
-- On FLOAT reduce production catches -> catches catch 
-- On FINALLY reduce production catches -> catches catch 
-- On FINAL reduce production catches -> catches catch 
-- On ELSE reduce production catches -> catches catch 
-- On DOUBLELIT reduce production catches -> catches catch 
-- On DOUBLE reduce production catches -> catches catch 
-- On DO reduce production catches -> catches catch 
-- On DECREMENT reduce production catches -> catches catch 
-- On CONTINUE reduce production catches -> catches catch 
-- On CHARLIT reduce production catches -> catches catch 
-- On CHAR reduce production catches -> catches catch 
-- On CATCH reduce production catches -> catches catch 
-- On BYTE reduce production catches -> catches catch 
-- On BREAK reduce production catches -> catches catch 
-- On BOOLEANLIT reduce production catches -> catches catch 
-- On BOOLEAN reduce production catches -> catches catch 
-- On BNOT reduce production catches -> catches catch 
-- On ASSERT reduce production catches -> catches catch 

State 444:
catches -> catch . [ error WHILE VOID TRY THROW THIS SYNCHRONIZED SWITCH SUPER STRLIT SHORT SEMI RETURN RCURL PLUS NULLLIT NOT NEW MINUS LPAR LONG LCURL INTLIT INT INCREMENT IF IDENTIFIER FOR FLOATLIT FLOAT FINALLY FINAL ELSE DOUBLELIT DOUBLE DO DECREMENT CONTINUE CHARLIT CHAR CATCH BYTE BREAK BOOLEANLIT BOOLEAN BNOT ASSERT ]
-- On error reduce production catches -> catch 
-- On WHILE reduce production catches -> catch 
-- On VOID reduce production catches -> catch 
-- On TRY reduce production catches -> catch 
-- On THROW reduce production catches -> catch 
-- On THIS reduce production catches -> catch 
-- On SYNCHRONIZED reduce production catches -> catch 
-- On SWITCH reduce production catches -> catch 
-- On SUPER reduce production catches -> catch 
-- On STRLIT reduce production catches -> catch 
-- On SHORT reduce production catches -> catch 
-- On SEMI reduce production catches -> catch 
-- On RETURN reduce production catches -> catch 
-- On RCURL reduce production catches -> catch 
-- On PLUS reduce production catches -> catch 
-- On NULLLIT reduce production catches -> catch 
-- On NOT reduce production catches -> catch 
-- On NEW reduce production catches -> catch 
-- On MINUS reduce production catches -> catch 
-- On LPAR reduce production catches -> catch 
-- On LONG reduce production catches -> catch 
-- On LCURL reduce production catches -> catch 
-- On INTLIT reduce production catches -> catch 
-- On INT reduce production catches -> catch 
-- On INCREMENT reduce production catches -> catch 
-- On IF reduce production catches -> catch 
-- On IDENTIFIER reduce production catches -> catch 
-- On FOR reduce production catches -> catch 
-- On FLOATLIT reduce production catches -> catch 
-- On FLOAT reduce production catches -> catch 
-- On FINALLY reduce production catches -> catch 
-- On FINAL reduce production catches -> catch 
-- On ELSE reduce production catches -> catch 
-- On DOUBLELIT reduce production catches -> catch 
-- On DOUBLE reduce production catches -> catch 
-- On DO reduce production catches -> catch 
-- On DECREMENT reduce production catches -> catch 
-- On CONTINUE reduce production catches -> catch 
-- On CHARLIT reduce production catches -> catch 
-- On CHAR reduce production catches -> catch 
-- On CATCH reduce production catches -> catch 
-- On BYTE reduce production catches -> catch 
-- On BREAK reduce production catches -> catch 
-- On BOOLEANLIT reduce production catches -> catch 
-- On BOOLEAN reduce production catches -> catch 
-- On BNOT reduce production catches -> catch 
-- On ASSERT reduce production catches -> catch 

State 445:
iterStmt -> WHILE LPAR expression RPAR statement . [ error WHILE VOID TRY THROW THIS SYNCHRONIZED SWITCH SUPER STRLIT SHORT SEMI RETURN RCURL PLUS NULLLIT NOT NEW MINUS LPAR LONG LCURL INTLIT INT INCREMENT IF IDENTIFIER FOR FLOATLIT FLOAT FINAL ELSE DOUBLELIT DOUBLE DO DECREMENT CONTINUE CHARLIT CHAR BYTE BREAK BOOLEANLIT BOOLEAN BNOT ASSERT ]
-- On error reduce production iterStmt -> WHILE LPAR expression RPAR statement 
-- On WHILE reduce production iterStmt -> WHILE LPAR expression RPAR statement 
-- On VOID reduce production iterStmt -> WHILE LPAR expression RPAR statement 
-- On TRY reduce production iterStmt -> WHILE LPAR expression RPAR statement 
-- On THROW reduce production iterStmt -> WHILE LPAR expression RPAR statement 
-- On THIS reduce production iterStmt -> WHILE LPAR expression RPAR statement 
-- On SYNCHRONIZED reduce production iterStmt -> WHILE LPAR expression RPAR statement 
-- On SWITCH reduce production iterStmt -> WHILE LPAR expression RPAR statement 
-- On SUPER reduce production iterStmt -> WHILE LPAR expression RPAR statement 
-- On STRLIT reduce production iterStmt -> WHILE LPAR expression RPAR statement 
-- On SHORT reduce production iterStmt -> WHILE LPAR expression RPAR statement 
-- On SEMI reduce production iterStmt -> WHILE LPAR expression RPAR statement 
-- On RETURN reduce production iterStmt -> WHILE LPAR expression RPAR statement 
-- On RCURL reduce production iterStmt -> WHILE LPAR expression RPAR statement 
-- On PLUS reduce production iterStmt -> WHILE LPAR expression RPAR statement 
-- On NULLLIT reduce production iterStmt -> WHILE LPAR expression RPAR statement 
-- On NOT reduce production iterStmt -> WHILE LPAR expression RPAR statement 
-- On NEW reduce production iterStmt -> WHILE LPAR expression RPAR statement 
-- On MINUS reduce production iterStmt -> WHILE LPAR expression RPAR statement 
-- On LPAR reduce production iterStmt -> WHILE LPAR expression RPAR statement 
-- On LONG reduce production iterStmt -> WHILE LPAR expression RPAR statement 
-- On LCURL reduce production iterStmt -> WHILE LPAR expression RPAR statement 
-- On INTLIT reduce production iterStmt -> WHILE LPAR expression RPAR statement 
-- On INT reduce production iterStmt -> WHILE LPAR expression RPAR statement 
-- On INCREMENT reduce production iterStmt -> WHILE LPAR expression RPAR statement 
-- On IF reduce production iterStmt -> WHILE LPAR expression RPAR statement 
-- On IDENTIFIER reduce production iterStmt -> WHILE LPAR expression RPAR statement 
-- On FOR reduce production iterStmt -> WHILE LPAR expression RPAR statement 
-- On FLOATLIT reduce production iterStmt -> WHILE LPAR expression RPAR statement 
-- On FLOAT reduce production iterStmt -> WHILE LPAR expression RPAR statement 
-- On FINAL reduce production iterStmt -> WHILE LPAR expression RPAR statement 
-- On ELSE reduce production iterStmt -> WHILE LPAR expression RPAR statement 
-- On DOUBLELIT reduce production iterStmt -> WHILE LPAR expression RPAR statement 
-- On DOUBLE reduce production iterStmt -> WHILE LPAR expression RPAR statement 
-- On DO reduce production iterStmt -> WHILE LPAR expression RPAR statement 
-- On DECREMENT reduce production iterStmt -> WHILE LPAR expression RPAR statement 
-- On CONTINUE reduce production iterStmt -> WHILE LPAR expression RPAR statement 
-- On CHARLIT reduce production iterStmt -> WHILE LPAR expression RPAR statement 
-- On CHAR reduce production iterStmt -> WHILE LPAR expression RPAR statement 
-- On BYTE reduce production iterStmt -> WHILE LPAR expression RPAR statement 
-- On BREAK reduce production iterStmt -> WHILE LPAR expression RPAR statement 
-- On BOOLEANLIT reduce production iterStmt -> WHILE LPAR expression RPAR statement 
-- On BOOLEAN reduce production iterStmt -> WHILE LPAR expression RPAR statement 
-- On BNOT reduce production iterStmt -> WHILE LPAR expression RPAR statement 
-- On ASSERT reduce production iterStmt -> WHILE LPAR expression RPAR statement 

State 446:
block -> LCURL RCURL . [ # ]
-- On # reduce production block -> LCURL RCURL 

State 447:
block -> LCURL localVariableDeclAndStmts . RCURL [ # ]
localVariableDeclAndStmts -> localVariableDeclAndStmts . localVariableDeclOrStmt [ error WHILE VOID TRY THROW THIS SYNCHRONIZED SWITCH SUPER STRLIT SHORT SEMI RETURN RCURL PLUS NULLLIT NOT NEW MINUS LPAR LONG LCURL INTLIT INT INCREMENT IF IDENTIFIER FOR FLOATLIT FLOAT FINAL DOUBLELIT DOUBLE DO DECREMENT CONTINUE CHARLIT CHAR BYTE BREAK BOOLEANLIT BOOLEAN BNOT ASSERT ]
-- On error shift to state 3
-- On WHILE shift to state 4
-- On VOID shift to state 6
-- On TRY shift to state 208
-- On THROW shift to state 210
-- On THIS shift to state 7
-- On SYNCHRONIZED shift to state 213
-- On SWITCH shift to state 217
-- On SUPER shift to state 8
-- On STRLIT shift to state 9
-- On SHORT shift to state 10
-- On SEMI shift to state 238
-- On RETURN shift to state 239
-- On RCURL shift to state 448
-- On PLUS shift to state 11
-- On NULLLIT shift to state 12
-- On NOT shift to state 13
-- On NEW shift to state 14
-- On MINUS shift to state 26
-- On LPAR shift to state 27
-- On LONG shift to state 15
-- On LCURL shift to state 243
-- On INTLIT shift to state 28
-- On INT shift to state 16
-- On INCREMENT shift to state 29
-- On IF shift to state 245
-- On IDENTIFIER shift to state 249
-- On FOR shift to state 251
-- On FLOATLIT shift to state 31
-- On FLOAT shift to state 18
-- On FINAL shift to state 254
-- On DOUBLELIT shift to state 32
-- On DOUBLE shift to state 19
-- On DO shift to state 274
-- On DECREMENT shift to state 33
-- On CONTINUE shift to state 387
-- On CHARLIT shift to state 34
-- On CHAR shift to state 20
-- On BYTE shift to state 21
-- On BREAK shift to state 391
-- On BOOLEANLIT shift to state 35
-- On BOOLEAN shift to state 22
-- On BNOT shift to state 36
-- On ASSERT shift to state 395
-- On unaryExpression shift to state 44
-- On typeSpecifier shift to state 422
-- On typeName shift to state 130
-- On statement shift to state 423
-- On specialName shift to state 38
-- On shiftExpression shift to state 58
-- On selectStmt shift to state 402
-- On relationalExpression shift to state 79
-- On realPostfixExpression shift to state 39
-- On qualifiedName shift to state 424
-- On primitiveType shift to state 425
-- On primaryExpression shift to state 64
-- On postfixExpression shift to state 65
-- On plainNewAllocationExpression shift to state 68
-- On notJustName shift to state 69
-- On newAllocationExpression shift to state 72
-- On multiplicativeExpression shift to state 73
-- On methodCall shift to state 75
-- On methodAccess shift to state 76
-- On logicalUnaryOperator shift to state 83
-- On logicalUnaryExpression shift to state 85
-- On localVariableDeclStmt shift to state 426
-- On localVariableDeclOrStmt shift to state 430
-- On labelStmt shift to state 403
-- On jumpStmt shift to state 404
-- On iterStmt shift to state 405
-- On inclusiveOrExpression shift to state 90
-- On guardingStmt shift to state 406
-- On fieldAccess shift to state 86
-- On expressionStmt shift to state 407
-- On expression shift to state 357
-- On exclusiveOrExpression shift to state 111
-- On equalityExpression shift to state 94
-- On emptyStmt shift to state 409
-- On conditionalOrExpression shift to state 112
-- On conditionalExpression shift to state 151
-- On conditionalAndExpression shift to state 117
-- On complexPrimaryNoParenthesis shift to state 87
-- On complexPrimary shift to state 88
-- On classAllocationExpression shift to state 100
-- On castExpression shift to state 103
-- On block shift to state 410
-- On assignmentExpression shift to state 152
-- On assertStmt shift to state 411
-- On arrayAllocationExpression shift to state 104
-- On arrayAccess shift to state 120
-- On arithmeticUnaryOperator shift to state 121
-- On andExpression shift to state 123
-- On additiveExpression shift to state 140

State 448:
block -> LCURL localVariableDeclAndStmts RCURL . [ # ]
-- On # reduce production block -> LCURL localVariableDeclAndStmts RCURL 

State 449:
compilationUnit' -> compilationUnit . [ # ]
-- On # accept compilationUnit

State 450:
compilationUnit -> block . [ # ]
-- On # reduce production compilationUnit -> block 

